{"version":3,"sources":["../src/index.ts","../src/coin-quantity.ts","../src/provider.ts","../src/__generated__/operations.ts","../src/memory-cache.ts","../src/transaction-request/input.ts","../src/transaction-request/output.ts","../src/transaction-request/transaction-request.ts","../src/resource.ts","../src/utils/receipts.ts","../src/utils/fee.ts","../src/utils/block-explorer.ts","../src/utils/json.ts","../src/utils/sleep.ts","../src/utils/time.ts","../src/transaction-request/errors.ts","../src/transaction-request/witness.ts","../src/transaction-request/create-transaction-request.ts","../src/transaction-request/storage-slot.ts","../src/transaction-request/script-transaction-request.ts","../src/transaction-request/scripts.ts","../src/transaction-request/utils.ts","../src/transaction-response/transaction-response.ts","../src/transaction-summary/assemble-transaction-summary.ts","../src/transaction-summary/date.ts","../src/transaction-summary/operations.ts","../src/transaction-summary/call.ts","../src/transaction-summary/input.ts","../src/transaction-summary/output.ts","../src/transaction-summary/types.ts","../src/transaction-summary/receipt.ts","../src/transaction-summary/status.ts","../src/transaction-response/getDecodedLogs.ts","../src/transaction-summary/get-transaction-summary.ts"],"sourcesContent":["/// <reference types=\"graphql\" />\n\nexport * from './coin-quantity';\nexport * from './coin';\nexport * from './provider';\nexport * from './message';\nexport * from './resource';\nexport { default as Provider } from './provider';\nexport * from './transaction-request';\nexport * from './transaction-response';\nexport * from './transaction-summary';\nexport * from './utils';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { BaseAssetId } from '@fuel-ts/address/configs';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\n\nexport type CoinQuantityLike =\n  | [amount: BigNumberish, assetId?: BytesLike, max?: BigNumberish]\n  | { amount: BigNumberish; assetId?: BytesLike; max?: BigNumberish };\nexport type CoinQuantity = { amount: BN; assetId: string; max?: BN };\n\n/** @hidden */\nexport const coinQuantityfy = (coinQuantityLike: CoinQuantityLike): CoinQuantity => {\n  let assetId;\n  let amount;\n  let max;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1] ?? BaseAssetId;\n    max = coinQuantityLike[2] ?? undefined;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId ?? BaseAssetId;\n    max = coinQuantityLike.max ?? undefined;\n  }\n\n  return {\n    assetId: hexlify(assetId),\n    amount: bn(amount),\n    max: max ? bn(max) : undefined,\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Network } from '@ethersproject/networks';\nimport { Address } from '@fuel-ts/address';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { max, bn } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  InputType,\n  TransactionType,\n  InputMessageCoder,\n  TransactionCoder,\n} from '@fuel-ts/transactions';\nimport { print } from 'graphql';\nimport { GraphQLClient } from 'graphql-request';\nimport type { Client } from 'graphql-sse';\nimport { createClient } from 'graphql-sse';\nimport { clone } from 'ramda';\n\nimport { getSdk as getOperationsSdk } from './__generated__/operations';\nimport type {\n  GqlChainInfoFragmentFragment,\n  GqlGetBlocksQueryVariables,\n} from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { CoinQuantity, CoinQuantityLike } from './coin-quantity';\nimport { coinQuantityfy } from './coin-quantity';\nimport { MemoryCache } from './memory-cache';\nimport type { Message, MessageCoin, MessageProof, MessageStatus } from './message';\nimport type { ExcludeResourcesOption, Resource } from './resource';\nimport type {\n  TransactionRequestLike,\n  TransactionRequest,\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n} from './transaction-request';\nimport { transactionRequestify, ScriptTransactionRequest } from './transaction-request';\nimport type { TransactionResultReceipt } from './transaction-response';\nimport { TransactionResponse } from './transaction-response';\nimport { processGqlReceipt } from './transaction-summary/receipt';\nimport { calculateTransactionFee, fromUnixToTai64, getReceiptsWithMissingData } from './utils';\n\nconst MAX_RETRIES = 10;\n\nexport type CallResult = {\n  receipts: TransactionResultReceipt[];\n};\n\n/**\n * A Fuel block\n */\nexport type Block = {\n  id: string;\n  height: BN;\n  time: string;\n  transactionIds: string[];\n};\n\n/**\n * Deployed Contract bytecode and contract id\n */\nexport type ContractResult = {\n  id: string;\n  bytecode: string;\n};\n\ntype ConsensusParameters = {\n  contractMaxSize: BN;\n  maxInputs: BN;\n  maxOutputs: BN;\n  maxWitnesses: BN;\n  maxGasPerTx: BN;\n  maxScriptLength: BN;\n  maxScriptDataLength: BN;\n  maxStorageSlots: BN;\n  maxPredicateLength: BN;\n  maxPredicateDataLength: BN;\n  maxGasPerPredicate: BN;\n  gasPriceFactor: BN;\n  gasPerByte: BN;\n  maxMessageDataLength: BN;\n  chainId: BN;\n};\n\n/**\n * Chain information\n */\nexport type ChainInfo = {\n  name: string;\n  baseChainHeight: BN;\n  peerCount: number;\n  consensusParameters: ConsensusParameters;\n  latestBlock: {\n    id: string;\n    height: BN;\n    time: string;\n    transactions: Array<{ id: string }>;\n  };\n};\n\n/**\n * Node information\n */\nexport type NodeInfo = {\n  utxoValidation: boolean;\n  vmBacktrace: boolean;\n  minGasPrice: BN;\n  maxTx: BN;\n  maxDepth: BN;\n  nodeVersion: string;\n};\n\nexport type NodeInfoAndConsensusParameters = {\n  minGasPrice: BN;\n  nodeVersion: string;\n  gasPerByte: BN;\n  gasPriceFactor: BN;\n  maxGasPerTx: BN;\n};\n\n// #region cost-estimation-1\nexport type TransactionCost = {\n  minGasPrice: BN;\n  gasPrice: BN;\n  gasUsed: BN;\n  fee: BN;\n};\n// #endregion cost-estimation-1\n\nconst processGqlChain = (chain: GqlChainInfoFragmentFragment): ChainInfo => {\n  const { name, baseChainHeight, peerCount, consensusParameters, latestBlock } = chain;\n\n  return {\n    name,\n    baseChainHeight: bn(baseChainHeight),\n    peerCount,\n    consensusParameters: {\n      contractMaxSize: bn(consensusParameters.contractMaxSize),\n      maxInputs: bn(consensusParameters.maxInputs),\n      maxOutputs: bn(consensusParameters.maxOutputs),\n      maxWitnesses: bn(consensusParameters.maxWitnesses),\n      maxGasPerTx: bn(consensusParameters.maxGasPerTx),\n      maxScriptLength: bn(consensusParameters.maxScriptLength),\n      maxScriptDataLength: bn(consensusParameters.maxScriptDataLength),\n      maxStorageSlots: bn(consensusParameters.maxStorageSlots),\n      maxPredicateLength: bn(consensusParameters.maxPredicateLength),\n      maxPredicateDataLength: bn(consensusParameters.maxPredicateDataLength),\n      maxGasPerPredicate: bn(consensusParameters.maxGasPerPredicate),\n      gasPriceFactor: bn(consensusParameters.gasPriceFactor),\n      gasPerByte: bn(consensusParameters.gasPerByte),\n      maxMessageDataLength: bn(consensusParameters.maxMessageDataLength),\n      chainId: bn(consensusParameters.chainId),\n    },\n    latestBlock: {\n      id: latestBlock.id,\n      height: bn(latestBlock.header.height),\n      time: latestBlock.header.time,\n      transactions: latestBlock.transactions.map((i) => ({\n        id: i.id,\n      })),\n    },\n  };\n};\n\n/**\n * @hidden\n *\n * Cursor pagination arguments\n *\n * https://relay.dev/graphql/connections.htm#sec-Arguments\n */\nexport type CursorPaginationArgs = {\n  /** Forward pagination limit */\n  first?: number | null;\n  /** Forward pagination cursor */\n  after?: string | null;\n  /** Backward pagination limit  */\n  last?: number | null;\n  /** Backward pagination cursor */\n  before?: string | null;\n};\n\nexport type BuildPredicateOptions = {\n  fundTransaction?: boolean;\n} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;\n\nexport type FetchRequestOptions = {\n  method: 'POST';\n  headers: { [key: string]: string };\n  body: string;\n};\n\nexport type CustomFetch<R extends Response = Response> = (\n  url: string,\n  options: FetchRequestOptions,\n  providerOptions?: Partial<Omit<ProviderOptions<R>, 'fetch'>>\n) => Promise<R>;\n/*\n * Provider initialization options\n */\nexport type ProviderOptions<FetchResponse extends Response = Response> = {\n  fetch: CustomFetch<FetchResponse> | undefined;\n  cacheUtxo: number | undefined;\n  timeout: number | undefined;\n};\n/**\n * Provider Call transaction params\n */\nexport type ProviderCallParams = {\n  utxoValidation?: boolean;\n};\n\n/**\n * URL - Consensus Params mapping.\n */\ntype ChainInfoCache = Record<string, ChainInfo>;\n\n/**\n * URL - Node Info mapping.\n */\ntype NodeInfoCache = Record<string, NodeInfo>;\n\n/**\n * A provider for connecting to a node\n */\nexport default class Provider {\n  operations!: ReturnType<typeof getOperationsSdk>;\n  #subscriptionClient!: Client;\n\n  cache?: MemoryCache;\n  options: ProviderOptions = {\n    timeout: undefined,\n    cacheUtxo: undefined,\n    fetch: undefined,\n  };\n\n  private static getFetchFn(options: ProviderOptions) {\n    return options.fetch !== undefined\n      ? options.fetch\n      : (url: string, request: FetchRequestOptions) =>\n          fetch(url, {\n            ...request,\n            signal:\n              options.timeout !== undefined ? AbortSignal.timeout(options.timeout) : undefined,\n          });\n  }\n\n  static chainInfoCache: ChainInfoCache = {};\n  static nodeInfoCache: NodeInfoCache = {};\n\n  /**\n   * Constructor to initialize a Provider.\n   *\n   * @param url - GraphQL endpoint of the Fuel node\n   * @param chainInfo - Chain info of the Fuel node\n   * @param options - Additional options for the provider\n   * @hidden\n   */\n  protected constructor(\n    /** GraphQL endpoint of the Fuel node */\n    public url: string,\n    options: Partial<ProviderOptions> = {}\n  ) {\n    this.options = { ...this.options, ...options };\n    this.createOperations();\n    this.cache = this.options.cacheUtxo ? new MemoryCache(this.options.cacheUtxo) : undefined;\n  }\n\n  /**\n   * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.\n   * @param url - GraphQL endpoint of the Fuel node\n   * @param options - Additional options for the provider\n   */\n  static async create(url: string, options: Partial<ProviderOptions> = {}) {\n    const provider = new Provider(url, options);\n    await provider.fetchChainAndNodeInfo();\n    return provider;\n  }\n\n  /**\n   * Returns the cached chainInfo for the current URL.\n   */\n  getChain() {\n    const chain = Provider.chainInfoCache[this.url];\n    if (!chain) {\n      throw new FuelError(\n        ErrorCode.CHAIN_INFO_CACHE_EMPTY,\n        'Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider.'\n      );\n    }\n    return chain;\n  }\n\n  /**\n   * Returns the cached nodeInfo for the current URL.\n   */\n  getNode() {\n    const node = Provider.nodeInfoCache[this.url];\n    if (!node) {\n      throw new FuelError(\n        ErrorCode.NODE_INFO_CACHE_EMPTY,\n        'Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider.'\n      );\n    }\n    return node;\n  }\n\n  /**\n   * Returns some helpful parameters related to gas fees.\n   */\n  getGasConfig() {\n    const { minGasPrice } = this.getNode();\n    const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte } =\n      this.getChain().consensusParameters;\n    return {\n      minGasPrice,\n      maxGasPerTx,\n      maxGasPerPredicate,\n      gasPriceFactor,\n      gasPerByte,\n    };\n  }\n\n  /**\n   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.\n   */\n  async switchUrl(url: string) {\n    this.url = url;\n    this.createOperations();\n    await this.fetchChainAndNodeInfo();\n  }\n\n  /**\n   * Retrieves and caches chain and node information if not already cached.\n   *\n   * - Checks the cache for existing chain and node information based on the current URL.\n   * - If not found in cache, fetches the information, caches it, and then returns the data.\n   *\n   * @returns NodeInfo and Chain\n   */\n  async fetchChainAndNodeInfo() {\n    let nodeInfo = Provider.nodeInfoCache[this.url];\n    let chain = Provider.chainInfoCache[this.url];\n\n    if (!nodeInfo) {\n      nodeInfo = await this.fetchNode();\n      Provider.nodeInfoCache[this.url] = nodeInfo;\n    }\n\n    if (!chain) {\n      chain = await this.fetchChain();\n      Provider.chainInfoCache[this.url] = chain;\n    }\n\n    return {\n      chain,\n      nodeInfo,\n    };\n  }\n\n  /**\n   * Create GraphQL client and set operations.\n   *\n   * @param url - The URL of the Fuel node\n   * @param options - Additional options for the provider\n   * @returns The operation SDK object\n   */\n  private createOperations() {\n    const fetchFn = Provider.getFetchFn(this.options);\n    const gqlClient = new GraphQLClient(this.url, {\n      fetch: (nodeUrl: string, request: FetchRequestOptions) =>\n        fetchFn(nodeUrl, request, this.options),\n    });\n\n    if (this.#subscriptionClient) this.#subscriptionClient.dispose();\n    this.#subscriptionClient = Provider.createSubscriptionClient(this.url, fetchFn, this.options);\n\n    // @ts-expect-error This is due to this function being generic and us using multiple libraries. Its type is specified when calling a specific operation via provider.operations.xyz.\n    this.operations = getOperationsSdk((query, vars) => {\n      const isSubscription =\n        (query.definitions.find((x) => x.kind === 'OperationDefinition') as { operation: string })\n          ?.operation === 'subscription';\n      if (isSubscription) {\n        return this.#subscriptionClient.iterate({\n          query: print(query),\n          variables: vars as Record<string, unknown>,\n        });\n      }\n\n      return gqlClient.request(query, vars);\n    });\n  }\n\n  private static createSubscriptionClient(\n    url: string,\n    fetchFn: ReturnType<typeof Provider.getFetchFn>,\n    options: ProviderOptions\n  ) {\n    return createClient({\n      url: `${url}-sub`,\n      onMessage: (msg) => {\n        /*\n          This is the only place where I've managed to wedge in error throwing\n          without the error being converted to the graphql-sse library's NetworkError or being silently ignored.\n          These are errors returned from the node as a field of the `data` property with a 200 response code,\n          so they aren't treated as errors by the graphql-sse library.\n          This function (onMessage) gets called after a fetch but before message processing.\n          So the fetchFn below gets called first, the node returns errors, then this function is called.\n          The _isError property is added in the response processing in the fetchFn as a way to differentiate between errors and successful responses.\n          See here: https://github.com/enisdenjo/graphql-sse/blob/370ec133f8ca9c7b763a6ca0223c756a09169c59/src/client.ts#L872\n        */\n        if ((msg.data as { _isError: boolean })._isError) {\n          throw new FuelError(ErrorCode.FUEL_NODE_ERROR, JSON.stringify(msg.data?.errors));\n        }\n      },\n      fetchFn: async (\n        subscriptionUrl: string,\n        request: FetchRequestOptions & { signal: AbortSignal }\n      ) => Provider.adaptSubscriptionResponse(await fetchFn(subscriptionUrl, request, options)),\n    });\n  }\n\n  /**\n    The subscription response processing serves two purposes:\n    1. To add an `event` field which is mandated by the graphql-sse library (not by the SSE protocol)\n    (see [the library's protocol](https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md))\n    2. To process the node's response because it's a different format to the types generated by graphql-codegen.\n  */\n  private static async adaptSubscriptionResponse(originalResponse: Response): Promise<Response> {\n    const originalResponseText = await originalResponse.text();\n    const originalResponseData = JSON.parse(originalResponseText.split('data:')[1]);\n    const data = originalResponseData.data;\n    const errors = originalResponseData.errors;\n\n    let text = 'event:next';\n    text += `\\ndata:${JSON.stringify(data ?? { _isError: true, errors })}`;\n    text += '\\n\\n';\n    return new Response(text, originalResponse);\n  }\n\n  /**\n   * Returns the version of the connected node.\n   *\n   * @returns A promise that resolves to the version string.\n   */\n  async getVersion(): Promise<string> {\n    const {\n      nodeInfo: { nodeVersion },\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n\n  /**\n   * @hidden\n   *\n   * Returns the network configuration of the connected Fuel node.\n   *\n   * @returns A promise that resolves to the network configuration object\n   */\n  async getNetwork(): Promise<Network> {\n    return Promise.resolve({\n      name: 'fuelv2',\n      chainId: 0xdeadbeef,\n    });\n  }\n\n  /**\n   * Returns the block number.\n   *\n   * @returns A promise that resolves to the block number\n   */\n  async getBlockNumber(): Promise<BN> {\n    const { chain } = await this.operations.getChain();\n    return bn(chain.latestBlock.header.height, 10);\n  }\n\n  /**\n   * Returns the chain information.\n   * @param url - The URL of the Fuel node\n   * @returns NodeInfo object\n   */\n  async fetchNode(): Promise<NodeInfo> {\n    const { nodeInfo } = await this.operations.getNodeInfo();\n    return {\n      maxDepth: bn(nodeInfo.maxDepth),\n      maxTx: bn(nodeInfo.maxTx),\n      minGasPrice: bn(nodeInfo.minGasPrice),\n      nodeVersion: nodeInfo.nodeVersion,\n      utxoValidation: nodeInfo.utxoValidation,\n      vmBacktrace: nodeInfo.vmBacktrace,\n    };\n  }\n\n  /**\n   * Fetches the `chainInfo` for the given node URL.\n   * @param url - The URL of the Fuel node\n   * @returns ChainInfo object\n   */\n  async fetchChain(): Promise<ChainInfo> {\n    const { chain } = await this.operations.getChain();\n    return processGqlChain(chain);\n  }\n\n  /**\n   * Returns the chain ID\n   * @returns A promise that resolves to the chain ID number\n   */\n  getChainId() {\n    const {\n      consensusParameters: { chainId },\n    } = this.getChain();\n    return chainId.toNumber();\n  }\n\n  /**\n   * @hidden\n   */\n  #cacheInputs(inputs: TransactionRequestInput[]): void {\n    if (!this.cache) {\n      return;\n    }\n\n    inputs.forEach((input) => {\n      if (input.type === InputType.Coin) {\n        this.cache?.set(input.id);\n      }\n    });\n  }\n\n  /**\n   * Submits a transaction to the chain to be executed.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @returns A promise that resolves to the transaction response object.\n   */\n  // #region Provider-sendTransaction\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    this.#cacheInputs(transactionRequest.inputs);\n    await this.estimateTxDependencies(transactionRequest);\n    // #endregion Provider-sendTransaction\n\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest, 0);\n\n    // Fail transaction before submit to avoid submit failure\n    // Resulting in lost of funds on a OutOfGas situation.\n    if (bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {\n      throw new FuelError(\n        ErrorCode.GAS_PRICE_TOO_LOW,\n        `Gas limit '${transactionRequest.gasLimit}' is lower than the required: '${gasUsed}'.`\n      );\n    } else if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {\n      throw new FuelError(\n        ErrorCode.GAS_LIMIT_TOO_LOW,\n        `Gas price '${transactionRequest.gasPrice}' is lower than the required: '${minGasPrice}'.`\n      );\n    }\n\n    const {\n      submit: { id: transactionId },\n    } = await this.operations.submit({ encodedTransaction });\n\n    const response = new TransactionResponse(transactionId, this);\n    return response;\n  }\n\n  /**\n   * Executes a transaction without actually submitting it to the chain.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param utxoValidation - Additional provider call parameters.\n   * @returns A promise that resolves to the call result object.\n   */\n  async call(\n    transactionRequestLike: TransactionRequestLike,\n    { utxoValidation }: ProviderCallParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.estimateTxDependencies(transactionRequest);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: utxoValidation || false,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Verifies whether enough gas is available to complete transaction.\n   *\n   * @param transactionRequest - The transaction request object.\n   * @returns A promise that resolves to the estimated transaction request object.\n   */\n  async estimatePredicates(transactionRequest: TransactionRequest): Promise<TransactionRequest> {\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const response = await this.operations.estimatePredicates({\n      encodedTransaction,\n    });\n\n    const estimatedTransaction = transactionRequest;\n    const [decodedTransaction] = new TransactionCoder().decode(\n      arrayify(response.estimatePredicates.rawPayload),\n      0\n    );\n\n    if (decodedTransaction.inputs) {\n      decodedTransaction.inputs.forEach((input, index) => {\n        if ('predicate' in input && input.predicateGasUsed.gt(0)) {\n          (<CoinTransactionRequestInput>estimatedTransaction.inputs[index]).predicateGasUsed =\n            input.predicateGasUsed;\n        }\n      });\n    }\n\n    return estimatedTransaction;\n  }\n\n  /**\n   * Will dryRun a transaction and check for missing dependencies.\n   *\n   * If there are missing variable outputs,\n   * `addVariableOutputs` is called on the transaction.\n   *\n   * @privateRemarks\n   * TODO: Investigate support for missing contract IDs\n   * TODO: Add support for missing output messages\n   *\n   * @param transactionRequest - The transaction request object.\n   * @returns A promise.\n   */\n  async estimateTxDependencies(transactionRequest: TransactionRequest): Promise<void> {\n    let missingOutputVariableCount = 0;\n    let missingOutputContractIdsCount = 0;\n    let tries = 0;\n\n    if (transactionRequest.type === TransactionType.Create) {\n      return;\n    }\n\n    const encodedTransaction = transactionRequest.hasPredicateInput()\n      ? hexlify((await this.estimatePredicates(transactionRequest)).toTransactionBytes())\n      : hexlify(transactionRequest.toTransactionBytes());\n\n    do {\n      const { dryRun: gqlReceipts } = await this.operations.dryRun({\n        encodedTransaction,\n        utxoValidation: false,\n      });\n      const receipts = gqlReceipts.map(processGqlReceipt);\n      const { missingOutputVariables, missingOutputContractIds } =\n        getReceiptsWithMissingData(receipts);\n\n      missingOutputVariableCount = missingOutputVariables.length;\n      missingOutputContractIdsCount = missingOutputContractIds.length;\n\n      if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {\n        return;\n      }\n\n      if (transactionRequest instanceof ScriptTransactionRequest) {\n        transactionRequest.addVariableOutputs(missingOutputVariableCount);\n\n        missingOutputContractIds.forEach(({ contractId }) =>\n          transactionRequest.addContractInputAndOutput(Address.fromString(contractId))\n        );\n      }\n\n      tries += 1;\n    } while (tries < MAX_RETRIES);\n  }\n\n  /**\n   * Executes a signed transaction without applying the states changes\n   * on the chain.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @returns A promise that resolves to the call result object.\n   */\n  async simulate(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.estimateTxDependencies(transactionRequest);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: true,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the the transaction.\n   *\n   * @privateRemarks\n   * The tolerance is add on top of the gasUsed calculated\n   * from the node, this create a safe margin costs like\n   * change states on transfer that don't occur on the dryRun\n   * transaction. The default value is 0.2 or 20%\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param tolerance - The tolerance to add on top of the gasUsed.\n   * @returns A promise that resolves to the transaction cost object.\n   */\n  async getTransactionCost(\n    transactionRequestLike: TransactionRequestLike,\n    tolerance: number = 0.2\n  ): Promise<TransactionCost> {\n    const transactionRequest = transactionRequestify(clone(transactionRequestLike));\n    const { minGasPrice, gasPerByte, gasPriceFactor, maxGasPerTx } = this.getGasConfig();\n    const gasPrice = max(transactionRequest.gasPrice, minGasPrice);\n    const margin = 1 + tolerance;\n\n    // Set gasLimit to the maximum of the chain\n    // and gasPrice to 0 for measure\n    // Transaction without arrive to OutOfGas\n    transactionRequest.gasLimit = maxGasPerTx;\n    transactionRequest.gasPrice = bn(0);\n\n    // Execute dryRun not validated transaction to query gasUsed\n    const { receipts } = await this.call(transactionRequest);\n    const transaction = transactionRequest.toTransaction();\n\n    const { fee, gasUsed } = calculateTransactionFee({\n      gasPrice,\n      transactionBytes: transactionRequest.toTransactionBytes(),\n      transactionWitnesses: transaction?.witnesses || [],\n      gasPerByte,\n      gasPriceFactor,\n      transactionType: transaction.type,\n      receipts,\n      margin,\n    });\n\n    return {\n      minGasPrice,\n      gasPrice,\n      gasUsed,\n      fee,\n    };\n  }\n\n  /**\n   * Returns coins for the given owner.\n   */\n  async getCoins(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId?: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoins({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) },\n    });\n\n    const coins = result.coins.edges.map((edge) => edge.node);\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      assetId: coin.assetId,\n      amount: bn(coin.amount),\n      owner: Address.fromAddressOrString(coin.owner),\n      maturity: bn(coin.maturity).toNumber(),\n      blockCreated: bn(coin.blockCreated),\n      txCreatedIdx: bn(coin.txCreatedIdx),\n    }));\n  }\n\n  /**\n   * Returns resources for the given owner satisfying the spend query.\n   *\n   * @param owner - The address to get resources for.\n   * @param quantities - The quantities to get.\n   * @param excludedIds - IDs of excluded resources from the selection.\n   * @returns A promise that resolves to the resources.\n   */\n  async getResourcesToSpend(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The quantities to get */\n    quantities: CoinQuantityLike[],\n    /** IDs of excluded resources from the selection. */\n    excludedIds?: ExcludeResourcesOption\n  ): Promise<Resource[]> {\n    const excludeInput = {\n      messages: excludedIds?.messages?.map((id) => hexlify(id)) || [],\n      utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || [],\n    };\n\n    if (this.cache) {\n      const uniqueUtxos = new Set(\n        excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify(id)))\n      );\n      excludeInput.utxos = Array.from(uniqueUtxos);\n    }\n    const coinsQuery = {\n      owner: owner.toB256(),\n      queryPerAsset: quantities\n        .map(coinQuantityfy)\n        .map(({ assetId, amount, max: maxPerAsset }) => ({\n          assetId: hexlify(assetId),\n          amount: amount.toString(10),\n          max: maxPerAsset ? maxPerAsset.toString(10) : undefined,\n        })),\n      excludedIds: excludeInput,\n    };\n\n    const result = await this.operations.getCoinsToSpend(coinsQuery);\n\n    const coins = result.coinsToSpend\n      .flat()\n      .map((coin) => {\n        switch (coin.__typename) {\n          case 'MessageCoin':\n            return {\n              amount: bn(coin.amount),\n              assetId: coin.assetId,\n              daHeight: bn(coin.daHeight),\n              sender: Address.fromAddressOrString(coin.sender),\n              recipient: Address.fromAddressOrString(coin.recipient),\n              nonce: coin.nonce,\n            } as MessageCoin;\n          case 'Coin':\n            return {\n              id: coin.utxoId,\n              amount: bn(coin.amount),\n              assetId: coin.assetId,\n              owner: Address.fromAddressOrString(coin.owner),\n              maturity: bn(coin.maturity).toNumber(),\n              blockCreated: bn(coin.blockCreated),\n              txCreatedIdx: bn(coin.txCreatedIdx),\n            } as Coin;\n          default:\n            return null;\n        }\n      })\n      .filter((v) => !!v) as Array<Resource>;\n\n    return coins;\n  }\n\n  /**\n   * Returns block matching the given ID or height.\n   *\n   * @param idOrHeight - ID or height of the block.\n   * @returns A promise that resolves to the block.\n   */\n  async getBlock(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<Block | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString(10) };\n    } else if (idOrHeight.length === 66) {\n      variables = { blockId: idOrHeight };\n    } else {\n      variables = { blockId: bn(idOrHeight).toString(10) };\n    }\n\n    const { block } = await this.operations.getBlock(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    };\n  }\n\n  /**\n   * Returns all the blocks matching the given parameters.\n   *\n   * @param params - The parameters to query blocks.\n   * @returns A promise that resolves to the blocks.\n   */\n  async getBlocks(params: GqlGetBlocksQueryVariables): Promise<Block[]> {\n    const { blocks: fetchedData } = await this.operations.getBlocks(params);\n\n    const blocks: Block[] = fetchedData.edges.map(({ node: block }) => ({\n      id: block.id,\n      height: bn(block.header.height),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    }));\n\n    return blocks;\n  }\n\n  /**\n   * Returns block matching the given ID or type, including transaction data.\n   *\n   * @param idOrHeight - ID or height of the block.\n   * @returns A promise that resolves to the block.\n   */\n  async getBlockWithTransactions(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<(Block & { transactions: Transaction[] }) | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height, 10),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]\n      ),\n    };\n  }\n\n  /**\n   * Get transaction with the given ID.\n   *\n   * @param transactionId - ID of the transaction.\n   * @returns A promise that resolves to the transaction.\n   */\n  async getTransaction<TTransactionType = void>(\n    transactionId: string\n  ): Promise<Transaction<TTransactionType> | null> {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    return new TransactionCoder().decode(\n      arrayify(transaction.rawPayload),\n      0\n    )?.[0] as Transaction<TTransactionType>;\n  }\n\n  /**\n   * Get deployed contract with the given ID.\n   *\n   * @param contractId - ID of the contract.\n   * @returns A promise that resolves to the contract.\n   */\n  async getContract(contractId: string): Promise<ContractResult | null> {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n\n  /**\n   * Returns the balance for the given contract for the given asset ID.\n   *\n   * @param contractId - The contract ID to get the balance for.\n   * @param assetId - The asset ID of coins to get.\n   * @returns A promise that resolves to the balance.\n   */\n  async getContractBalance(\n    /** The contract ID to get the balance for */\n    contractId: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { contractBalance } = await this.operations.getContractBalance({\n      contract: contractId.toB256(),\n      asset: hexlify(assetId),\n    });\n    return bn(contractBalance.amount, 10);\n  }\n\n  /**\n   * Returns the balance for the given owner for the given asset ID.\n   *\n   * @param owner - The address to get coins for.\n   * @param assetId - The asset ID of coins to get.\n   * @returns A promise that resolves to the balance.\n   */\n  async getBalance(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { balance } = await this.operations.getBalance({\n      owner: owner.toB256(),\n      assetId: hexlify(assetId),\n    });\n    return bn(balance.amount, 10);\n  }\n\n  /**\n   * Returns balances for the given owner.\n   *\n   * @param owner - The address to get coins for.\n   * @param paginationArgs - Pagination arguments.\n   * @returns A promise that resolves to the balances.\n   */\n  async getBalances(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<CoinQuantity[]> {\n    const result = await this.operations.getBalances({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256() },\n    });\n\n    const balances = result.balances.edges.map((edge) => edge.node);\n\n    return balances.map((balance) => ({\n      assetId: balance.assetId,\n      amount: bn(balance.amount),\n    }));\n  }\n\n  /**\n   * Returns message for the given address.\n   *\n   * @param address - The address to get message from.\n   * @param paginationArgs - Pagination arguments.\n   * @returns A promise that resolves to the messages.\n   */\n  async getMessages(\n    /** The address to get message from */\n    address: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Message[]> {\n    const result = await this.operations.getMessages({\n      first: 10,\n      ...paginationArgs,\n      owner: address.toB256(),\n    });\n\n    const messages = result.messages.edges.map((edge) => edge.node);\n\n    return messages.map((message) => ({\n      messageId: InputMessageCoder.getMessageId({\n        sender: message.sender,\n        recipient: message.recipient,\n        nonce: message.nonce,\n        amount: bn(message.amount),\n        data: message.data,\n      }),\n      sender: Address.fromAddressOrString(message.sender),\n      recipient: Address.fromAddressOrString(message.recipient),\n      nonce: message.nonce,\n      amount: bn(message.amount),\n      data: InputMessageCoder.decodeData(message.data),\n      daHeight: bn(message.daHeight),\n    }));\n  }\n\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.\n   *\n   * @param transactionId - The transaction to get message from.\n   * @param messageId - The message id from MessageOut receipt.\n   * @param commitBlockId - The commit block id.\n   * @param commitBlockHeight - The commit block height.\n   * @returns A promise that resolves to the message proof.\n   */\n  async getMessageProof(\n    /** The transaction to get message from */\n    transactionId: string,\n    /** The message id from MessageOut receipt */\n    messageId: string,\n    commitBlockId?: string,\n    commitBlockHeight?: BN\n  ): Promise<MessageProof | null> {\n    let inputObject: {\n      /** The transaction to get message from */\n      transactionId: string;\n      /** The message id from MessageOut receipt */\n      messageId: string;\n      commitBlockId?: string;\n      commitBlockHeight?: string;\n    } = {\n      transactionId,\n      messageId,\n    };\n\n    if (commitBlockId && commitBlockHeight) {\n      throw new FuelError(\n        ErrorCode.INVALID_INPUT_PARAMETERS,\n        'commitBlockId and commitBlockHeight cannot be used together'\n      );\n    }\n\n    if (commitBlockId) {\n      inputObject = {\n        ...inputObject,\n        commitBlockId,\n      };\n    }\n\n    if (commitBlockHeight) {\n      inputObject = {\n        ...inputObject,\n        // Conver BN into a number string required on the query\n        // This should problably be fixed on the fuel client side\n        commitBlockHeight: commitBlockHeight.toNumber().toString(),\n      };\n    }\n\n    const result = await this.operations.getMessageProof(inputObject);\n\n    if (!result.messageProof) {\n      return null;\n    }\n\n    const {\n      messageProof,\n      messageBlockHeader,\n      commitBlockHeader,\n      blockProof,\n      nonce,\n      sender,\n      recipient,\n      amount,\n      data,\n    } = result.messageProof;\n\n    return {\n      messageProof: {\n        proofIndex: bn(messageProof.proofIndex),\n        proofSet: messageProof.proofSet,\n      },\n      blockProof: {\n        proofIndex: bn(blockProof.proofIndex),\n        proofSet: blockProof.proofSet,\n      },\n      messageBlockHeader: {\n        id: messageBlockHeader.id,\n        daHeight: bn(messageBlockHeader.daHeight),\n        transactionsCount: bn(messageBlockHeader.transactionsCount),\n        transactionsRoot: messageBlockHeader.transactionsRoot,\n        height: bn(messageBlockHeader.height),\n        prevRoot: messageBlockHeader.prevRoot,\n        time: messageBlockHeader.time,\n        applicationHash: messageBlockHeader.applicationHash,\n        messageReceiptRoot: messageBlockHeader.messageReceiptRoot,\n        messageReceiptCount: bn(messageBlockHeader.messageReceiptCount),\n      },\n      commitBlockHeader: {\n        id: commitBlockHeader.id,\n        daHeight: bn(commitBlockHeader.daHeight),\n        transactionsCount: bn(commitBlockHeader.transactionsCount),\n        transactionsRoot: commitBlockHeader.transactionsRoot,\n        height: bn(commitBlockHeader.height),\n        prevRoot: commitBlockHeader.prevRoot,\n        time: commitBlockHeader.time,\n        applicationHash: commitBlockHeader.applicationHash,\n        messageReceiptRoot: commitBlockHeader.messageReceiptRoot,\n        messageReceiptCount: bn(commitBlockHeader.messageReceiptCount),\n      },\n      sender: Address.fromAddressOrString(sender),\n      recipient: Address.fromAddressOrString(recipient),\n      nonce,\n      amount: bn(amount),\n      data,\n    };\n  }\n\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.\n   *\n   * @param nonce - The nonce of the message to get status from.\n   * @returns A promise that resolves to the message status\n   */\n  async getMessageStatus(\n    /** The nonce of the message to get status from */\n    nonce: string\n  ): Promise<MessageStatus> {\n    const result = await this.operations.getMessageStatus({ nonce });\n    return result.messageStatus;\n  }\n\n  /**\n   * Lets you produce blocks with custom timestamps and the block number of the last block produced.\n   *\n   * @param amount - The amount of blocks to produce\n   * @param startTime - The UNIX timestamp to set for the first produced block\n   * @returns A promise that resolves to the block number of the last produced block.\n   */\n  async produceBlocks(amount: number, startTime?: number) {\n    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({\n      blocksToProduce: bn(amount).toString(10),\n      startTimestamp: startTime ? fromUnixToTai64(startTime) : undefined,\n    });\n    return bn(latestBlockHeight);\n  }\n}\n","import type { DocumentNode } from 'graphql';\nimport gql from 'graphql-tag';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Address: string;\n  AssetId: string;\n  BlockId: string;\n  Bytes32: string;\n  ContractId: string;\n  HexString: string;\n  MessageId: any;\n  Nonce: string;\n  Salt: string;\n  Signature: any;\n  Tai64Timestamp: any;\n  TransactionId: string;\n  TxPointer: any;\n  U32: any;\n  U64: string;\n  UtxoId: string;\n};\n\nexport type GqlBalance = {\n  __typename: 'Balance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlBalanceConnection = {\n  __typename: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBalanceEdge = {\n  __typename: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBalance;\n};\n\nexport type GqlBalanceFilterInput = {\n  /** Filter coins based on the `owner` field */\n  owner: Scalars['Address'];\n};\n\nexport type GqlBlock = {\n  __typename: 'Block';\n  consensus: GqlConsensus;\n  header: GqlHeader;\n  id: Scalars['BlockId'];\n  transactions: Array<GqlTransaction>;\n};\n\nexport type GqlBlockConnection = {\n  __typename: 'BlockConnection';\n  /** A list of edges. */\n  edges: Array<GqlBlockEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBlockEdge = {\n  __typename: 'BlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBlock;\n};\n\nexport type GqlChainInfo = {\n  __typename: 'ChainInfo';\n  baseChainHeight: Scalars['U32'];\n  consensusParameters: GqlConsensusParameters;\n  gasCosts: GqlGasCosts;\n  latestBlock: GqlBlock;\n  name: Scalars['String'];\n  peerCount: Scalars['Int'];\n};\n\nexport type GqlChangeOutput = {\n  __typename: 'ChangeOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlCoin = {\n  __typename: 'Coin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  /** TxPointer - the height of the block this coin was created in */\n  blockCreated: Scalars['U32'];\n  maturity: Scalars['U32'];\n  owner: Scalars['Address'];\n  /** TxPointer - the index of the transaction that created this coin */\n  txCreatedIdx: Scalars['U64'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlCoinConnection = {\n  __typename: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<GqlCoinEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlCoin>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlCoinEdge = {\n  __typename: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlCoin;\n};\n\nexport type GqlCoinFilterInput = {\n  /** Returns coins only with `asset_id`. */\n  assetId?: InputMaybe<Scalars['AssetId']>;\n  /** Returns coins owned by the `owner`. */\n  owner: Scalars['Address'];\n};\n\nexport type GqlCoinOutput = {\n  __typename: 'CoinOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\n/** The schema analog of the [`coins::CoinType`]. */\nexport type GqlCoinType = GqlCoin | GqlMessageCoin;\n\nexport type GqlConsensus = GqlGenesis | GqlPoAConsensus;\n\nexport type GqlConsensusParameters = {\n  __typename: 'ConsensusParameters';\n  chainId: Scalars['U64'];\n  contractMaxSize: Scalars['U64'];\n  gasPerByte: Scalars['U64'];\n  gasPriceFactor: Scalars['U64'];\n  maxGasPerPredicate: Scalars['U64'];\n  maxGasPerTx: Scalars['U64'];\n  maxInputs: Scalars['U64'];\n  maxMessageDataLength: Scalars['U64'];\n  maxOutputs: Scalars['U64'];\n  maxPredicateDataLength: Scalars['U64'];\n  maxPredicateLength: Scalars['U64'];\n  maxScriptDataLength: Scalars['U64'];\n  maxScriptLength: Scalars['U64'];\n  maxStorageSlots: Scalars['U64'];\n  maxWitnesses: Scalars['U64'];\n};\n\nexport type GqlContract = {\n  __typename: 'Contract';\n  bytecode: Scalars['HexString'];\n  id: Scalars['ContractId'];\n  salt: Scalars['Salt'];\n};\n\nexport type GqlContractBalance = {\n  __typename: 'ContractBalance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractBalanceConnection = {\n  __typename: 'ContractBalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlContractBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlContractBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlContractBalanceEdge = {\n  __typename: 'ContractBalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlContractBalance;\n};\n\nexport type GqlContractBalanceFilterInput = {\n  /** Filter assets based on the `contractId` field */\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractCreated = {\n  __typename: 'ContractCreated';\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractOutput = {\n  __typename: 'ContractOutput';\n  balanceRoot: Scalars['Bytes32'];\n  inputIndex: Scalars['Int'];\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlDependentCost = {\n  __typename: 'DependentCost';\n  base: Scalars['U64'];\n  depPerUnit: Scalars['U64'];\n};\n\nexport type GqlExcludeInput = {\n  /** Messages to exclude from the selection. */\n  messages: Array<Scalars['Nonce']>;\n  /** Utxos to exclude from the selection. */\n  utxos: Array<Scalars['UtxoId']>;\n};\n\nexport type GqlFailureStatus = {\n  __typename: 'FailureStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  reason: Scalars['String'];\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlGasCosts = {\n  __typename: 'GasCosts';\n  add: Scalars['U64'];\n  addi: Scalars['U64'];\n  aloc: Scalars['U64'];\n  and: Scalars['U64'];\n  andi: Scalars['U64'];\n  bal: Scalars['U64'];\n  bhei: Scalars['U64'];\n  bhsh: Scalars['U64'];\n  burn: Scalars['U64'];\n  call: GqlDependentCost;\n  cb: Scalars['U64'];\n  ccp: GqlDependentCost;\n  cfei: Scalars['U64'];\n  cfsi: Scalars['U64'];\n  croo: Scalars['U64'];\n  csiz: GqlDependentCost;\n  div: Scalars['U64'];\n  divi: Scalars['U64'];\n  eck1: Scalars['U64'];\n  ecr1: Scalars['U64'];\n  ed19: Scalars['U64'];\n  eq: Scalars['U64'];\n  exp: Scalars['U64'];\n  expi: Scalars['U64'];\n  flag: Scalars['U64'];\n  gm: Scalars['U64'];\n  gt: Scalars['U64'];\n  gtf: Scalars['U64'];\n  ji: Scalars['U64'];\n  jmp: Scalars['U64'];\n  jmpb: Scalars['U64'];\n  jmpf: Scalars['U64'];\n  jne: Scalars['U64'];\n  jneb: Scalars['U64'];\n  jnef: Scalars['U64'];\n  jnei: Scalars['U64'];\n  jnzb: Scalars['U64'];\n  jnzf: Scalars['U64'];\n  jnzi: Scalars['U64'];\n  k256: Scalars['U64'];\n  lb: Scalars['U64'];\n  ldc: GqlDependentCost;\n  log: Scalars['U64'];\n  logd: GqlDependentCost;\n  lt: Scalars['U64'];\n  lw: Scalars['U64'];\n  mcl: GqlDependentCost;\n  mcli: GqlDependentCost;\n  mcp: GqlDependentCost;\n  mcpi: Scalars['U64'];\n  meq: GqlDependentCost;\n  mint: Scalars['U64'];\n  mldv: Scalars['U64'];\n  mlog: Scalars['U64'];\n  modOp: Scalars['U64'];\n  modi: Scalars['U64'];\n  moveOp: Scalars['U64'];\n  movi: Scalars['U64'];\n  mroo: Scalars['U64'];\n  mul: Scalars['U64'];\n  muli: Scalars['U64'];\n  noop: Scalars['U64'];\n  not: Scalars['U64'];\n  or: Scalars['U64'];\n  ori: Scalars['U64'];\n  ret: Scalars['U64'];\n  retd: GqlDependentCost;\n  rvrt: Scalars['U64'];\n  s256: Scalars['U64'];\n  sb: Scalars['U64'];\n  scwq: Scalars['U64'];\n  sll: Scalars['U64'];\n  slli: Scalars['U64'];\n  smo: GqlDependentCost;\n  srl: Scalars['U64'];\n  srli: Scalars['U64'];\n  srw: Scalars['U64'];\n  srwq: GqlDependentCost;\n  sub: Scalars['U64'];\n  subi: Scalars['U64'];\n  sw: Scalars['U64'];\n  sww: Scalars['U64'];\n  swwq: Scalars['U64'];\n  time: Scalars['U64'];\n  tr: Scalars['U64'];\n  tro: Scalars['U64'];\n  wdam: Scalars['U64'];\n  wdcm: Scalars['U64'];\n  wddv: Scalars['U64'];\n  wdmd: Scalars['U64'];\n  wdml: Scalars['U64'];\n  wdmm: Scalars['U64'];\n  wdop: Scalars['U64'];\n  wqam: Scalars['U64'];\n  wqcm: Scalars['U64'];\n  wqdv: Scalars['U64'];\n  wqmd: Scalars['U64'];\n  wqml: Scalars['U64'];\n  wqmm: Scalars['U64'];\n  wqop: Scalars['U64'];\n  xor: Scalars['U64'];\n  xori: Scalars['U64'];\n};\n\nexport type GqlGenesis = {\n  __typename: 'Genesis';\n  /**\n   * The chain configs define what consensus type to use, what settlement layer to use,\n   * rules of block validity, etc.\n   */\n  chainConfigHash: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of all genesis coins. */\n  coinsRoot: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of state, balances, contracts code hash of each contract. */\n  contractsRoot: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of all genesis messages. */\n  messagesRoot: Scalars['Bytes32'];\n};\n\nexport type GqlHeader = {\n  __typename: 'Header';\n  /** Hash of the application header. */\n  applicationHash: Scalars['Bytes32'];\n  /** The layer 1 height of messages and events to include since the last layer 1 block number. */\n  daHeight: Scalars['U64'];\n  /** Fuel block height. */\n  height: Scalars['U32'];\n  /** Hash of the header */\n  id: Scalars['BlockId'];\n  /** Number of message receipts in this block. */\n  messageReceiptCount: Scalars['U64'];\n  /** Merkle root of message receipts in this block. */\n  messageReceiptRoot: Scalars['Bytes32'];\n  /** Merkle root of all previous block header hashes. */\n  prevRoot: Scalars['Bytes32'];\n  /** The block producer time. */\n  time: Scalars['Tai64Timestamp'];\n  /** Number of transactions in this block. */\n  transactionsCount: Scalars['U64'];\n  /** Merkle root of transactions. */\n  transactionsRoot: Scalars['Bytes32'];\n};\n\nexport type GqlInput = GqlInputCoin | GqlInputContract | GqlInputMessage;\n\nexport type GqlInputCoin = {\n  __typename: 'InputCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  maturity: Scalars['U32'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  predicateGasUsed: Scalars['U64'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlInputContract = {\n  __typename: 'InputContract';\n  balanceRoot: Scalars['Bytes32'];\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlInputMessage = {\n  __typename: 'InputMessage';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  nonce: Scalars['Nonce'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  predicateGasUsed: Scalars['U64'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlMerkleProof = {\n  __typename: 'MerkleProof';\n  proofIndex: Scalars['U64'];\n  proofSet: Array<Scalars['Bytes32']>;\n};\n\nexport type GqlMessage = {\n  __typename: 'Message';\n  amount: Scalars['U64'];\n  daHeight: Scalars['U64'];\n  data: Scalars['HexString'];\n  nonce: Scalars['Nonce'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport type GqlMessageCoin = {\n  __typename: 'MessageCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  daHeight: Scalars['U64'];\n  nonce: Scalars['Nonce'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport type GqlMessageConnection = {\n  __typename: 'MessageConnection';\n  /** A list of edges. */\n  edges: Array<GqlMessageEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlMessage>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlMessageEdge = {\n  __typename: 'MessageEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlMessage;\n};\n\nexport type GqlMessageProof = {\n  __typename: 'MessageProof';\n  amount: Scalars['U64'];\n  blockProof: GqlMerkleProof;\n  commitBlockHeader: GqlHeader;\n  data: Scalars['HexString'];\n  messageBlockHeader: GqlHeader;\n  messageProof: GqlMerkleProof;\n  nonce: Scalars['Nonce'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport enum GqlMessageState {\n  NotFound = 'NOT_FOUND',\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT'\n}\n\nexport type GqlMessageStatus = {\n  __typename: 'MessageStatus';\n  state: GqlMessageState;\n};\n\nexport type GqlMutation = {\n  __typename: 'Mutation';\n  /** Execute a dry-run of the transaction using a fork of current state, no changes are committed. */\n  dryRun: Array<GqlReceipt>;\n  /**\n   * Sequentially produces `blocks_to_produce` blocks. The first block starts with\n   * `start_timestamp`. If the block production in the [`crate::service::Config`] is\n   * `Trigger::Interval { block_time }`, produces blocks with `block_time ` intervals between\n   * them. The `start_timestamp` is the timestamp in seconds.\n   */\n  produceBlocks: Scalars['U32'];\n  /**\n   * Submits transaction to the `TxPool`.\n   *\n   * Returns submitted transaction if the transaction is included in the `TxPool` without problems.\n   */\n  submit: GqlTransaction;\n};\n\n\nexport type GqlMutationDryRunArgs = {\n  tx: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n};\n\n\nexport type GqlMutationProduceBlocksArgs = {\n  blocksToProduce: Scalars['U64'];\n  startTimestamp?: InputMaybe<Scalars['Tai64Timestamp']>;\n};\n\n\nexport type GqlMutationSubmitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlNodeInfo = {\n  __typename: 'NodeInfo';\n  maxDepth: Scalars['U64'];\n  maxTx: Scalars['U64'];\n  minGasPrice: Scalars['U64'];\n  nodeVersion: Scalars['String'];\n  utxoValidation: Scalars['Boolean'];\n  vmBacktrace: Scalars['Boolean'];\n};\n\nexport type GqlOutput = GqlChangeOutput | GqlCoinOutput | GqlContractCreated | GqlContractOutput | GqlVariableOutput;\n\n/** Information about pagination in a connection */\nexport type GqlPageInfo = {\n  __typename: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\nexport type GqlPoAConsensus = {\n  __typename: 'PoAConsensus';\n  /** Gets the signature of the block produced by `PoA` consensus. */\n  signature: Scalars['Signature'];\n};\n\nexport type GqlProgramState = {\n  __typename: 'ProgramState';\n  data: Scalars['HexString'];\n  returnType: GqlReturnType;\n};\n\nexport type GqlQuery = {\n  __typename: 'Query';\n  balance: GqlBalance;\n  balances: GqlBalanceConnection;\n  block?: Maybe<GqlBlock>;\n  blocks: GqlBlockConnection;\n  chain: GqlChainInfo;\n  /** Gets the coin by `utxo_id`. */\n  coin?: Maybe<GqlCoin>;\n  /** Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page. */\n  coins: GqlCoinConnection;\n  /**\n   * For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by\n   * `owner` that add up at least the query amount. The returned coins can be spent.\n   * The number of coins is optimized to prevent dust accumulation.\n   *\n   * The query supports excluding and maximum the number of coins.\n   *\n   * Returns:\n   * The list of spendable coins per asset from the query. The length of the result is\n   * the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`\n   * is the same.\n   */\n  coinsToSpend: Array<Array<GqlCoinType>>;\n  contract?: Maybe<GqlContract>;\n  contractBalance: GqlContractBalance;\n  contractBalances: GqlContractBalanceConnection;\n  /** Estimate the predicate gas for the provided transaction */\n  estimatePredicates: GqlTransaction;\n  /** Returns true when the GraphQL API is serving requests. */\n  health: Scalars['Boolean'];\n  messageProof?: Maybe<GqlMessageProof>;\n  messageStatus: GqlMessageStatus;\n  messages: GqlMessageConnection;\n  nodeInfo: GqlNodeInfo;\n  transaction?: Maybe<GqlTransaction>;\n  transactions: GqlTransactionConnection;\n  transactionsByOwner: GqlTransactionConnection;\n};\n\n\nexport type GqlQueryBalanceArgs = {\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\n\nexport type GqlQueryBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryBlockArgs = {\n  height?: InputMaybe<Scalars['U64']>;\n  id?: InputMaybe<Scalars['BlockId']>;\n};\n\n\nexport type GqlQueryBlocksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryCoinArgs = {\n  utxoId: Scalars['UtxoId'];\n};\n\n\nexport type GqlQueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlCoinFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryCoinsToSpendArgs = {\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput>;\n};\n\n\nexport type GqlQueryContractArgs = {\n  id: Scalars['ContractId'];\n};\n\n\nexport type GqlQueryContractBalanceArgs = {\n  asset: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\n\nexport type GqlQueryContractBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlContractBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryEstimatePredicatesArgs = {\n  tx: Scalars['HexString'];\n};\n\n\nexport type GqlQueryMessageProofArgs = {\n  commitBlockHeight?: InputMaybe<Scalars['U32']>;\n  commitBlockId?: InputMaybe<Scalars['BlockId']>;\n  messageId: Scalars['MessageId'];\n  transactionId: Scalars['TransactionId'];\n};\n\n\nexport type GqlQueryMessageStatusArgs = {\n  nonce: Scalars['Nonce'];\n};\n\n\nexport type GqlQueryMessagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner?: InputMaybe<Scalars['Address']>;\n};\n\n\nexport type GqlQueryTransactionArgs = {\n  id: Scalars['TransactionId'];\n};\n\n\nexport type GqlQueryTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryTransactionsByOwnerArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n};\n\nexport type GqlReceipt = {\n  __typename: 'Receipt';\n  amount?: Maybe<Scalars['U64']>;\n  assetId?: Maybe<Scalars['AssetId']>;\n  contract?: Maybe<GqlContract>;\n  contractId?: Maybe<Scalars['ContractId']>;\n  data?: Maybe<Scalars['HexString']>;\n  digest?: Maybe<Scalars['Bytes32']>;\n  gas?: Maybe<Scalars['U64']>;\n  gasUsed?: Maybe<Scalars['U64']>;\n  is?: Maybe<Scalars['U64']>;\n  len?: Maybe<Scalars['U64']>;\n  nonce?: Maybe<Scalars['Nonce']>;\n  param1?: Maybe<Scalars['U64']>;\n  param2?: Maybe<Scalars['U64']>;\n  pc?: Maybe<Scalars['U64']>;\n  ptr?: Maybe<Scalars['U64']>;\n  ra?: Maybe<Scalars['U64']>;\n  rb?: Maybe<Scalars['U64']>;\n  rc?: Maybe<Scalars['U64']>;\n  rd?: Maybe<Scalars['U64']>;\n  reason?: Maybe<Scalars['U64']>;\n  receiptType: GqlReceiptType;\n  recipient?: Maybe<Scalars['Address']>;\n  result?: Maybe<Scalars['U64']>;\n  sender?: Maybe<Scalars['Address']>;\n  subId?: Maybe<Scalars['Bytes32']>;\n  to?: Maybe<GqlContract>;\n  toAddress?: Maybe<Scalars['Address']>;\n  val?: Maybe<Scalars['U64']>;\n};\n\nexport enum GqlReceiptType {\n  Burn = 'BURN',\n  Call = 'CALL',\n  Log = 'LOG',\n  LogData = 'LOG_DATA',\n  MessageOut = 'MESSAGE_OUT',\n  Mint = 'MINT',\n  Panic = 'PANIC',\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n  ScriptResult = 'SCRIPT_RESULT',\n  Transfer = 'TRANSFER',\n  TransferOut = 'TRANSFER_OUT'\n}\n\nexport enum GqlReturnType {\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT'\n}\n\nexport type GqlSpendQueryElementInput = {\n  /** Target amount for the query. */\n  amount: Scalars['U64'];\n  /** Identifier of the asset to spend. */\n  assetId: Scalars['AssetId'];\n  /** The maximum number of currencies for selection. */\n  max?: InputMaybe<Scalars['U64']>;\n};\n\nexport type GqlSqueezedOutStatus = {\n  __typename: 'SqueezedOutStatus';\n  reason: Scalars['String'];\n};\n\nexport type GqlSubmittedStatus = {\n  __typename: 'SubmittedStatus';\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlSubscription = {\n  __typename: 'Subscription';\n  /**\n   * Returns a stream of status updates for the given transaction id.\n   * If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]\n   * or [`TransactionStatus::Failed`] the stream will return that and end immediately.\n   * If the current status is [`TransactionStatus::Submitted`] this will be returned\n   * and the stream will wait for a future update.\n   *\n   * This stream will wait forever so it's advised to use within a timeout.\n   *\n   * It is possible for the stream to miss an update if it is polled slower\n   * then the updates arrive. In such a case the stream will close without\n   * a status. If this occurs the stream can simply be restarted to return\n   * the latest status.\n   */\n  statusChange: GqlTransactionStatus;\n  /** Submits transaction to the `TxPool` and await either confirmation or failure. */\n  submitAndAwait: GqlTransactionStatus;\n};\n\n\nexport type GqlSubscriptionStatusChangeArgs = {\n  id: Scalars['TransactionId'];\n};\n\n\nexport type GqlSubscriptionSubmitAndAwaitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlSuccessStatus = {\n  __typename: 'SuccessStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlTransaction = {\n  __typename: 'Transaction';\n  bytecodeLength?: Maybe<Scalars['U64']>;\n  bytecodeWitnessIndex?: Maybe<Scalars['Int']>;\n  gasLimit?: Maybe<Scalars['U64']>;\n  gasPrice?: Maybe<Scalars['U64']>;\n  id: Scalars['TransactionId'];\n  inputAssetIds?: Maybe<Array<Scalars['AssetId']>>;\n  inputContracts?: Maybe<Array<GqlContract>>;\n  inputs?: Maybe<Array<GqlInput>>;\n  isCreate: Scalars['Boolean'];\n  isMint: Scalars['Boolean'];\n  isScript: Scalars['Boolean'];\n  maturity?: Maybe<Scalars['U32']>;\n  outputs: Array<GqlOutput>;\n  /** Return the transaction bytes using canonical encoding */\n  rawPayload: Scalars['HexString'];\n  receipts?: Maybe<Array<GqlReceipt>>;\n  receiptsRoot?: Maybe<Scalars['Bytes32']>;\n  salt?: Maybe<Scalars['Salt']>;\n  script?: Maybe<Scalars['HexString']>;\n  scriptData?: Maybe<Scalars['HexString']>;\n  status?: Maybe<GqlTransactionStatus>;\n  storageSlots?: Maybe<Array<Scalars['HexString']>>;\n  txPointer?: Maybe<Scalars['TxPointer']>;\n  witnesses?: Maybe<Array<Scalars['HexString']>>;\n};\n\nexport type GqlTransactionConnection = {\n  __typename: 'TransactionConnection';\n  /** A list of edges. */\n  edges: Array<GqlTransactionEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlTransaction>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlTransactionEdge = {\n  __typename: 'TransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlTransaction;\n};\n\nexport type GqlTransactionStatus = GqlFailureStatus | GqlSqueezedOutStatus | GqlSubmittedStatus | GqlSuccessStatus;\n\nexport type GqlVariableOutput = {\n  __typename: 'VariableOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\ntype GqlTransactionStatusFragment_FailureStatus_Fragment = { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } };\n\ntype GqlTransactionStatusFragment_SqueezedOutStatus_Fragment = { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' };\n\ntype GqlTransactionStatusFragment_SubmittedStatus_Fragment = { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' };\n\ntype GqlTransactionStatusFragment_SuccessStatus_Fragment = { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null };\n\nexport type GqlTransactionStatusFragmentFragment = GqlTransactionStatusFragment_FailureStatus_Fragment | GqlTransactionStatusFragment_SqueezedOutStatus_Fragment | GqlTransactionStatusFragment_SubmittedStatus_Fragment | GqlTransactionStatusFragment_SuccessStatus_Fragment;\n\nexport type GqlTransactionFragmentFragment = { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null };\n\nexport type GqlReceiptFragmentFragment = { __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null };\n\nexport type GqlBlockFragmentFragment = { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> };\n\nexport type GqlCoinFragmentFragment = { __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string };\n\nexport type GqlMessageCoinFragmentFragment = { __typename: 'MessageCoin', sender: string, recipient: string, nonce: string, amount: string, assetId: string, daHeight: string };\n\nexport type GqlMessageFragmentFragment = { __typename: 'Message', amount: string, sender: string, recipient: string, data: string, nonce: string, daHeight: string };\n\nexport type GqlMessageProofFragmentFragment = { __typename: 'MessageProof', sender: string, recipient: string, nonce: string, amount: string, data: string, messageProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, blockProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, messageBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string }, commitBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string } };\n\nexport type GqlBalanceFragmentFragment = { __typename: 'Balance', owner: string, amount: string, assetId: string };\n\nexport type GqlConsensusParametersFragmentFragment = { __typename: 'ConsensusParameters', contractMaxSize: string, maxInputs: string, maxOutputs: string, maxWitnesses: string, maxGasPerTx: string, maxScriptLength: string, maxScriptDataLength: string, maxStorageSlots: string, maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, gasPriceFactor: string, gasPerByte: string, maxMessageDataLength: string, chainId: string };\n\nexport type GqlChainInfoFragmentFragment = { __typename: 'ChainInfo', name: string, baseChainHeight: any, peerCount: number, consensusParameters: { __typename: 'ConsensusParameters', contractMaxSize: string, maxInputs: string, maxOutputs: string, maxWitnesses: string, maxGasPerTx: string, maxScriptLength: string, maxScriptDataLength: string, maxStorageSlots: string, maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, gasPriceFactor: string, gasPerByte: string, maxMessageDataLength: string, chainId: string }, latestBlock: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> } };\n\nexport type GqlContractBalanceFragmentFragment = { __typename: 'ContractBalance', contract: string, amount: string, assetId: string };\n\nexport type GqlPageInfoFragmentFragment = { __typename: 'PageInfo', hasPreviousPage: boolean, hasNextPage: boolean, startCursor?: string | null, endCursor?: string | null };\n\nexport type GqlGetVersionQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GqlGetVersionQuery = { __typename: 'Query', nodeInfo: { __typename: 'NodeInfo', nodeVersion: string } };\n\nexport type GqlNodeInfoFragmentFragment = { __typename: 'NodeInfo', utxoValidation: boolean, vmBacktrace: boolean, minGasPrice: string, maxTx: string, maxDepth: string, nodeVersion: string };\n\nexport type GqlGetNodeInfoQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GqlGetNodeInfoQuery = { __typename: 'Query', nodeInfo: { __typename: 'NodeInfo', utxoValidation: boolean, vmBacktrace: boolean, minGasPrice: string, maxTx: string, maxDepth: string, nodeVersion: string } };\n\nexport type GqlGetChainQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GqlGetChainQuery = { __typename: 'Query', chain: { __typename: 'ChainInfo', name: string, baseChainHeight: any, peerCount: number, consensusParameters: { __typename: 'ConsensusParameters', contractMaxSize: string, maxInputs: string, maxOutputs: string, maxWitnesses: string, maxGasPerTx: string, maxScriptLength: string, maxScriptDataLength: string, maxStorageSlots: string, maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, gasPriceFactor: string, gasPerByte: string, maxMessageDataLength: string, chainId: string }, latestBlock: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> } } };\n\nexport type GqlGetTransactionQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\n\nexport type GqlGetTransactionQuery = { __typename: 'Query', transaction?: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } | null };\n\nexport type GqlGetTransactionWithReceiptsQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\n\nexport type GqlGetTransactionWithReceiptsQuery = { __typename: 'Query', transaction?: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } | null };\n\nexport type GqlGetTransactionsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetTransactionsQuery = { __typename: 'Query', transactions: { __typename: 'TransactionConnection', edges: Array<{ __typename: 'TransactionEdge', node: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } }> } };\n\nexport type GqlGetTransactionsByOwnerQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetTransactionsByOwnerQuery = { __typename: 'Query', transactionsByOwner: { __typename: 'TransactionConnection', pageInfo: { __typename: 'PageInfo', hasPreviousPage: boolean, hasNextPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename: 'TransactionEdge', node: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } }> } };\n\nexport type GqlEstimatePredicatesQueryVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\n\nexport type GqlEstimatePredicatesQuery = { __typename: 'Query', estimatePredicates: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } };\n\nexport type GqlGetBlockQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\n\nexport type GqlGetBlockQuery = { __typename: 'Query', block?: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> } | null };\n\nexport type GqlGetBlockWithTransactionsQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\n\nexport type GqlGetBlockWithTransactionsQuery = { __typename: 'Query', block?: { __typename: 'Block', id: string, transactions: Array<{ __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null }>, header: { __typename: 'Header', height: any, time: any } } | null };\n\nexport type GqlGetBlocksQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetBlocksQuery = { __typename: 'Query', blocks: { __typename: 'BlockConnection', edges: Array<{ __typename: 'BlockEdge', node: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> } }> } };\n\nexport type GqlGetCoinQueryVariables = Exact<{\n  coinId: Scalars['UtxoId'];\n}>;\n\n\nexport type GqlGetCoinQuery = { __typename: 'Query', coin?: { __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string } | null };\n\nexport type GqlGetCoinsQueryVariables = Exact<{\n  filter: GqlCoinFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetCoinsQuery = { __typename: 'Query', coins: { __typename: 'CoinConnection', edges: Array<{ __typename: 'CoinEdge', node: { __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string } }> } };\n\nexport type GqlGetCoinsToSpendQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n}>;\n\n\nexport type GqlGetCoinsToSpendQuery = { __typename: 'Query', coinsToSpend: Array<Array<{ __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string } | { __typename: 'MessageCoin', sender: string, recipient: string, nonce: string, amount: string, assetId: string, daHeight: string }>> };\n\nexport type GqlGetContractQueryVariables = Exact<{\n  contractId: Scalars['ContractId'];\n}>;\n\n\nexport type GqlGetContractQuery = { __typename: 'Query', contract?: { __typename: 'Contract', bytecode: string, id: string } | null };\n\nexport type GqlGetContractBalanceQueryVariables = Exact<{\n  contract: Scalars['ContractId'];\n  asset: Scalars['AssetId'];\n}>;\n\n\nexport type GqlGetContractBalanceQuery = { __typename: 'Query', contractBalance: { __typename: 'ContractBalance', contract: string, amount: string, assetId: string } };\n\nexport type GqlGetBalanceQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  assetId: Scalars['AssetId'];\n}>;\n\n\nexport type GqlGetBalanceQuery = { __typename: 'Query', balance: { __typename: 'Balance', owner: string, amount: string, assetId: string } };\n\nexport type GqlGetBalancesQueryVariables = Exact<{\n  filter: GqlBalanceFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetBalancesQuery = { __typename: 'Query', balances: { __typename: 'BalanceConnection', edges: Array<{ __typename: 'BalanceEdge', node: { __typename: 'Balance', owner: string, amount: string, assetId: string } }> } };\n\nexport type GqlGetMessagesQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetMessagesQuery = { __typename: 'Query', messages: { __typename: 'MessageConnection', edges: Array<{ __typename: 'MessageEdge', node: { __typename: 'Message', amount: string, sender: string, recipient: string, data: string, nonce: string, daHeight: string } }> } };\n\nexport type GqlGetMessageProofQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n  messageId: Scalars['MessageId'];\n  commitBlockId?: InputMaybe<Scalars['BlockId']>;\n  commitBlockHeight?: InputMaybe<Scalars['U32']>;\n}>;\n\n\nexport type GqlGetMessageProofQuery = { __typename: 'Query', messageProof?: { __typename: 'MessageProof', sender: string, recipient: string, nonce: string, amount: string, data: string, messageProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, blockProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, messageBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string }, commitBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string } } | null };\n\nexport type GqlGetMessageStatusQueryVariables = Exact<{\n  nonce: Scalars['Nonce'];\n}>;\n\n\nexport type GqlGetMessageStatusQuery = { __typename: 'Query', messageStatus: { __typename: 'MessageStatus', state: GqlMessageState } };\n\nexport type GqlDryRunMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n}>;\n\n\nexport type GqlDryRunMutation = { __typename: 'Mutation', dryRun: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> };\n\nexport type GqlSubmitMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\n\nexport type GqlSubmitMutation = { __typename: 'Mutation', submit: { __typename: 'Transaction', id: string } };\n\nexport type GqlProduceBlocksMutationVariables = Exact<{\n  startTimestamp?: InputMaybe<Scalars['Tai64Timestamp']>;\n  blocksToProduce: Scalars['U64'];\n}>;\n\n\nexport type GqlProduceBlocksMutation = { __typename: 'Mutation', produceBlocks: any };\n\nexport type GqlSubmitAndAwaitSubscriptionVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\n\nexport type GqlSubmitAndAwaitSubscription = { __typename: 'Subscription', submitAndAwait: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } };\n\nexport type GqlStatusChangeSubscriptionVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\n\nexport type GqlStatusChangeSubscription = { __typename: 'Subscription', statusChange: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } };\n\nexport const ReceiptFragmentFragmentDoc = gql`\n    fragment receiptFragment on Receipt {\n  contract {\n    id\n    bytecode\n    salt\n  }\n  pc\n  is\n  to {\n    id\n    bytecode\n    salt\n  }\n  toAddress\n  amount\n  assetId\n  gas\n  param1\n  param2\n  val\n  ptr\n  digest\n  reason\n  ra\n  rb\n  rc\n  rd\n  len\n  receiptType\n  result\n  gasUsed\n  data\n  sender\n  recipient\n  nonce\n  contractId\n  subId\n}\n    `;\nexport const TransactionStatusFragmentFragmentDoc = gql`\n    fragment transactionStatusFragment on TransactionStatus {\n  type: __typename\n  ... on SubmittedStatus {\n    time\n  }\n  ... on SuccessStatus {\n    block {\n      id\n    }\n    time\n    programState {\n      returnType\n      data\n    }\n  }\n  ... on FailureStatus {\n    block {\n      id\n    }\n    time\n    reason\n  }\n}\n    `;\nexport const TransactionFragmentFragmentDoc = gql`\n    fragment transactionFragment on Transaction {\n  id\n  rawPayload\n  gasPrice\n  receipts {\n    ...receiptFragment\n  }\n  status {\n    ...transactionStatusFragment\n  }\n}\n    `;\nexport const CoinFragmentFragmentDoc = gql`\n    fragment coinFragment on Coin {\n  __typename\n  utxoId\n  owner\n  amount\n  assetId\n  maturity\n  blockCreated\n  txCreatedIdx\n}\n    `;\nexport const MessageCoinFragmentFragmentDoc = gql`\n    fragment messageCoinFragment on MessageCoin {\n  __typename\n  sender\n  recipient\n  nonce\n  amount\n  assetId\n  daHeight\n}\n    `;\nexport const MessageFragmentFragmentDoc = gql`\n    fragment messageFragment on Message {\n  amount\n  sender\n  recipient\n  data\n  nonce\n  daHeight\n}\n    `;\nexport const MessageProofFragmentFragmentDoc = gql`\n    fragment messageProofFragment on MessageProof {\n  messageProof {\n    proofSet\n    proofIndex\n  }\n  blockProof {\n    proofSet\n    proofIndex\n  }\n  messageBlockHeader {\n    id\n    daHeight\n    transactionsCount\n    transactionsRoot\n    height\n    prevRoot\n    time\n    applicationHash\n    messageReceiptRoot\n    messageReceiptCount\n  }\n  commitBlockHeader {\n    id\n    daHeight\n    transactionsCount\n    transactionsRoot\n    height\n    prevRoot\n    time\n    applicationHash\n    messageReceiptRoot\n    messageReceiptCount\n  }\n  sender\n  recipient\n  nonce\n  amount\n  data\n}\n    `;\nexport const BalanceFragmentFragmentDoc = gql`\n    fragment balanceFragment on Balance {\n  owner\n  amount\n  assetId\n}\n    `;\nexport const ConsensusParametersFragmentFragmentDoc = gql`\n    fragment consensusParametersFragment on ConsensusParameters {\n  contractMaxSize\n  maxInputs\n  maxOutputs\n  maxWitnesses\n  maxGasPerTx\n  maxScriptLength\n  maxScriptDataLength\n  maxStorageSlots\n  maxPredicateLength\n  maxPredicateDataLength\n  maxGasPerPredicate\n  gasPriceFactor\n  gasPerByte\n  maxMessageDataLength\n  chainId\n}\n    `;\nexport const BlockFragmentFragmentDoc = gql`\n    fragment blockFragment on Block {\n  id\n  header {\n    height\n    time\n  }\n  transactions {\n    id\n  }\n}\n    `;\nexport const ChainInfoFragmentFragmentDoc = gql`\n    fragment chainInfoFragment on ChainInfo {\n  name\n  baseChainHeight\n  peerCount\n  consensusParameters {\n    ...consensusParametersFragment\n  }\n  latestBlock {\n    ...blockFragment\n  }\n}\n    `;\nexport const ContractBalanceFragmentFragmentDoc = gql`\n    fragment contractBalanceFragment on ContractBalance {\n  contract\n  amount\n  assetId\n}\n    `;\nexport const PageInfoFragmentFragmentDoc = gql`\n    fragment pageInfoFragment on PageInfo {\n  hasPreviousPage\n  hasNextPage\n  startCursor\n  endCursor\n}\n    `;\nexport const NodeInfoFragmentFragmentDoc = gql`\n    fragment nodeInfoFragment on NodeInfo {\n  utxoValidation\n  vmBacktrace\n  minGasPrice\n  maxTx\n  maxDepth\n  nodeVersion\n}\n    `;\nexport const GetVersionDocument = gql`\n    query getVersion {\n  nodeInfo {\n    nodeVersion\n  }\n}\n    `;\nexport const GetNodeInfoDocument = gql`\n    query getNodeInfo {\n  nodeInfo {\n    ...nodeInfoFragment\n  }\n}\n    ${NodeInfoFragmentFragmentDoc}`;\nexport const GetChainDocument = gql`\n    query getChain {\n  chain {\n    ...chainInfoFragment\n  }\n}\n    ${ChainInfoFragmentFragmentDoc}\n${ConsensusParametersFragmentFragmentDoc}\n${BlockFragmentFragmentDoc}`;\nexport const GetTransactionDocument = gql`\n    query getTransaction($transactionId: TransactionId!) {\n  transaction(id: $transactionId) {\n    ...transactionFragment\n  }\n}\n    ${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}\n${TransactionStatusFragmentFragmentDoc}`;\nexport const GetTransactionWithReceiptsDocument = gql`\n    query getTransactionWithReceipts($transactionId: TransactionId!) {\n  transaction(id: $transactionId) {\n    ...transactionFragment\n    receipts {\n      ...receiptFragment\n    }\n  }\n}\n    ${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}\n${TransactionStatusFragmentFragmentDoc}`;\nexport const GetTransactionsDocument = gql`\n    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n  transactions(after: $after, before: $before, first: $first, last: $last) {\n    edges {\n      node {\n        ...transactionFragment\n      }\n    }\n  }\n}\n    ${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}\n${TransactionStatusFragmentFragmentDoc}`;\nexport const GetTransactionsByOwnerDocument = gql`\n    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n  transactionsByOwner(\n    owner: $owner\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    pageInfo {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        ...transactionFragment\n      }\n    }\n  }\n}\n    ${PageInfoFragmentFragmentDoc}\n${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}\n${TransactionStatusFragmentFragmentDoc}`;\nexport const EstimatePredicatesDocument = gql`\n    query estimatePredicates($encodedTransaction: HexString!) {\n  estimatePredicates(tx: $encodedTransaction) {\n    ...transactionFragment\n  }\n}\n    ${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}\n${TransactionStatusFragmentFragmentDoc}`;\nexport const GetBlockDocument = gql`\n    query getBlock($blockId: BlockId, $blockHeight: U64) {\n  block(id: $blockId, height: $blockHeight) {\n    ...blockFragment\n  }\n}\n    ${BlockFragmentFragmentDoc}`;\nexport const GetBlockWithTransactionsDocument = gql`\n    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {\n  block(id: $blockId, height: $blockHeight) {\n    ...blockFragment\n    transactions {\n      ...transactionFragment\n    }\n  }\n}\n    ${BlockFragmentFragmentDoc}\n${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}\n${TransactionStatusFragmentFragmentDoc}`;\nexport const GetBlocksDocument = gql`\n    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n  blocks(after: $after, before: $before, first: $first, last: $last) {\n    edges {\n      node {\n        ...blockFragment\n      }\n    }\n  }\n}\n    ${BlockFragmentFragmentDoc}`;\nexport const GetCoinDocument = gql`\n    query getCoin($coinId: UtxoId!) {\n  coin(utxoId: $coinId) {\n    ...coinFragment\n  }\n}\n    ${CoinFragmentFragmentDoc}`;\nexport const GetCoinsDocument = gql`\n    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {\n  coins(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        ...coinFragment\n      }\n    }\n  }\n}\n    ${CoinFragmentFragmentDoc}`;\nexport const GetCoinsToSpendDocument = gql`\n    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {\n  coinsToSpend(\n    owner: $owner\n    queryPerAsset: $queryPerAsset\n    excludedIds: $excludedIds\n  ) {\n    ...coinFragment\n    ...messageCoinFragment\n  }\n}\n    ${CoinFragmentFragmentDoc}\n${MessageCoinFragmentFragmentDoc}`;\nexport const GetContractDocument = gql`\n    query getContract($contractId: ContractId!) {\n  contract(id: $contractId) {\n    bytecode\n    id\n  }\n}\n    `;\nexport const GetContractBalanceDocument = gql`\n    query getContractBalance($contract: ContractId!, $asset: AssetId!) {\n  contractBalance(contract: $contract, asset: $asset) {\n    ...contractBalanceFragment\n  }\n}\n    ${ContractBalanceFragmentFragmentDoc}`;\nexport const GetBalanceDocument = gql`\n    query getBalance($owner: Address!, $assetId: AssetId!) {\n  balance(owner: $owner, assetId: $assetId) {\n    ...balanceFragment\n  }\n}\n    ${BalanceFragmentFragmentDoc}`;\nexport const GetBalancesDocument = gql`\n    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {\n  balances(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        ...balanceFragment\n      }\n    }\n  }\n}\n    ${BalanceFragmentFragmentDoc}`;\nexport const GetMessagesDocument = gql`\n    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n  messages(\n    owner: $owner\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        ...messageFragment\n      }\n    }\n  }\n}\n    ${MessageFragmentFragmentDoc}`;\nexport const GetMessageProofDocument = gql`\n    query getMessageProof($transactionId: TransactionId!, $messageId: MessageId!, $commitBlockId: BlockId, $commitBlockHeight: U32) {\n  messageProof(\n    transactionId: $transactionId\n    messageId: $messageId\n    commitBlockId: $commitBlockId\n    commitBlockHeight: $commitBlockHeight\n  ) {\n    ...messageProofFragment\n  }\n}\n    ${MessageProofFragmentFragmentDoc}`;\nexport const GetMessageStatusDocument = gql`\n    query getMessageStatus($nonce: Nonce!) {\n  messageStatus(nonce: $nonce) {\n    state\n  }\n}\n    `;\nexport const DryRunDocument = gql`\n    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {\n  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentFragmentDoc}`;\nexport const SubmitDocument = gql`\n    mutation submit($encodedTransaction: HexString!) {\n  submit(tx: $encodedTransaction) {\n    id\n  }\n}\n    `;\nexport const ProduceBlocksDocument = gql`\n    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U64!) {\n  produceBlocks(\n    blocksToProduce: $blocksToProduce\n    startTimestamp: $startTimestamp\n  )\n}\n    `;\nexport const SubmitAndAwaitDocument = gql`\n    subscription submitAndAwait($encodedTransaction: HexString!) {\n  submitAndAwait(tx: $encodedTransaction) {\n    ...transactionStatusFragment\n  }\n}\n    ${TransactionStatusFragmentFragmentDoc}`;\nexport const StatusChangeDocument = gql`\n    subscription statusChange($transactionId: TransactionId!) {\n  statusChange(id: $transactionId) {\n    ...transactionStatusFragment\n  }\n}\n    ${TransactionStatusFragmentFragmentDoc}`;\nexport type Requester<C = {}, E = unknown> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>\nexport function getSdk<C, E>(requester: Requester<C, E>) {\n  return {\n    getVersion(variables?: GqlGetVersionQueryVariables, options?: C): Promise<GqlGetVersionQuery> {\n      return requester<GqlGetVersionQuery, GqlGetVersionQueryVariables>(GetVersionDocument, variables, options) as Promise<GqlGetVersionQuery>;\n    },\n    getNodeInfo(variables?: GqlGetNodeInfoQueryVariables, options?: C): Promise<GqlGetNodeInfoQuery> {\n      return requester<GqlGetNodeInfoQuery, GqlGetNodeInfoQueryVariables>(GetNodeInfoDocument, variables, options) as Promise<GqlGetNodeInfoQuery>;\n    },\n    getChain(variables?: GqlGetChainQueryVariables, options?: C): Promise<GqlGetChainQuery> {\n      return requester<GqlGetChainQuery, GqlGetChainQueryVariables>(GetChainDocument, variables, options) as Promise<GqlGetChainQuery>;\n    },\n    getTransaction(variables: GqlGetTransactionQueryVariables, options?: C): Promise<GqlGetTransactionQuery> {\n      return requester<GqlGetTransactionQuery, GqlGetTransactionQueryVariables>(GetTransactionDocument, variables, options) as Promise<GqlGetTransactionQuery>;\n    },\n    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, options?: C): Promise<GqlGetTransactionWithReceiptsQuery> {\n      return requester<GqlGetTransactionWithReceiptsQuery, GqlGetTransactionWithReceiptsQueryVariables>(GetTransactionWithReceiptsDocument, variables, options) as Promise<GqlGetTransactionWithReceiptsQuery>;\n    },\n    getTransactions(variables?: GqlGetTransactionsQueryVariables, options?: C): Promise<GqlGetTransactionsQuery> {\n      return requester<GqlGetTransactionsQuery, GqlGetTransactionsQueryVariables>(GetTransactionsDocument, variables, options) as Promise<GqlGetTransactionsQuery>;\n    },\n    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, options?: C): Promise<GqlGetTransactionsByOwnerQuery> {\n      return requester<GqlGetTransactionsByOwnerQuery, GqlGetTransactionsByOwnerQueryVariables>(GetTransactionsByOwnerDocument, variables, options) as Promise<GqlGetTransactionsByOwnerQuery>;\n    },\n    estimatePredicates(variables: GqlEstimatePredicatesQueryVariables, options?: C): Promise<GqlEstimatePredicatesQuery> {\n      return requester<GqlEstimatePredicatesQuery, GqlEstimatePredicatesQueryVariables>(EstimatePredicatesDocument, variables, options) as Promise<GqlEstimatePredicatesQuery>;\n    },\n    getBlock(variables?: GqlGetBlockQueryVariables, options?: C): Promise<GqlGetBlockQuery> {\n      return requester<GqlGetBlockQuery, GqlGetBlockQueryVariables>(GetBlockDocument, variables, options) as Promise<GqlGetBlockQuery>;\n    },\n    getBlockWithTransactions(variables?: GqlGetBlockWithTransactionsQueryVariables, options?: C): Promise<GqlGetBlockWithTransactionsQuery> {\n      return requester<GqlGetBlockWithTransactionsQuery, GqlGetBlockWithTransactionsQueryVariables>(GetBlockWithTransactionsDocument, variables, options) as Promise<GqlGetBlockWithTransactionsQuery>;\n    },\n    getBlocks(variables?: GqlGetBlocksQueryVariables, options?: C): Promise<GqlGetBlocksQuery> {\n      return requester<GqlGetBlocksQuery, GqlGetBlocksQueryVariables>(GetBlocksDocument, variables, options) as Promise<GqlGetBlocksQuery>;\n    },\n    getCoin(variables: GqlGetCoinQueryVariables, options?: C): Promise<GqlGetCoinQuery> {\n      return requester<GqlGetCoinQuery, GqlGetCoinQueryVariables>(GetCoinDocument, variables, options) as Promise<GqlGetCoinQuery>;\n    },\n    getCoins(variables: GqlGetCoinsQueryVariables, options?: C): Promise<GqlGetCoinsQuery> {\n      return requester<GqlGetCoinsQuery, GqlGetCoinsQueryVariables>(GetCoinsDocument, variables, options) as Promise<GqlGetCoinsQuery>;\n    },\n    getCoinsToSpend(variables: GqlGetCoinsToSpendQueryVariables, options?: C): Promise<GqlGetCoinsToSpendQuery> {\n      return requester<GqlGetCoinsToSpendQuery, GqlGetCoinsToSpendQueryVariables>(GetCoinsToSpendDocument, variables, options) as Promise<GqlGetCoinsToSpendQuery>;\n    },\n    getContract(variables: GqlGetContractQueryVariables, options?: C): Promise<GqlGetContractQuery> {\n      return requester<GqlGetContractQuery, GqlGetContractQueryVariables>(GetContractDocument, variables, options) as Promise<GqlGetContractQuery>;\n    },\n    getContractBalance(variables: GqlGetContractBalanceQueryVariables, options?: C): Promise<GqlGetContractBalanceQuery> {\n      return requester<GqlGetContractBalanceQuery, GqlGetContractBalanceQueryVariables>(GetContractBalanceDocument, variables, options) as Promise<GqlGetContractBalanceQuery>;\n    },\n    getBalance(variables: GqlGetBalanceQueryVariables, options?: C): Promise<GqlGetBalanceQuery> {\n      return requester<GqlGetBalanceQuery, GqlGetBalanceQueryVariables>(GetBalanceDocument, variables, options) as Promise<GqlGetBalanceQuery>;\n    },\n    getBalances(variables: GqlGetBalancesQueryVariables, options?: C): Promise<GqlGetBalancesQuery> {\n      return requester<GqlGetBalancesQuery, GqlGetBalancesQueryVariables>(GetBalancesDocument, variables, options) as Promise<GqlGetBalancesQuery>;\n    },\n    getMessages(variables: GqlGetMessagesQueryVariables, options?: C): Promise<GqlGetMessagesQuery> {\n      return requester<GqlGetMessagesQuery, GqlGetMessagesQueryVariables>(GetMessagesDocument, variables, options) as Promise<GqlGetMessagesQuery>;\n    },\n    getMessageProof(variables: GqlGetMessageProofQueryVariables, options?: C): Promise<GqlGetMessageProofQuery> {\n      return requester<GqlGetMessageProofQuery, GqlGetMessageProofQueryVariables>(GetMessageProofDocument, variables, options) as Promise<GqlGetMessageProofQuery>;\n    },\n    getMessageStatus(variables: GqlGetMessageStatusQueryVariables, options?: C): Promise<GqlGetMessageStatusQuery> {\n      return requester<GqlGetMessageStatusQuery, GqlGetMessageStatusQueryVariables>(GetMessageStatusDocument, variables, options) as Promise<GqlGetMessageStatusQuery>;\n    },\n    dryRun(variables: GqlDryRunMutationVariables, options?: C): Promise<GqlDryRunMutation> {\n      return requester<GqlDryRunMutation, GqlDryRunMutationVariables>(DryRunDocument, variables, options) as Promise<GqlDryRunMutation>;\n    },\n    submit(variables: GqlSubmitMutationVariables, options?: C): Promise<GqlSubmitMutation> {\n      return requester<GqlSubmitMutation, GqlSubmitMutationVariables>(SubmitDocument, variables, options) as Promise<GqlSubmitMutation>;\n    },\n    produceBlocks(variables: GqlProduceBlocksMutationVariables, options?: C): Promise<GqlProduceBlocksMutation> {\n      return requester<GqlProduceBlocksMutation, GqlProduceBlocksMutationVariables>(ProduceBlocksDocument, variables, options) as Promise<GqlProduceBlocksMutation>;\n    },\n    submitAndAwait(variables: GqlSubmitAndAwaitSubscriptionVariables, options?: C): AsyncIterable<GqlSubmitAndAwaitSubscription> {\n      return requester<GqlSubmitAndAwaitSubscription, GqlSubmitAndAwaitSubscriptionVariables>(SubmitAndAwaitDocument, variables, options) as AsyncIterable<GqlSubmitAndAwaitSubscription>;\n    },\n    statusChange(variables: GqlStatusChangeSubscriptionVariables, options?: C): AsyncIterable<GqlStatusChangeSubscription> {\n      return requester<GqlStatusChangeSubscription, GqlStatusChangeSubscriptionVariables>(StatusChangeDocument, variables, options) as AsyncIterable<GqlStatusChangeSubscription>;\n    }\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\ntype Cache = {\n  [key: string]: {\n    expires: number;\n    value: BytesLike;\n  };\n};\nconst cache: Cache = {}; // it's a cache hash ~~> cash?\n\nconst DEFAULT_TTL_IN_MS = 30 * 1000; // 30seconds\n\nexport class MemoryCache {\n  ttl: number;\n  constructor(ttlInMs: number = DEFAULT_TTL_IN_MS) {\n    this.ttl = ttlInMs;\n\n    if (typeof ttlInMs !== 'number' || this.ttl <= 0) {\n      throw new FuelError(\n        ErrorCode.INVALID_TTL,\n        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`\n      );\n    }\n  }\n\n  get(value: BytesLike, isAutoExpiring = true): BytesLike | undefined {\n    const key = hexlify(value);\n    if (cache[key]) {\n      if (!isAutoExpiring || cache[key].expires > Date.now()) {\n        return cache[key].value;\n      }\n\n      this.del(value);\n    }\n\n    return undefined;\n  }\n\n  set(value: BytesLike): number {\n    const expiresAt = Date.now() + this.ttl;\n    const key = hexlify(value);\n    cache[key] = {\n      expires: expiresAt,\n      value,\n    };\n\n    return expiresAt;\n  }\n\n  getAllData(): BytesLike[] {\n    return Object.keys(cache).reduce((list, key) => {\n      const data = this.get(key, false);\n      if (data) {\n        list.push(data);\n      }\n\n      return list;\n    }, [] as BytesLike[]);\n  }\n\n  getActiveData(): BytesLike[] {\n    return Object.keys(cache).reduce((list, key) => {\n      const data = this.get(key);\n      if (data) {\n        list.push(data);\n      }\n\n      return list;\n    }, [] as BytesLike[]);\n  }\n\n  del(value: BytesLike) {\n    const key = hexlify(value);\n    delete cache[key];\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type { Input } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestInput = {\n  type: InputType.Coin;\n\n  /** UTXO ID */\n  id: BytesLike;\n\n  /** Owning address or script hash */\n  owner: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Asset ID of the coins */\n  assetId: BytesLike;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Index of witness that authorizes spending the coin */\n  witnessIndex: number;\n\n  /** UTXO being spent must have been created at least this many blocks ago */\n  maturity?: number;\n\n  /** Gas used by predicate */\n  predicateGasUsed?: BigNumberish;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\n\nexport type MessageTransactionRequestInput = {\n  type: InputType.Message;\n\n  /** Address of sender */\n  sender: BytesLike;\n\n  /** Address of recipient */\n  recipient: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Index of witness that authorizes the message */\n  witnessIndex: number;\n\n  /** Unique nonce of message */\n  nonce: BytesLike;\n\n  /** Gas used by predicate */\n  predicateGasUsed?: BigNumberish;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n\n  /** data of message */\n  data?: BytesLike;\n};\n\nexport type ContractTransactionRequestInput = {\n  type: InputType.Contract;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Contract ID */\n  contractId: BytesLike;\n};\nexport type TransactionRequestInput =\n  | CoinTransactionRequestInput\n  | ContractTransactionRequestInput\n  | MessageTransactionRequestInput;\n\n/** @hidden */\nexport const inputify = (value: TransactionRequestInput): Input => {\n  const { type } = value;\n\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Coin,\n        utxoID: {\n          transactionId: hexlify(arrayify(value.id).slice(0, 32)),\n          outputIndex: arrayify(value.id)[32],\n        },\n        owner: hexlify(value.owner),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        witnessIndex: value.witnessIndex,\n        maturity: value.maturity ?? 0,\n        predicateGasUsed: bn(value.predicateGasUsed),\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        contractID: hexlify(value.contractId),\n      };\n    }\n    case InputType.Message: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      const data = arrayify(value.data ?? '0x');\n      return {\n        type: InputType.Message,\n        sender: hexlify(value.sender),\n        recipient: hexlify(value.recipient),\n        amount: bn(value.amount),\n        nonce: hexlify(value.nonce),\n        witnessIndex: value.witnessIndex,\n        predicateGasUsed: bn(value.predicateGasUsed),\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n        data: hexlify(data),\n        dataLength: data.length,\n      };\n    }\n    default: {\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_INPUT,\n        `Invalid transaction input type: ${type}.`\n      );\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Output } from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestOutput = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Amount of coins to send */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ContractTransactionRequestOutput = {\n  type: OutputType.Contract;\n  /** Index of input contract */\n  inputIndex: number;\n};\nexport type ChangeTransactionRequestOutput = {\n  type: OutputType.Change;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type VariableTransactionRequestOutput = {\n  type: OutputType.Variable;\n};\nexport type ContractCreatedTransactionRequestOutput = {\n  type: OutputType.ContractCreated;\n  /** Contract ID */\n  contractId: BytesLike;\n  /** State Root */\n  stateRoot: BytesLike;\n};\nexport type TransactionRequestOutput =\n  | CoinTransactionRequestOutput\n  | ContractTransactionRequestOutput\n  | ChangeTransactionRequestOutput\n  | VariableTransactionRequestOutput\n  | ContractCreatedTransactionRequestOutput;\n\n/** @hidden */\nexport const outputify = (value: TransactionRequestOutput): Output => {\n  const { type } = value;\n\n  switch (type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify(value.to),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify(value.to),\n        amount: bn(0),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: ZeroBytes32,\n        amount: bn(0),\n        assetId: ZeroBytes32,\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify(value.contractId),\n        stateRoot: hexlify(value.stateRoot),\n      };\n    }\n    default: {\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_INPUT,\n        `Invalid transaction output type: ${type}.`\n      );\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { addressify } from '@fuel-ts/address';\nimport { BaseAssetId } from '@fuel-ts/address/configs';\nimport type { AddressLike, AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { TransactionCreate, TransactionScript } from '@fuel-ts/transactions';\nimport { TransactionType, TransactionCoder, InputType, OutputType } from '@fuel-ts/transactions';\n\nimport type { Coin } from '../coin';\nimport type { CoinQuantity, CoinQuantityLike } from '../coin-quantity';\nimport { coinQuantityfy } from '../coin-quantity';\nimport type { MessageCoin } from '../message';\nimport type { Resource } from '../resource';\nimport { isCoin } from '../resource';\nimport { calculatePriceWithFactor, normalizeJSON } from '../utils';\n\nimport type { CoinTransactionRequestOutput } from '.';\nimport { NoWitnessAtIndexError, ChangeOutputCollisionError } from './errors';\nimport type {\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n  MessageTransactionRequestInput,\n} from './input';\nimport { inputify } from './input';\nimport type { TransactionRequestOutput, ChangeTransactionRequestOutput } from './output';\nimport { outputify } from './output';\nimport type { TransactionRequestWitness } from './witness';\nimport { witnessify } from './witness';\n\nexport {\n  /**\n   * @hidden\n   */\n  TransactionType,\n};\n\n/**\n * @hidden\n *\n * Interface defining a like structure for a base transaction request.\n */\nexport interface BaseTransactionRequestLike {\n  /** Gas price for transaction */\n  gasPrice?: BigNumberish;\n  /** Gas limit for transaction */\n  gasLimit?: BigNumberish;\n  /** Block until which tx cannot be included */\n  maturity?: number;\n  /** List of inputs */\n  inputs?: TransactionRequestInput[];\n  /** List of outputs */\n  outputs?: TransactionRequestOutput[];\n  /** List of witnesses */\n  witnesses?: TransactionRequestWitness[];\n}\n\n/**\n * Abstract class to define the functionalities of a transaction request transaction request.\n */\nexport abstract class BaseTransactionRequest implements BaseTransactionRequestLike {\n  /** Type of the transaction */\n  abstract type: TransactionType;\n  /** Gas price for transaction */\n  gasPrice: BN;\n  /** Gas limit for transaction */\n  gasLimit: BN;\n  /** Block until which tx cannot be included */\n  maturity: number;\n  /** List of inputs */\n  inputs: TransactionRequestInput[] = [];\n  /** List of outputs */\n  outputs: TransactionRequestOutput[] = [];\n  /** List of witnesses */\n  witnesses: TransactionRequestWitness[] = [];\n\n  /**\n   * Constructor for initializing a base transaction request.\n   *\n   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.\n   */\n  constructor({\n    gasPrice,\n    gasLimit,\n    maturity,\n    inputs,\n    outputs,\n    witnesses,\n  }: BaseTransactionRequestLike = {}) {\n    this.gasPrice = bn(gasPrice);\n    this.gasLimit = bn(gasLimit);\n    this.maturity = maturity ?? 0;\n    this.inputs = inputs ?? [];\n    this.outputs = outputs ?? [];\n    this.witnesses = witnesses ?? [];\n  }\n\n  /**\n   * Method to obtain the base transaction details.\n   *\n   * @returns The base transaction details.\n   */\n  protected getBaseTransaction(): Pick<\n    TransactionScript | TransactionCreate,\n    keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'\n  > {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n    return {\n      gasPrice: this.gasPrice,\n      gasLimit: this.gasLimit,\n      maturity: this.maturity,\n      inputs,\n      outputs,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length,\n    };\n  }\n\n  abstract toTransaction(): TransactionCreate | TransactionScript;\n\n  /**\n   * Converts the transaction request to a byte array.\n   *\n   * @returns The transaction bytes.\n   */\n  toTransactionBytes(): Uint8Array {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n\n  /**\n   * @hidden\n   *\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  protected pushInput(input: TransactionRequestInput): number {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n\n  /**\n   * @hidden\n   *\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  protected pushOutput(output: TransactionRequestOutput): number {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * @hidden\n   *\n   * Creates an empty witness without any side effects and returns the index\n   */\n  protected createWitness() {\n    this.witnesses.push('0x');\n    return this.witnesses.length - 1;\n  }\n\n  /**\n   * Updates the witness for a given owner and signature.\n   *\n   * @param address - The address to get the coin input witness index for.\n   * @param signature - The signature to update the witness with.\n   */\n  updateWitnessByOwner(address: AbstractAddress, signature: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(address);\n    if (typeof witnessIndex === 'number') {\n      this.updateWitness(witnessIndex, signature);\n    }\n  }\n\n  /**\n   * Updates an existing witness without any side effects.\n   *\n   * @param index - The index of the witness to update.\n   * @param witness - The new witness.\n   * @throws If the witness does not exist.\n   */\n  updateWitness(index: number, witness: TransactionRequestWitness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n\n  /**\n   * Gets the coin inputs for a transaction.\n   *\n   * @returns The coin inputs.\n   */\n  getCoinInputs(): CoinTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is CoinTransactionRequestInput => input.type === InputType.Coin\n    );\n  }\n\n  /**\n   * Gets the coin outputs for a transaction.\n   *\n   * @returns The coin outputs.\n   */\n  getCoinOutputs(): CoinTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is CoinTransactionRequestOutput => output.type === OutputType.Coin\n    );\n  }\n\n  /**\n   * Gets the change outputs for a transaction.\n   *\n   * @returns The change outputs.\n   */\n  getChangeOutputs(): ChangeTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ChangeTransactionRequestOutput => output.type === OutputType.Change\n    );\n  }\n\n  /**\n   * @hidden\n   *\n   * Returns the witnessIndex of the found CoinInput.\n   */\n  getCoinInputWitnessIndexByOwner(owner: AddressLike): number | undefined {\n    const ownerAddress = addressify(owner);\n\n    const found = this.inputs.find((input) => {\n      switch (input.type) {\n        case InputType.Coin:\n          return hexlify((<CoinTransactionRequestInput>input).owner) === ownerAddress.toB256();\n        case InputType.Message:\n          return (\n            hexlify((<MessageTransactionRequestInput>input).recipient) === ownerAddress.toB256()\n          );\n        default:\n          return false;\n      }\n    });\n\n    return (<CoinTransactionRequestInput>found)?.witnessIndex;\n  }\n\n  /**\n   * Adds a single coin input to the transaction and a change output for the related\n   * assetId, if one it was not added yet.\n   *\n   * @param coin - Coin resource.\n   * @param predicate - Predicate bytes.\n   * @param predicateData - Predicate data bytes.\n   */\n  addCoinInput(coin: Coin, predicate?: AbstractPredicate) {\n    const { assetId, owner, amount } = coin;\n\n    let witnessIndex;\n\n    if (predicate) {\n      witnessIndex = 0;\n    } else {\n      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n\n      // Insert a dummy witness if no witness exists\n      if (typeof witnessIndex !== 'number') {\n        witnessIndex = this.createWitness();\n      }\n    }\n\n    const input: CoinTransactionRequestInput = {\n      ...coin,\n      type: InputType.Coin,\n      owner: owner.toB256(),\n      amount,\n      assetId,\n      txPointer: '0x00000000000000000000000000000000',\n      witnessIndex,\n      predicate: predicate?.bytes,\n      predicateData: predicate?.predicateData,\n    };\n\n    // Insert the Input\n    this.pushInput(input);\n\n    // Insert a ChangeOutput if it does not exist\n    this.addChangeOutput(owner, assetId);\n  }\n\n  /**\n   * Adds a single message input to the transaction and a change output for the\n   * baseAssetId, if one it was not added yet.\n   *\n   * @param message - Message resource.\n   * @param predicate - Predicate bytes.\n   * @param predicateData - Predicate data bytes.\n   */\n  addMessageInput(message: MessageCoin, predicate?: AbstractPredicate) {\n    const { recipient, sender, amount } = message;\n\n    const assetId = BaseAssetId;\n\n    let witnessIndex;\n\n    if (predicate) {\n      witnessIndex = 0;\n    } else {\n      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);\n\n      // Insert a dummy witness if no witness exists\n      if (typeof witnessIndex !== 'number') {\n        witnessIndex = this.createWitness();\n      }\n    }\n\n    const input: MessageTransactionRequestInput = {\n      ...message,\n      type: InputType.Message,\n      sender: sender.toB256(),\n      recipient: recipient.toB256(),\n      amount,\n      witnessIndex,\n      predicate: predicate?.bytes,\n      predicateData: predicate?.predicateData,\n    };\n\n    // Insert the Input\n    this.pushInput(input);\n\n    // Insert a ChangeOutput if it does not exist\n    this.addChangeOutput(recipient, assetId);\n  }\n\n  /**\n   * Adds a single resource to the transaction by adding a coin/message input and a\n   * change output for the related assetId, if one it was not added yet.\n   *\n   * @param resource - The resource to add.\n   * @returns This transaction.\n   */\n  addResource(resource: Resource) {\n    if (isCoin(resource)) {\n      this.addCoinInput(resource);\n    } else {\n      this.addMessageInput(resource);\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds multiple resources to the transaction by adding coin/message inputs and change\n   * outputs from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addResources(resources: ReadonlyArray<Resource>) {\n    resources.forEach((resource) => this.addResource(resource));\n\n    return this;\n  }\n\n  /**\n   * Adds multiple resources to the transaction by adding coin/message inputs and change\n   * outputs from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addPredicateResource(resource: Resource, predicate: AbstractPredicate) {\n    if (isCoin(resource)) {\n      this.addCoinInput(resource, predicate);\n    } else {\n      this.addMessageInput(resource, predicate);\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds multiple predicate coin/message inputs to the transaction and change outputs\n   * from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addPredicateResources(resources: Resource[], predicate: AbstractPredicate) {\n    resources.forEach((resource) => this.addPredicateResource(resource, predicate));\n\n    return this;\n  }\n\n  /**\n   * Adds a coin output to the transaction.\n   *\n   * @param to - Address of the owner.\n   * @param amount - Amount of coin.\n   * @param assetId - Asset ID of coin.\n   */\n  addCoinOutput(to: AddressLike, amount: BigNumberish, assetId: BytesLike = BaseAssetId) {\n    this.pushOutput({\n      type: OutputType.Coin,\n      to: addressify(to).toB256(),\n      amount,\n      assetId,\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds multiple coin outputs to the transaction.\n   *\n   * @param to - Address of the destination.\n   * @param quantities - Quantities of coins.\n   */\n  addCoinOutputs(to: AddressLike, quantities: CoinQuantityLike[]) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType.Coin,\n        to: addressify(to).toB256(),\n        amount: quantity.amount,\n        assetId: quantity.assetId,\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a change output to the transaction.\n   *\n   * @param to - Address of the owner.\n   * @param assetId - Asset ID of coin.\n   */\n  addChangeOutput(to: AddressLike, assetId: BytesLike = BaseAssetId) {\n    // Find the ChangeOutput for the AssetId of the Resource\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === assetId\n    );\n\n    // Throw if the existing ChangeOutput is not for the same owner\n    if (changeOutput && hexlify(changeOutput.to) !== addressify(to).toB256()) {\n      throw new ChangeOutputCollisionError();\n    }\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: addressify(to).toB256(),\n        assetId,\n      });\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  byteSize() {\n    return this.toTransactionBytes().length;\n  }\n\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction. This is required even if the gasPrice is 0.\n   *\n   * @returns The minimum amount in coins required to create a transaction.\n   */\n  calculateFee(gasPriceFactor: BN): CoinQuantity {\n    const gasFee = calculatePriceWithFactor(this.gasLimit, this.gasPrice, gasPriceFactor);\n\n    return {\n      assetId: BaseAssetId,\n      amount: gasFee.isZero() ? bn(1) : gasFee,\n    };\n  }\n\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction.\n   *\n   * @returns The transaction as a JSON object.\n   */\n  toJSON() {\n    return normalizeJSON(this);\n  }\n\n  /**\n   * @hidden\n   *\n   * Determines whether the transaction has a predicate input.\n   *\n   * @returns Whether the transaction has a predicate input.\n   */\n  hasPredicateInput(): boolean {\n    return Boolean(\n      this.inputs.find(\n        (input) => 'predicate' in input && input.predicate && input.predicate !== arrayify('0x')\n      )\n    );\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\n\nimport type { Coin } from './coin';\nimport type { MessageCoin } from './message';\n\nexport type RawCoin = {\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  blockCreated: string;\n  txCreatedIdx: string;\n};\n\nexport type RawMessage = {\n  amount: string;\n  sender: string;\n  assetId: string;\n  recipient: string;\n  data: string;\n  nonce: string;\n  daHeight: string;\n};\n\nexport type RawResource = RawCoin | RawMessage;\nexport type Resource = Coin | MessageCoin;\n\n/** @hidden */\nexport type ExcludeResourcesOption = {\n  utxos?: BytesLike[];\n  messages?: BytesLike[];\n};\n\n/** @hidden */\nexport const isRawCoin = (resource: RawResource): resource is RawCoin => 'utxoId' in resource;\n/** @hidden */\nexport const isRawMessage = (resource: RawResource): resource is RawMessage =>\n  'recipient' in resource;\n/** @hidden */\nexport const isCoin = (resource: Resource): resource is Coin => 'id' in resource;\n/** @hidden */\nexport const isMessage = (resource: Resource): resource is MessageCoin => 'recipient' in resource;\n","import { arrayify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptBurn,\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptMessageOut,\n  ReceiptMint,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptScriptResult,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n} from '@fuel-ts/transactions';\nimport {\n  ReceiptBurnCoder,\n  ReceiptMessageOutCoder,\n  ReceiptMintCoder,\n  ReceiptType,\n} from '@fuel-ts/transactions';\nimport { FAILED_TRANSFER_TO_ADDRESS_SIGNAL } from '@fuel-ts/transactions/configs';\n\nimport type { GqlReceipt } from '../__generated__/operations';\nimport { GqlReceiptType } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\n\n/** @hidden */\nconst doesReceiptHaveMissingOutputVariables = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptRevert =>\n  receipt.type === ReceiptType.Revert &&\n  receipt.val.toString('hex') === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;\n\n/** @hidden */\nconst doesReceiptHaveMissingContractId = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptPanic =>\n  receipt.type === ReceiptType.Panic &&\n  receipt.contractId !== '0x0000000000000000000000000000000000000000000000000000000000000000';\n\n/** @hidden */\nexport const getReceiptsWithMissingData = (receipts: Array<TransactionResultReceipt>) =>\n  receipts.reduce<{\n    missingOutputVariables: Array<ReceiptRevert>;\n    missingOutputContractIds: Array<ReceiptPanic>;\n  }>(\n    (memo, receipt) => {\n      if (doesReceiptHaveMissingOutputVariables(receipt)) {\n        memo.missingOutputVariables.push(receipt);\n      }\n      if (doesReceiptHaveMissingContractId(receipt)) {\n        memo.missingOutputContractIds.push(receipt);\n      }\n      return memo;\n    },\n    {\n      missingOutputVariables: [],\n      missingOutputContractIds: [],\n    }\n  );\n\nconst hexOrZero = (hex?: string | null) => hex || ZeroBytes32;\n\nexport function assembleReceiptByType(receipt: GqlReceipt) {\n  const { receiptType } = receipt;\n\n  switch (receiptType) {\n    case GqlReceiptType.Call: {\n      const callReceipt: ReceiptCall = {\n        type: ReceiptType.Call,\n        from: hexOrZero(receipt.contract?.id),\n        to: hexOrZero(receipt?.to?.id),\n        amount: bn(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        gas: bn(receipt.gas),\n        param1: bn(receipt.param1),\n        param2: bn(receipt.param2),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return callReceipt;\n    }\n\n    case GqlReceiptType.Return: {\n      const returnReceipt: ReceiptReturn = {\n        type: ReceiptType.Return,\n        id: hexOrZero(receipt.contract?.id),\n        val: bn(receipt.val),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return returnReceipt;\n    }\n\n    case GqlReceiptType.ReturnData: {\n      const returnDataReceipt: ReceiptReturnData = {\n        type: ReceiptType.ReturnData,\n        id: hexOrZero(receipt.contract?.id),\n        ptr: bn(receipt.ptr),\n        len: bn(receipt.len),\n        digest: hexOrZero(receipt.digest),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return returnDataReceipt;\n    }\n\n    case GqlReceiptType.Panic: {\n      const panicReceipt: ReceiptPanic = {\n        type: ReceiptType.Panic,\n        id: hexOrZero(receipt.contract?.id),\n        reason: bn(receipt.reason),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n        contractId: hexOrZero(receipt.contractId),\n      };\n\n      return panicReceipt;\n    }\n\n    case GqlReceiptType.Revert: {\n      const revertReceipt: ReceiptRevert = {\n        type: ReceiptType.Revert,\n        id: hexOrZero(receipt.contract?.id),\n        val: bn(receipt.ra),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n      return revertReceipt;\n    }\n\n    case GqlReceiptType.Log: {\n      const logReceipt: ReceiptLog = {\n        type: ReceiptType.Log,\n        id: hexOrZero(receipt.contract?.id),\n        val0: bn(receipt.ra),\n        val1: bn(receipt.rb),\n        val2: bn(receipt.rc),\n        val3: bn(receipt.rd),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return logReceipt;\n    }\n\n    case GqlReceiptType.LogData: {\n      const logDataReceipt: ReceiptLogData = {\n        type: ReceiptType.LogData,\n        id: hexOrZero(receipt.contract?.id),\n        val0: bn(receipt.ra),\n        val1: bn(receipt.rb),\n        ptr: bn(receipt.ptr),\n        len: bn(receipt.len),\n        digest: hexOrZero(receipt.digest),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n      return logDataReceipt;\n    }\n\n    case GqlReceiptType.Transfer: {\n      const transferReceipt: ReceiptTransfer = {\n        type: ReceiptType.Transfer,\n        from: hexOrZero(receipt.contract?.id),\n        to: hexOrZero(receipt?.to?.id),\n        amount: bn(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return transferReceipt;\n    }\n\n    case GqlReceiptType.TransferOut: {\n      const transferOutReceipt: ReceiptTransferOut = {\n        type: ReceiptType.TransferOut,\n        from: hexOrZero(receipt.contract?.id),\n        to: hexOrZero(receipt?.to?.id),\n        amount: bn(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n      return transferOutReceipt;\n    }\n\n    case GqlReceiptType.ScriptResult: {\n      const scriptResultReceipt: ReceiptScriptResult = {\n        type: ReceiptType.ScriptResult,\n        result: bn(receipt.result),\n        gasUsed: bn(receipt.gasUsed),\n      };\n\n      return scriptResultReceipt;\n    }\n\n    case GqlReceiptType.MessageOut: {\n      const sender = hexOrZero(receipt.sender);\n      const recipient = hexOrZero(receipt.recipient);\n      const nonce = hexOrZero(receipt.nonce);\n      const amount = bn(receipt.amount);\n      const data = receipt.data ? arrayify(receipt.data) : Uint8Array.from([]);\n      const digest = hexOrZero(receipt.digest);\n\n      const messageId = ReceiptMessageOutCoder.getMessageId({\n        sender,\n        recipient,\n        nonce,\n        amount,\n        data,\n      });\n\n      const receiptMessageOut: ReceiptMessageOut = {\n        type: ReceiptType.MessageOut,\n        sender,\n        recipient,\n        amount,\n        nonce,\n        data,\n        digest,\n        messageId,\n      };\n\n      return receiptMessageOut;\n    }\n\n    case GqlReceiptType.Mint: {\n      const contractId = hexOrZero(receipt.contract?.id);\n      const subId = hexOrZero(receipt.subId);\n      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);\n\n      const mintReceipt: ReceiptMint = {\n        type: ReceiptType.Mint,\n        subId,\n        contractId,\n        assetId,\n        val: bn(receipt.val),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return mintReceipt;\n    }\n\n    case GqlReceiptType.Burn: {\n      const contractId = hexOrZero(receipt.contract?.id);\n      const subId = hexOrZero(receipt.subId);\n      const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);\n\n      const burnReceipt: ReceiptBurn = {\n        type: ReceiptType.Burn,\n        subId,\n        contractId,\n        assetId,\n        val: bn(receipt.val),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return burnReceipt;\n    }\n\n    default:\n      throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);\n  }\n}\n","import type { BN } from '@fuel-ts/math';\nimport { bn, multiply } from '@fuel-ts/math';\nimport type { Witness } from '@fuel-ts/transactions';\nimport { ReceiptType, TransactionType } from '@fuel-ts/transactions';\n\nimport type {\n  TransactionResultReceipt,\n  TransactionResultScriptResultReceipt,\n} from '../transaction-response';\n\n/** @hidden */\nexport const calculatePriceWithFactor = (gasUsed: BN, gasPrice: BN, priceFactor: BN): BN =>\n  bn(Math.ceil(gasUsed.toNumber() / priceFactor.toNumber()) * gasPrice.toNumber());\n\n/** @hidden */\nexport const getGasUsedFromReceipts = (receipts: Array<TransactionResultReceipt>): BN => {\n  const scriptResult = receipts.filter(\n    (receipt) => receipt.type === ReceiptType.ScriptResult\n  ) as TransactionResultScriptResultReceipt[];\n\n  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));\n\n  return gasUsed;\n};\n\n/**\n * @hidden\n */\nexport interface CalculateTransactionFeeForScriptParams {\n  receipts: TransactionResultReceipt[];\n  gasPrice: BN;\n  gasPriceFactor: BN;\n  margin?: number;\n}\n\n/** @hidden */\nexport const calculateTransactionFeeForScript = (\n  params: CalculateTransactionFeeForScriptParams\n) => {\n  const { gasPrice, receipts, gasPriceFactor, margin = 1 } = params;\n\n  const gasUsed = multiply(getGasUsedFromReceipts(receipts), margin);\n  const fee = calculatePriceWithFactor(gasUsed, gasPrice, gasPriceFactor);\n\n  return {\n    fee,\n    gasUsed,\n  };\n};\n\n/** @hidden */\nexport interface CalculateTransactionFeeForContractCreatedParams {\n  gasPrice: BN;\n  transactionBytes: Uint8Array;\n  transactionWitnesses: Witness[];\n  gasPriceFactor: BN;\n  gasPerByte?: BN;\n}\n\n/** @hidden */\nexport const calculateTransactionFeeForContractCreated = (\n  params: CalculateTransactionFeeForContractCreatedParams\n) => {\n  const { gasPrice, transactionBytes, transactionWitnesses, gasPerByte, gasPriceFactor } = params;\n\n  const witnessSize = transactionWitnesses?.reduce((total, w) => total + w.dataLength, 0) || 0;\n\n  const txChargeableBytes = bn(transactionBytes.length - witnessSize);\n\n  const gasUsed = bn(\n    Math.ceil(\n      (txChargeableBytes.toNumber() * bn(gasPerByte).toNumber()) / bn(gasPriceFactor).toNumber()\n    )\n  );\n\n  const fee = gasUsed.mul(gasPrice);\n\n  return {\n    fee,\n    gasUsed,\n  };\n};\n\nexport interface CalculateTransactionFeeParams {\n  receipts: TransactionResultReceipt[];\n  gasPrice: BN;\n  margin?: number;\n  transactionBytes: Uint8Array;\n  transactionWitnesses: Witness[];\n  transactionType: TransactionType;\n  gasPriceFactor: BN;\n  gasPerByte?: BN;\n}\n\n/** @hidden */\nexport const calculateTransactionFee = ({\n  receipts,\n  gasPrice,\n  gasPriceFactor,\n  gasPerByte,\n  transactionBytes,\n  transactionType,\n  transactionWitnesses,\n  margin,\n}: CalculateTransactionFeeParams) => {\n  const isTypeCreate = transactionType === TransactionType.Create;\n\n  if (isTypeCreate) {\n    return calculateTransactionFeeForContractCreated({\n      gasPerByte,\n      gasPriceFactor,\n      transactionBytes,\n      transactionWitnesses,\n      gasPrice,\n    });\n  }\n\n  return calculateTransactionFeeForScript({\n    gasPrice,\n    receipts,\n    gasPriceFactor,\n    margin: margin || 1,\n  });\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nconst DEFAULT_BLOCK_EXPLORER_URL = 'https://fuellabs.github.io/block-explorer-v2';\n\n/** @hidden */\nconst getPathFromInput = (\n  key: BuildBlockExplorerUrlHelperParam,\n  value: string | number | undefined\n) => {\n  const pathMap = {\n    address: `address`,\n    txId: `transaction`,\n    blockNumber: `block`,\n  };\n  const path = pathMap[key] || key;\n  return `${path}/${value}`;\n};\n\ntype BuildBlockExplorerUrlHelperParam = 'address' | 'txId' | 'blockNumber';\n\n/**\n * @hidden\n *\n * Builds a block explorer url based on and the given path, block explorer URL and provider URL\n */\nexport const buildBlockExplorerUrl = (\n  options: {\n    blockExplorerUrl?: string;\n    path?: string;\n    providerUrl?: string;\n    address?: string;\n    txId?: string;\n    blockNumber?: number;\n  } = {}\n) => {\n  const { blockExplorerUrl, path, providerUrl, address, txId, blockNumber } = options;\n  const explorerUrl = blockExplorerUrl || DEFAULT_BLOCK_EXPLORER_URL;\n\n  // make sure that only ONE or none of the following is defined: address, txId, blockNumber\n  const customInputParams = [\n    {\n      key: 'address',\n      value: address,\n    },\n    {\n      key: 'txId',\n      value: txId,\n    },\n    {\n      key: 'blockNumber',\n      value: blockNumber,\n    },\n  ];\n\n  const definedValues = customInputParams\n    .filter((param) => !!param.value)\n    .map(({ key, value }) => ({\n      key,\n      value,\n    }));\n\n  const hasAnyDefinedValues = definedValues.length > 0;\n\n  if (definedValues.length > 1) {\n    throw new FuelError(\n      ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,\n      `Only one of the following can be passed in to buildBlockExplorerUrl: ${customInputParams\n        .map((param) => param.key)\n        .join(', ')}.`\n    );\n  }\n\n  if (path && definedValues.length > 0) {\n    const inputKeys = customInputParams.map(({ key }) => key).join(', ');\n    throw new FuelError(\n      ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,\n      `You cannot pass in a path to 'buildBlockExplorerUrl' along with any of the following: ${inputKeys}.`\n    );\n  }\n\n  const pathGeneratedFromInputParams = hasAnyDefinedValues\n    ? getPathFromInput(\n        definedValues[0].key as BuildBlockExplorerUrlHelperParam,\n        definedValues[0].value\n      )\n    : '';\n\n  // Remove leading and trailing slashes from the path and block explorer url respectively, if present\n  const trimSlashes = /^\\/|\\/$/gm;\n  const cleanPath = path ? path.replace(trimSlashes, '') : pathGeneratedFromInputParams;\n  const cleanBlockExplorerUrl = explorerUrl.replace(trimSlashes, '');\n  const cleanProviderUrl = providerUrl?.replace(trimSlashes, '');\n  const encodedProviderUrl = cleanProviderUrl ? encodeURIComponent(cleanProviderUrl) : undefined;\n\n  // if the block explorer url doesn't have a protocol i.e. http:// or https://, add https://\n  const protocol = cleanBlockExplorerUrl.match(/^https?:\\/\\//) ? '' : 'https://';\n  const providerUrlProtocol = cleanProviderUrl?.match(/^https?:\\/\\//) ? '' : 'https://';\n\n  const url = `${protocol}${cleanBlockExplorerUrl}/${cleanPath}${\n    encodedProviderUrl ? `?providerUrl=${providerUrlProtocol}${encodedProviderUrl}` : ''\n  }`;\n\n  return url;\n};\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hexlify } from '@ethersproject/bytes';\nimport { clone } from 'ramda';\n\n// When parsing a Transaction to JSON we need\n// to convert special types into each respective\n// JSON friendly value. This enables a tx to be\n// stringified and parsed back into a Transaction\n/** @hidden */\nfunction normalize(object: any) {\n  Object.keys(object).forEach((key) => {\n    switch (object[key]?.constructor.name) {\n      case 'Uint8Array':\n        object[key] = hexlify(object[key]);\n        break;\n      case 'Array':\n        object[key] = normalize(object[key]);\n        break;\n      case 'BN':\n        object[key] = object[key].toHex();\n        break;\n      case 'Address':\n        object[key] = object[key].toB256();\n        break;\n      case 'Object':\n        object[key] = normalize(object[key]);\n        break;\n      default:\n        break;\n    }\n  });\n  return object;\n}\n\n/**\n * Stringify Transaction to a JSON object\n * compatible with the Transaction class constructor.\n */\n/** @hidden */\nexport function normalizeJSON(root: any) {\n  // Do a single deep clone before normalizing\n  // to avoid mutating the original object\n  // and doing extra clones on each iteration\n  return normalize(clone(root));\n}\n","/** @hidden */\nexport function sleep(time: number) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, time);\n  });\n}\n","/**\n * @hidden\n *\n * Converts a TAI64 timestamp to a Unix timestamp in milliseconds.\n *\n * TAI64 is a 64-bit unsigned integer format that represents a point in time\n * as the number of TAI seconds elapsed since 00:00:00 TAI, January 1, 1970.\n *\n * Unix timestamp, on the other hand, represents the number of milliseconds\n * elapsed since 00:00:00 UTC, January 1, 1970.\n *\n * To convert a TAI64 timestamp to a Unix timestamp, we need to subtract the\n * TAI64 epoch time (00:00:00 TAI, January 1, 1970) from the TAI64 timestamp\n * and then add the Unix epoch time (00:00:00 UTC, January 1, 1970). The epoch\n * time difference between TAI64 and Unix is 2 ** 62 + 10.\n *\n * @param tai64Timestamp - The TAI64 timestamp to convert.\n * @returns - The Unix timestamp in milliseconds.\n */\nexport const fromTai64ToUnix = (tai64Timestamp: string) =>\n  Number(BigInt(tai64Timestamp) - BigInt(2 ** 62) - BigInt(10));\n\n/**\n * @hidden\n *\n * Converts a Unix timestamp in milliseconds to a TAI64 timestamp.\n *\n * Unix timestamp represents the number of milliseconds elapsed since\n * 00:00:00 UTC, January 1, 1970. TAI64 timestamp is a 64-bit unsigned\n * integer format that represents a point in time as the number of TAI\n * seconds elapsed since 00:00:00 TAI, January 1, 1970.\n *\n * To convert a Unix timestamp to a TAI64 timestamp, we need to add the\n * TAI64 epoch time (00:00:00 TAI, January 1, 1970) to the Unix timestamp\n * and then subtract the Unix epoch time (00:00:00 UTC, January 1, 1970).\n * The epoch time difference between TAI64 and Unix is 2 ** 62 + 10.\n *\n * @param unixTimestampMs - The Unix timestamp in milliseconds to convert.\n * @returns - The TAI64 timestamp as a string.\n */\nexport const fromUnixToTai64 = (unixTimestampMs: number) =>\n  (BigInt(unixTimestampMs) + BigInt(2 ** 62) + BigInt(10)).toString();\n","/* eslint-disable max-classes-per-file */\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\n\n/**\n * @hidden\n */\nexport class ChangeOutputCollisionError extends Error {\n  name = 'ChangeOutputCollisionError';\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n}\n\n/**\n * @hidden\n */\nexport class NoWitnessAtIndexError extends Error {\n  name = 'NoWitnessAtIndexError';\n  constructor(public readonly index: number) {\n    super();\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n}\n\n/**\n * @hidden\n */\nexport class NoWitnessByOwnerError extends Error {\n  name = 'NoWitnessByOwnerError';\n  constructor(public readonly owner: AbstractAddress) {\n    super();\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Witness } from '@fuel-ts/transactions';\n\nexport type TransactionRequestWitness = BytesLike;\n\nexport const witnessify = (value: TransactionRequestWitness): Witness => {\n  const data = arrayify(value);\n\n  return {\n    data: hexlify(data),\n    dataLength: data.length,\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport type { TransactionCreate } from '@fuel-ts/transactions';\nimport { TransactionType, OutputType } from '@fuel-ts/transactions';\n\nimport type { ContractCreatedTransactionRequestOutput } from './output';\nimport type { TransactionRequestStorageSlot } from './storage-slot';\nimport { storageSlotify } from './storage-slot';\nimport { BaseTransactionRequest } from './transaction-request';\nimport type { BaseTransactionRequestLike } from './transaction-request';\n\n/**\n * @hidden\n */\nexport interface CreateTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex?: number;\n  /** Salt */\n  salt?: BytesLike;\n  /** List of storage slots to initialize */\n  storageSlots?: TransactionRequestStorageSlot[];\n}\n\n/**\n * `CreateTransactionRequest` provides functionalities for creating a transaction request that creates a contract.\n */\nexport class CreateTransactionRequest extends BaseTransactionRequest {\n  static from(obj: CreateTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Create as const;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex: number;\n  /** Salt */\n  salt: string;\n  /** List of storage slots to initialize */\n  storageSlots: TransactionRequestStorageSlot[];\n\n  /**\n   * Creates an instance `CreateTransactionRequest`.\n   *\n   * @param createTransactionRequestLike - The initial values for the instance\n   */\n  constructor({\n    bytecodeWitnessIndex,\n    salt,\n    storageSlots,\n    ...rest\n  }: CreateTransactionRequestLike = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify(salt ?? ZeroBytes32);\n    this.storageSlots = [...(storageSlots ?? [])];\n  }\n\n  /**\n   * Converts the transaction request to a `TransactionCreate`.\n   *\n   * @returns The transaction create object.\n   */\n  toTransaction(): TransactionCreate {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType.Create,\n      ...baseTransaction,\n      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,\n      bytecodeWitnessIndex,\n      storageSlotsCount: storageSlots.length,\n      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,\n      storageSlots,\n    };\n  }\n\n  /**\n   * Get contract created outputs for the transaction.\n   *\n   * @returns An array of contract created transaction request outputs.\n   */\n  getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractCreatedTransactionRequestOutput =>\n        output.type === OutputType.ContractCreated\n    );\n  }\n\n  /**\n   * Adds a contract created output to the transaction request.\n   *\n   * @param contractId - The contract ID.\n   * @param stateRoot - The state root.\n   */\n  addContractCreatedOutput(\n    /** Contract ID */\n    contractId: BytesLike,\n    /** State Root */\n    stateRoot: BytesLike\n  ) {\n    this.pushOutput({\n      type: OutputType.ContractCreated,\n      contractId,\n      stateRoot,\n    });\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport type TransactionRequestStorageSlot =\n  | {\n      /** Key */\n      key: BytesLike;\n      /** Value */\n      value: BytesLike;\n    }\n  | [key: BytesLike, value: BytesLike];\n\n// Make sure all values have 32 bytes\nconst getStorageValue = (value: BytesLike): Uint8Array => {\n  const v = new Uint8Array(32);\n  v.set(arrayify(value));\n  return v;\n};\n\nexport const storageSlotify = (storageSlot: TransactionRequestStorageSlot): StorageSlot => {\n  let key;\n  let value;\n\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n\n  return {\n    key: hexlify(key),\n    value: hexlify(getStorageValue(value)),\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { InputValue, JsonAbi } from '@fuel-ts/abi-coder';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport { addressify } from '@fuel-ts/address';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport type { AbstractScriptRequest, ContractIdLike } from '@fuel-ts/interfaces';\nimport type { TransactionScript } from '@fuel-ts/transactions';\nimport { InputType, OutputType, TransactionType } from '@fuel-ts/transactions';\n\nimport type { ContractTransactionRequestInput } from './input';\nimport type { ContractTransactionRequestOutput, VariableTransactionRequestOutput } from './output';\nimport { returnZeroScript } from './scripts';\nimport type { BaseTransactionRequestLike } from './transaction-request';\nimport { BaseTransactionRequest } from './transaction-request';\n\n/**\n * @hidden\n */\nexport interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Script to execute */\n  script?: BytesLike;\n  /** Script input data (parameters) */\n  scriptData?: BytesLike;\n}\n\n/**\n * `ScriptTransactionRequest` provides functionalities for creating a transaction request that uses a script.\n */\nexport class ScriptTransactionRequest extends BaseTransactionRequest {\n  static from(obj: ScriptTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Script as const;\n  /** Script to execute */\n  script: Uint8Array;\n  /** Script input data (parameters) */\n  scriptData: Uint8Array;\n\n  /**\n   * Constructor for `ScriptTransactionRequest`.\n   *\n   * @param scriptTransactionRequestLike - The initial values for the instance.\n   */\n  constructor({ script, scriptData, ...rest }: ScriptTransactionRequestLike = {}) {\n    super(rest);\n    this.script = arrayify(script ?? returnZeroScript.bytes);\n    this.scriptData = arrayify(scriptData ?? returnZeroScript.encodeScriptData());\n  }\n\n  /**\n   * Converts the transaction request to a `TransactionScript`.\n   *\n   * @returns The transaction script object.\n   */\n  toTransaction(): TransactionScript {\n    const script = arrayify(this.script ?? '0x');\n    const scriptData = arrayify(this.scriptData ?? '0x');\n    return {\n      type: TransactionType.Script,\n      ...super.getBaseTransaction(),\n      scriptLength: script.length,\n      scriptDataLength: scriptData.length,\n      receiptsRoot: ZeroBytes32,\n      script: hexlify(script),\n      scriptData: hexlify(scriptData),\n    };\n  }\n\n  /**\n   * Get contract inputs for the transaction.\n   *\n   * @returns An array of contract transaction request inputs.\n   */\n  getContractInputs(): ContractTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is ContractTransactionRequestInput => input.type === InputType.Contract\n    );\n  }\n\n  /**\n   * Get contract outputs for the transaction.\n   *\n   * @returns An array of contract transaction request outputs.\n   */\n  getContractOutputs(): ContractTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractTransactionRequestOutput => output.type === OutputType.Contract\n    );\n  }\n\n  /**\n   * Get variable outputs for the transaction.\n   *\n   * @returns An array of variable transaction request outputs.\n   */\n  getVariableOutputs(): VariableTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is VariableTransactionRequestOutput => output.type === OutputType.Variable\n    );\n  }\n\n  /**\n   * Set the script and its data.\n   *\n   * @param script - The abstract script request.\n   * @param data - The script data.\n   */\n  setScript<T>(script: AbstractScriptRequest<T>, data: T) {\n    this.scriptData = script.encodeScriptData(data);\n    this.script = script.bytes;\n  }\n\n  /**\n   * Adds variable outputs to the transaction request.\n   *\n   * @param numberOfVariables - The number of variables to add.\n   * @returns The new length of the outputs array.\n   */\n  addVariableOutputs(numberOfVariables: number = 1) {\n    let outputsNumber = numberOfVariables;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Variable,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * Adds a contract input and output to the transaction request.\n   *\n   * @param contract - The contract ID.\n   * @returns The current instance of the `ScriptTransactionRequest`.\n   */\n  addContractInputAndOutput(contract: ContractIdLike): ScriptTransactionRequest {\n    const contractAddress = addressify(contract);\n\n    // Add only one input contract per contractId\n    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {\n      return this;\n    }\n\n    const inputIndex = super.pushInput({\n      type: InputType.Contract,\n      contractId: contractAddress.toB256(),\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    this.pushOutput({\n      type: OutputType.Contract,\n      inputIndex,\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets the data for the transaction request.\n   *\n   * @param abi - Script JSON ABI.\n   * @param args - The input arguments.\n   * @returns The current instance of the `ScriptTransactionRequest`.\n   */\n  setData(abi: JsonAbi, args: InputValue[]): ScriptTransactionRequest {\n    const abiInterface = new Interface(abi);\n    this.scriptData = abiInterface.functions.main.encodeArguments(args);\n    return this;\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport type { AbstractScriptRequest } from '@fuel-ts/interfaces';\n\n// We can't import this from `@fuel-ts/script` because it causes\n// cyclic dependency errors so we duplicate it here.\n/** @hidden */\nexport const returnZeroScript: AbstractScriptRequest<void> = {\n  /*\n      Opcode::RET(REG_ZERO)\n      Opcode::NOOP\n    */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x24000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\n/** @hidden */\nexport const withdrawScript: AbstractScriptRequest<void> = {\n  /*\n          The following code loads some basic values into registers and calls SMO to create an output message\n  \n          5040C010 \t- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]\n          5D44C006\t- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]\n          4C400011\t- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]\n          24000000\t- RET                [return 0]\n          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]\n          00000000 00000000 [amount value]\n      */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x5040C0105D44C0064C40001124000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { TransactionType } from '@fuel-ts/transactions';\n\nimport { CreateTransactionRequest } from './create-transaction-request';\nimport { ScriptTransactionRequest } from './script-transaction-request';\nimport type { TransactionRequestLike, TransactionRequest } from './types';\n\n/** @hidden */\nexport const transactionRequestify = (obj: TransactionRequestLike): TransactionRequest => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {\n    return obj;\n  }\n\n  const { type } = obj;\n\n  switch (obj.type) {\n    case TransactionType.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    default: {\n      throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}.`);\n    }\n  }\n};\n","import { arrayify } from '@ethersproject/bytes';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n  ReceiptScriptResult,\n  ReceiptMessageOut,\n  Transaction,\n  ReceiptMint,\n  ReceiptBurn,\n} from '@fuel-ts/transactions';\nimport { TransactionCoder } from '@fuel-ts/transactions';\n\nimport type Provider from '../provider';\nimport { assembleTransactionSummary } from '../transaction-summary/assemble-transaction-summary';\nimport { processGqlReceipt } from '../transaction-summary/receipt';\nimport type {\n  TransactionSummary,\n  FailureStatus,\n  GqlTransaction,\n  AbiMap,\n} from '../transaction-summary/types';\n\n/** @hidden */\nexport type TransactionResultCallReceipt = ReceiptCall;\n/** @hidden */\nexport type TransactionResultReturnReceipt = ReceiptReturn;\n/** @hidden */\nexport type TransactionResultReturnDataReceipt = ReceiptReturnData & { data: string };\n/** @hidden */\nexport type TransactionResultPanicReceipt = ReceiptPanic;\n/** @hidden */\nexport type TransactionResultRevertReceipt = ReceiptRevert;\n/** @hidden */\nexport type TransactionResultLogReceipt = ReceiptLog;\n/** @hidden */\nexport type TransactionResultLogDataReceipt = ReceiptLogData & { data: string };\n/** @hidden */\nexport type TransactionResultTransferReceipt = ReceiptTransfer;\n/** @hidden */\nexport type TransactionResultTransferOutReceipt = ReceiptTransferOut;\n/** @hidden */\nexport type TransactionResultScriptResultReceipt = ReceiptScriptResult;\n/** @hidden */\nexport type TransactionResultMessageOutReceipt = ReceiptMessageOut;\nexport type TransactionResultMintReceipt = ReceiptMint;\nexport type TransactionResultBurnReceipt = ReceiptBurn;\n\n/** @hidden */\nexport type TransactionResultReceipt =\n  | ReceiptCall\n  | ReceiptReturn\n  | (ReceiptReturnData & { data: string })\n  | ReceiptPanic\n  | ReceiptRevert\n  | ReceiptLog\n  | (ReceiptLogData & { data: string })\n  | ReceiptTransfer\n  | ReceiptTransferOut\n  | ReceiptScriptResult\n  | ReceiptMessageOut\n  | TransactionResultMintReceipt\n  | TransactionResultBurnReceipt;\n\n/** @hidden */\nexport type TransactionResult<TTransactionType = void> = TransactionSummary<TTransactionType> & {\n  gqlTransaction: GqlTransaction;\n};\n\n/**\n * Represents a response for a transaction.\n */\nexport class TransactionResponse {\n  /** Transaction ID */\n  id: string;\n  /** Current provider */\n  provider: Provider;\n  /** Gas used on the transaction */\n  gasUsed: BN = bn(0);\n  /** The graphql Transaction with receipts object. */\n  gqlTransaction?: GqlTransaction;\n\n  /**\n   * Constructor for `TransactionResponse`.\n   *\n   * @param id - The transaction ID.\n   * @param provider - The provider.\n   */\n  constructor(id: string, provider: Provider) {\n    this.id = id;\n    this.provider = provider;\n  }\n\n  /**\n   * Async constructor for `TransactionResponse`. This method can be used to create\n   * an instance of `TransactionResponse` and wait for the transaction to be fetched\n   * from the chain, ensuring that the `gqlTransaction` property is set.\n   *\n   * @param id - The transaction ID.\n   * @param provider - The provider.\n   */\n  static async create(id: string, provider: Provider): Promise<TransactionResponse> {\n    const response = new TransactionResponse(id, provider);\n    await response.fetch();\n    return response;\n  }\n\n  /**\n   * Fetch the transaction with receipts from the provider.\n   *\n   * @returns Transaction with receipts query result.\n   */\n  async fetch(): Promise<GqlTransaction> {\n    const response = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id,\n    });\n\n    if (!response.transaction) {\n      for await (const { statusChange } of this.provider.operations.statusChange({\n        transactionId: this.id,\n      })) {\n        if (statusChange) {\n          break;\n        }\n      }\n\n      return this.fetch();\n    }\n\n    this.gqlTransaction = response.transaction;\n\n    return response.transaction;\n  }\n\n  /**\n   * Decode the raw payload of the transaction.\n   *\n   * @param transactionWithReceipts - The transaction with receipts object.\n   * @returns The decoded transaction.\n   */\n  decodeTransaction<TTransactionType = void>(transactionWithReceipts: GqlTransaction) {\n    return new TransactionCoder().decode(\n      arrayify(transactionWithReceipts.rawPayload),\n      0\n    )?.[0] as Transaction<TTransactionType>;\n  }\n\n  /**\n   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will\n   * fetch it from the provider\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   * @returns\n   */\n  async getTransactionSummary<TTransactionType = void>(\n    contractsAbiMap?: AbiMap\n  ): Promise<TransactionSummary<TTransactionType>> {\n    let transaction = this.gqlTransaction;\n\n    if (!transaction) {\n      transaction = await this.fetch();\n    }\n\n    const decodedTransaction = this.decodeTransaction<TTransactionType>(\n      transaction\n    ) as Transaction<TTransactionType>;\n\n    const receipts = transaction.receipts?.map(processGqlReceipt) || [];\n\n    const { gasPerByte, gasPriceFactor } = this.provider.getGasConfig();\n\n    const transactionSummary = assembleTransactionSummary<TTransactionType>({\n      id: this.id,\n      receipts,\n      transaction: decodedTransaction,\n      transactionBytes: arrayify(transaction.rawPayload),\n      gqlTransactionStatus: transaction.status,\n      gasPerByte: bn(gasPerByte),\n      gasPriceFactor: bn(gasPriceFactor),\n      abiMap: contractsAbiMap,\n    });\n\n    return transactionSummary;\n  }\n\n  /**\n   * Waits for transaction to complete and returns the result.\n   *\n   * @returns The completed transaction result\n   */\n  async waitForResult<TTransactionType = void>(\n    contractsAbiMap?: AbiMap\n  ): Promise<TransactionResult<TTransactionType>> {\n    for await (const { statusChange } of this.provider.operations.statusChange({\n      transactionId: this.id,\n    })) {\n      if (statusChange.__typename !== 'SubmittedStatus') break;\n    }\n\n    const transactionSummary = await this.getTransactionSummary<TTransactionType>(contractsAbiMap);\n\n    const transactionResult: TransactionResult<TTransactionType> = {\n      gqlTransaction: this.gqlTransaction as GqlTransaction,\n      ...transactionSummary,\n    };\n\n    return transactionResult;\n  }\n\n  /**\n   * Waits for transaction to complete and returns the result.\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   */\n  async wait<TTransactionType = void>(\n    contractsAbiMap?: AbiMap\n  ): Promise<TransactionResult<TTransactionType>> {\n    const result = await this.waitForResult<TTransactionType>(contractsAbiMap);\n\n    if (result.isStatusFailure) {\n      throw new FuelError(\n        ErrorCode.TRANSACTION_FAILED,\n        `Transaction failed: ${(<FailureStatus>result.gqlTransaction.status).reason}`\n      );\n    }\n\n    return result;\n  }\n}\n","import { hexlify } from '@ethersproject/bytes';\nimport { bn, type BN } from '@fuel-ts/math';\nimport { type Transaction } from '@fuel-ts/transactions';\n\nimport type { TransactionResultReceipt } from '../transaction-response';\nimport { calculateTransactionFee } from '../utils';\n\nimport { fromTai64ToDate } from './date';\nimport {\n  getOperations,\n  getTransactionTypeName,\n  isTypeMint,\n  isTypeCreate,\n  isTypeScript,\n} from './operations';\nimport { extractBurnedAssetsFromReceipts, extractMintedAssetsFromReceipts } from './receipt';\nimport { processGraphqlStatus } from './status';\nimport type { AbiMap, GraphqlTransactionStatus, TransactionSummary } from './types';\n\nexport interface AssembleTransactionSummaryParams {\n  id?: string;\n  gasPerByte?: BN;\n  gasPriceFactor: BN;\n  transaction: Transaction;\n  transactionBytes: Uint8Array;\n  gqlTransactionStatus?: GraphqlTransactionStatus;\n  receipts: TransactionResultReceipt[];\n  abiMap?: AbiMap;\n}\n\n/** @hidden */\nexport function assembleTransactionSummary<TTransactionType = void>(\n  params: AssembleTransactionSummaryParams\n) {\n  const {\n    receipts,\n    gasPerByte,\n    gasPriceFactor,\n    transaction,\n    transactionBytes,\n    id,\n    gqlTransactionStatus,\n    abiMap = {},\n  } = params;\n\n  const gasPrice = bn(transaction.gasPrice);\n\n  const { gasUsed, fee } = calculateTransactionFee({\n    receipts,\n    gasPrice,\n    transactionBytes,\n    transactionWitnesses: transaction?.witnesses || [],\n    gasPerByte,\n    gasPriceFactor,\n    transactionType: transaction.type,\n  });\n\n  const operations = getOperations({\n    transactionType: transaction.type,\n    inputs: transaction.inputs || [],\n    outputs: transaction.outputs || [],\n    receipts,\n    rawPayload: hexlify(transactionBytes),\n    abiMap,\n  });\n\n  const typeName = getTransactionTypeName(transaction.type);\n\n  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } =\n    processGraphqlStatus(gqlTransactionStatus);\n\n  const mintedAssets = extractMintedAssetsFromReceipts(receipts);\n  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);\n\n  let date: Date | undefined;\n\n  if (time) {\n    date = fromTai64ToDate(time);\n  }\n\n  const transactionSummary: TransactionSummary<TTransactionType> = {\n    id,\n    fee,\n    gasUsed,\n    operations,\n    type: typeName,\n    blockId,\n    time,\n    status,\n    receipts,\n    mintedAssets,\n    burnedAssets,\n    isTypeMint: isTypeMint(transaction.type),\n    isTypeCreate: isTypeCreate(transaction.type),\n    isTypeScript: isTypeScript(transaction.type),\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n    date,\n    transaction: transaction as Transaction<TTransactionType>,\n  };\n\n  return transactionSummary;\n}\n","import { TAI64 } from 'tai64';\n\nexport const fromTai64ToDate = (tai64Timestamp: string) => {\n  const timestamp = TAI64.fromString(tai64Timestamp, 10).toUnix();\n  return new Date(timestamp * 1000);\n};\n\nexport const fromDateToTai64 = (date: Date) =>\n  TAI64.fromUnix(Math.floor(date.getTime() / 1000)).toString(10);\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { ReceiptType, type Output, TransactionType } from '@fuel-ts/transactions';\n\nimport type {\n  TransactionResultCallReceipt,\n  TransactionResultMessageOutReceipt,\n  TransactionResultReceipt,\n  TransactionResultTransferOutReceipt,\n} from '../transaction-response';\n\nimport { getFunctionCall } from './call';\nimport {\n  getInputFromAssetId,\n  getInputAccountAddress,\n  getInputContractFromIndex,\n  getInputsCoin,\n} from './input';\nimport { getOutputsCoin, getOutputsContract, getOutputsContractCreated } from './output';\nimport type {\n  InputOutputParam,\n  InputParam,\n  OperationCoin,\n  RawPayloadParam,\n  ReceiptParam,\n} from './types';\nimport {\n  type Operation,\n  type GetOperationParams,\n  AddressType,\n  ChainName,\n  OperationName,\n  TransactionTypeName,\n} from './types';\n\n/** @hidden */\nexport function getReceiptsByType<T = TransactionResultReceipt>(\n  receipts: TransactionResultReceipt[],\n  type: ReceiptType\n) {\n  return (receipts ?? []).filter((r) => r.type === type) as T[];\n}\n\n/** @hidden */\nexport function getTransactionTypeName(transactionType: TransactionType): TransactionTypeName {\n  switch (transactionType) {\n    case TransactionType.Mint:\n      return TransactionTypeName.Mint;\n    case TransactionType.Create:\n      return TransactionTypeName.Create;\n    case TransactionType.Script:\n      return TransactionTypeName.Script;\n    default:\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_TYPE,\n        `Invalid transaction type: ${transactionType}.`\n      );\n  }\n}\n\n/** @hidden */\nexport function isType(transactionType: TransactionType, type: TransactionTypeName) {\n  const txType = getTransactionTypeName(transactionType);\n\n  return txType === type;\n}\n\n/** @hidden */\nexport function isTypeMint(transactionType: TransactionType) {\n  return isType(transactionType, TransactionTypeName.Mint);\n}\n\n/** @hidden */\nexport function isTypeCreate(transactionType: TransactionType) {\n  return isType(transactionType, TransactionTypeName.Create);\n}\n\n/** @hidden */\nexport function isTypeScript(transactionType: TransactionType) {\n  return isType(transactionType, TransactionTypeName.Script);\n}\n\n/** @hidden */\nexport function hasSameAssetId(a: OperationCoin) {\n  return (b: OperationCoin) => a.assetId === b.assetId;\n}\n\n/** @hidden */\nexport function getReceiptsCall(receipts: TransactionResultReceipt[]) {\n  return getReceiptsByType<TransactionResultCallReceipt>(receipts, ReceiptType.Call);\n}\n\n/** @hidden */\nexport function getReceiptsMessageOut(receipts: TransactionResultReceipt[]) {\n  return getReceiptsByType<TransactionResultMessageOutReceipt>(receipts, ReceiptType.MessageOut);\n}\n\n/** @hidden */\nconst mergeAssets = (op1: Operation, op2: Operation) => {\n  const assets1 = op1.assetsSent || [];\n  const assets2 = op2.assetsSent || [];\n  const filtered = assets2.filter((c) => !assets1.some(hasSameAssetId(c)));\n  return assets1\n    .map((coin) => {\n      const asset = assets2.find(hasSameAssetId(coin));\n      if (!asset) return coin;\n      return { ...coin, amount: bn(coin.amount).add(asset.amount) };\n    })\n    .concat(filtered);\n};\n\n/** @hidden */\nfunction isSameOperation(a: Operation, b: Operation) {\n  return (\n    a.name === b.name &&\n    a.from?.address === b.from?.address &&\n    a.to?.address === b.to?.address &&\n    a.from?.type === b.from?.type &&\n    a.to?.type === b.to?.type\n  );\n}\n\n/** @hidden */\nexport function addOperation(operations: Operation[], toAdd: Operation) {\n  const ops = operations\n    .map((op) => {\n      // if it's not same operation, don't change. we just wanna stack the same operation\n      if (!isSameOperation(op, toAdd)) return null;\n\n      let newOp = { ...op };\n\n      // if it's adding new assets\n      if (toAdd.assetsSent?.length) {\n        // if prev op had assets, merge them. Otherwise just add the new assets\n        newOp = {\n          ...newOp,\n          assetsSent: op.assetsSent?.length ? mergeAssets(op, toAdd) : toAdd.assetsSent,\n        };\n      }\n\n      // if it's adding new calls,\n      if (toAdd.calls?.length) {\n        /*\n[]          for calls we don't stack as grouping is not desired.\n          we wanna show all calls in the same operation\n          with each respective assets, amounts, functions, arguments.\n        */\n        newOp = {\n          ...newOp,\n          calls: [...(op.calls || []), ...(toAdd.calls || [])],\n        };\n      }\n\n      return newOp;\n    })\n    .filter(Boolean) as Operation[];\n\n  // if this operation didn't exist before just add it to the end\n  return ops.length ? ops : [...operations, toAdd];\n}\n\n/** @hidden */\nexport function getReceiptsTransferOut(receipts: TransactionResultReceipt[]) {\n  return getReceiptsByType<TransactionResultTransferOutReceipt>(receipts, ReceiptType.TransferOut);\n}\n\n/** @hidden */\nexport function getContractTransferOperations({ receipts }: ReceiptParam): Operation[] {\n  const transferOutReceipts = getReceiptsTransferOut(receipts);\n\n  const contractTransferOperations = transferOutReceipts.reduce(\n    (prevContractTransferOps, receipt) => {\n      const newContractTransferOps = addOperation(prevContractTransferOps, {\n        name: OperationName.contractTransfer,\n        from: {\n          type: AddressType.contract,\n          address: receipt.from,\n        },\n        to: {\n          type: AddressType.account,\n          address: receipt.to,\n        },\n        assetsSent: [\n          {\n            amount: receipt.amount,\n            assetId: receipt.assetId,\n          },\n        ],\n      });\n\n      return newContractTransferOps;\n    },\n    [] as Operation[]\n  );\n\n  return contractTransferOperations;\n}\n\n/** @hidden */\nexport function getWithdrawFromFuelOperations({\n  inputs,\n  receipts,\n}: InputParam & ReceiptParam): Operation[] {\n  const messageOutReceipts = getReceiptsMessageOut(receipts);\n\n  const withdrawFromFuelOperations = messageOutReceipts.reduce(\n    (prevWithdrawFromFuelOps, receipt) => {\n      // TODO: replace this hardcode with receipt.assetId when assetId gets added to MessageOutReceipt\n      const assetId = '0x0000000000000000000000000000000000000000000000000000000000000000';\n      const input = getInputFromAssetId(inputs, assetId);\n      if (input) {\n        const inputAddress = getInputAccountAddress(input);\n        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {\n          name: OperationName.withdrawFromFuel,\n          from: {\n            type: AddressType.account,\n            address: inputAddress,\n          },\n          to: {\n            type: AddressType.account,\n            address: receipt.recipient.toString(),\n            chain: ChainName.ethereum,\n          },\n          assetsSent: [\n            {\n              amount: receipt.amount,\n              assetId,\n            },\n          ],\n        });\n\n        return newWithdrawFromFuelOps;\n      }\n\n      return prevWithdrawFromFuelOps;\n    },\n    [] as Operation[]\n  );\n\n  return withdrawFromFuelOperations;\n}\n\n/** @hidden */\nexport function getContractCallOperations({\n  inputs,\n  outputs,\n  receipts,\n  abiMap,\n  rawPayload,\n}: InputOutputParam &\n  ReceiptParam &\n  Pick<GetOperationParams, 'abiMap'> &\n  RawPayloadParam): Operation[] {\n  const contractCallReceipts = getReceiptsCall(receipts);\n  const contractOutputs = getOutputsContract(outputs);\n\n  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output) => {\n    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);\n\n    if (contractInput) {\n      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {\n        if (receipt.to === contractInput.contractID) {\n          const input = getInputFromAssetId(inputs, receipt.assetId);\n          if (input) {\n            const inputAddress = getInputAccountAddress(input);\n            const calls = [];\n\n            const abi = abiMap?.[contractInput.contractID];\n            if (abi) {\n              calls.push(\n                getFunctionCall({\n                  abi,\n                  receipt,\n                  rawPayload,\n                })\n              );\n            }\n\n            const newContractCallOps = addOperation(prevContractCallOps, {\n              name: OperationName.contractCall,\n              from: {\n                type: AddressType.account,\n                address: inputAddress,\n              },\n              to: {\n                type: AddressType.contract,\n                address: receipt.to,\n              },\n              // if no amount is forwarded to the contract, skip showing assetsSent\n              assetsSent: receipt.amount?.isZero()\n                ? undefined\n                : [\n                    {\n                      amount: receipt.amount,\n                      assetId: receipt.assetId,\n                    },\n                  ],\n              calls,\n            });\n\n            return newContractCallOps;\n          }\n        }\n        return prevContractCallOps;\n      }, prevOutputCallOps as Operation[]);\n\n      return newCallOps;\n    }\n\n    return prevOutputCallOps;\n  }, [] as Operation[]);\n\n  return contractCallOperations;\n}\n\n/** @hidden */\nexport function getTransferOperations({ inputs, outputs }: InputOutputParam): Operation[] {\n  const coinOutputs = getOutputsCoin(outputs);\n\n  let operations: Operation[] = [];\n  coinOutputs.forEach((output) => {\n    const input = getInputFromAssetId(inputs, output.assetId);\n\n    if (input) {\n      const inputAddress = getInputAccountAddress(input);\n      operations = addOperation(operations, {\n        name: OperationName.transfer,\n        from: {\n          type: AddressType.account,\n          address: inputAddress,\n        },\n        to: {\n          type: AddressType.account,\n          address: output.to.toString(),\n        },\n        assetsSent: [\n          {\n            assetId: output.assetId.toString(),\n            amount: output.amount,\n          },\n        ],\n      });\n    }\n  });\n\n  return operations;\n}\n\n/** @hidden */\nexport function getPayProducerOperations(outputs: Output[]): Operation[] {\n  const coinOutputs = getOutputsCoin(outputs);\n  const payProducerOperations = coinOutputs.reduce((prev, output) => {\n    const operations = addOperation(prev, {\n      name: OperationName.payBlockProducer,\n      from: {\n        type: AddressType.account,\n        address: 'Network',\n      },\n      to: {\n        type: AddressType.account,\n        address: output.to.toString(),\n      },\n      assetsSent: [\n        {\n          assetId: output.assetId.toString(),\n          amount: output.amount,\n        },\n      ],\n    });\n\n    return operations;\n  }, [] as Operation[]);\n\n  return payProducerOperations;\n}\n\n/** @hidden */\nexport function getContractCreatedOperations({ inputs, outputs }: InputOutputParam): Operation[] {\n  const contractCreatedOutputs = getOutputsContractCreated(outputs);\n  const input = getInputsCoin(inputs)[0];\n  const fromAddress = getInputAccountAddress(input);\n  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {\n    const operations = addOperation(prev, {\n      name: OperationName.contractCreated,\n      from: {\n        type: AddressType.account,\n        address: fromAddress,\n      },\n      to: {\n        type: AddressType.contract,\n        address: contractCreatedOutput?.contractId || '',\n      },\n    });\n\n    return operations;\n  }, [] as Operation[]);\n\n  return contractCreatedOperations;\n}\n\n/** @hidden */\nexport function getOperations({\n  transactionType,\n  inputs,\n  outputs,\n  receipts,\n  abiMap,\n  rawPayload,\n}: GetOperationParams): Operation[] {\n  if (isTypeCreate(transactionType)) {\n    return [\n      ...getContractCreatedOperations({ inputs, outputs }),\n      ...getTransferOperations({ inputs, outputs }),\n    ];\n  }\n\n  if (isTypeScript(transactionType)) {\n    return [\n      ...getTransferOperations({ inputs, outputs }),\n      ...getContractCallOperations({\n        inputs,\n        outputs,\n        receipts,\n        abiMap,\n        rawPayload,\n      }),\n      ...getContractTransferOperations({ receipts }),\n      ...getWithdrawFromFuelOperations({ inputs, receipts }),\n    ];\n  }\n  // at this point we are sure it's a mint transaction\n  return [...getPayProducerOperations(outputs)];\n}\n","import { Interface, VM_TX_MEMORY, type JsonAbi } from '@fuel-ts/abi-coder';\nimport { bn } from '@fuel-ts/math';\nimport type { ReceiptCall } from '@fuel-ts/transactions';\n\ntype GetFunctionCallProps = {\n  abi: JsonAbi;\n  receipt: ReceiptCall;\n  rawPayload?: string;\n};\n\nexport const getFunctionCall = ({ abi, receipt, rawPayload }: GetFunctionCallProps) => {\n  const abiInterface = new Interface(abi);\n  const callFunctionSelector = receipt.param1.toHex(8);\n  const functionFragment = abiInterface.getFunction(callFunctionSelector);\n  const inputs = functionFragment.jsonFn.inputs;\n\n  let encodedArgs;\n\n  // if has more than 1 input or input type is bigger than 8 bytes, then it's a pointer to data\n  if (functionFragment.isInputDataPointer) {\n    if (rawPayload) {\n      // calculate offset to get function params from rawPayload. should also consider vm offset: VM_TX_MEMORY\n      const argsOffset = bn(receipt.param2).sub(VM_TX_MEMORY).toNumber();\n\n      // slice(2) to remove first 0x, then slice again to remove offset and get only args\n      encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;\n    }\n  } else {\n    // for small inputs, param2 is directly the value\n    encodedArgs = receipt.param2.toHex();\n  }\n\n  let argumentsProvided;\n  if (encodedArgs) {\n    // use bytes got from rawPayload to decode function params\n    const data = functionFragment.decodeArguments(encodedArgs);\n    if (data) {\n      // put together decoded data with input names from abi\n      argumentsProvided = inputs.reduce((prev, input, index) => {\n        const value = data[index];\n        const name = input.name;\n\n        if (name) {\n          return {\n            ...prev,\n            // reparse to remove bn\n            [name]: JSON.parse(JSON.stringify(value)),\n          };\n        }\n\n        return prev;\n      }, {});\n    }\n  }\n\n  const call = {\n    functionSignature: functionFragment.signature,\n    functionName: functionFragment.name,\n    argumentsProvided,\n    ...(receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }),\n  };\n\n  return call;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { Input, InputCoin, InputContract, InputMessage } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\n/** @hidden */\nexport function getInputsByType<T = Input>(inputs: Input[], type: InputType) {\n  return inputs.filter((i) => i.type === type) as T[];\n}\n\n/** @hidden */\nexport function getInputsCoin(inputs: Input[]) {\n  return getInputsByType<InputCoin>(inputs, InputType.Coin);\n}\n\n/** @hidden */\nexport function getInputsMessage(inputs: Input[]) {\n  return getInputsByType<InputMessage>(inputs, InputType.Message);\n}\n\n/** @hidden */\nexport function getInputsContract(inputs: Input[]) {\n  return getInputsByType<InputContract>(inputs, InputType.Contract);\n}\n\n/** @hidden */\nexport function getInputFromAssetId(inputs: Input[], assetId: string) {\n  const coinInputs = getInputsCoin(inputs);\n  const messageInputs = getInputsMessage(inputs);\n  const coinInput = coinInputs.find((i) => i.assetId === assetId);\n  // TODO: should include assetId in InputMessage as well. for now we're mocking ETH\n  const messageInput = messageInputs.find(\n    (_) => assetId === '0x0000000000000000000000000000000000000000000000000000000000000000'\n  );\n\n  return coinInput || messageInput;\n}\n\n/** @hidden */\nexport function getInputContractFromIndex(\n  inputs: Input[],\n  inputIndex: number\n): InputContract | undefined {\n  if (inputIndex == null) return undefined;\n\n  const contractInput = inputs?.[inputIndex];\n\n  if (!contractInput) return undefined;\n  if (contractInput.type !== InputType.Contract) {\n    throw new FuelError(\n      ErrorCode.INVALID_TRANSACTION_INPUT,\n      `Contract input should be of type 'contract'.`\n    );\n  }\n\n  return contractInput as InputContract;\n}\n\n/** @hidden */\nexport function getInputAccountAddress(input: Input) {\n  if (input.type === InputType.Coin) {\n    return input.owner.toString();\n  }\n\n  if (input.type === InputType.Message) {\n    return input.recipient.toString();\n  }\n\n  return '';\n}\n","import type {\n  Output,\n  OutputCoin,\n  OutputContract,\n  OutputContractCreated,\n  OutputVariable,\n} from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\n/** @hidden */\nexport function getOutputsByType<T = Output>(outputs: Output[], type: OutputType) {\n  return outputs.filter((o) => o.type === type) as T[];\n}\n\n/** @hidden */\nexport function getOutputsContractCreated(outputs: Output[]) {\n  return getOutputsByType<OutputContractCreated>(outputs, OutputType.ContractCreated);\n}\n\n/** @hidden */\nexport function getOutputsCoin(outputs: Output[]) {\n  return getOutputsByType<OutputCoin>(outputs, OutputType.Coin);\n}\n\n/** @hidden */\nexport function getOutputsChange(outputs: Output[]) {\n  return getOutputsByType<OutputCoin>(outputs, OutputType.Change);\n}\n\n/** @hidden */\nexport function getOutputsContract(outputs: Output[]) {\n  return getOutputsByType<OutputContract>(outputs, OutputType.Contract);\n}\n\n/** @hidden */\nexport function getOutputsVariable(outputs: Output[]) {\n  return getOutputsByType<OutputVariable>(outputs, OutputType.Variable);\n}\n","import type { JsonAbi } from '@fuel-ts/abi-coder';\nimport type { B256Address } from '@fuel-ts/interfaces';\nimport type { BN, BNInput } from '@fuel-ts/math';\nimport type { Input, Output, Transaction, TransactionType } from '@fuel-ts/transactions';\n\nimport type { GqlGetTransactionQuery } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\n\nexport type GqlTransaction = NonNullable<GqlGetTransactionQuery['transaction']>;\n\nexport type GraphqlTransactionStatus = GqlTransaction['status'];\n\nexport type SuccessStatus = Extract<GraphqlTransactionStatus, { __typename: 'SuccessStatus' }>;\nexport type FailureStatus = Extract<GraphqlTransactionStatus, { __typename: 'FailureStatus' }>;\nexport type SubmittedStatus = Extract<GraphqlTransactionStatus, { __typename: 'SubmittedStatus' }>;\nexport type SqueezedOutStatus = Extract<\n  GraphqlTransactionStatus,\n  { __typename: 'SqueezedOutStatus' }\n>;\n\nexport type Reason = FailureStatus['reason'];\nexport type ProgramState = SuccessStatus['programState'];\nexport type Time = SubmittedStatus['time'] | SuccessStatus['time'] | FailureStatus['time'];\nexport type BlockId = SuccessStatus['block']['id'] | FailureStatus['block']['id'];\n\n/**\n * @hidden\n */\nexport enum TransactionTypeName {\n  Create = 'Create',\n  Mint = 'Mint',\n  Script = 'Script',\n}\n\n/**\n * @hidden\n */\nexport enum TransactionStatus {\n  submitted = 'submitted',\n  success = 'success',\n  squeezedout = 'squeezedout',\n  failure = 'failure',\n}\n\n/**\n * @hidden\n */\nexport type GqlTransactionStatusesNames =\n  | 'FailureStatus'\n  | 'SubmittedStatus'\n  | 'SuccessStatus'\n  | 'SqueezedOutStatus';\n\n/**\n * @hidden\n */\nexport enum OperationName {\n  payBlockProducer = 'Pay network fee to block producer',\n  contractCreated = 'Contract created',\n  transfer = 'Transfer asset',\n  contractCall = 'Contract call',\n  contractTransfer = 'Contract transfer',\n  receive = 'Receive asset',\n  mint = 'Mint asset',\n  predicatecall = 'Predicate call',\n  script = 'Script',\n  sent = 'Sent asset',\n  withdrawFromFuel = 'Withdraw from Fuel',\n}\n\nexport type OperationCoin = {\n  assetId: string;\n  amount: BNInput;\n};\n\nexport type OperationFunctionCall = {\n  functionSignature: string;\n  functionName: string;\n  argumentsProvided?: Record<string, unknown>;\n} & Partial<OperationCoin>;\n\nexport type Operation = {\n  name?: OperationName;\n  from?: OperationTransactionAddress;\n  to?: OperationTransactionAddress;\n  assetsSent?: Array<OperationCoin>;\n  calls?: Array<OperationFunctionCall>;\n};\n\n/**\n * @hidden\n */\nexport enum AddressType {\n  contract,\n  account,\n}\n\n/**\n * @hidden\n */\nexport enum ChainName {\n  ethereum = 'ethereum',\n  fuel = 'fuel',\n}\n\nexport type OperationTransactionAddress = {\n  address: string;\n  type: AddressType;\n  chain?: ChainName;\n};\n\nexport type InputParam = {\n  inputs: Input[];\n};\n\nexport type OutputParam = {\n  outputs: Output[];\n};\n\nexport type ReceiptParam = {\n  receipts: TransactionResultReceipt[];\n};\n\nexport type AbiMap = Record<string, JsonAbi>;\n\nexport type RawPayloadParam = {\n  rawPayload?: string;\n};\n\nexport type InputOutputParam = InputParam & OutputParam;\n\nexport type GetOperationParams = {\n  transactionType: TransactionType;\n  abiMap?: AbiMap;\n} & InputOutputParam &\n  ReceiptParam &\n  RawPayloadParam;\n\nexport interface MintedAsset {\n  subId: B256Address;\n  contractId: B256Address;\n  assetId: B256Address;\n  amount: BN;\n}\n\nexport type BurnedAsset = MintedAsset;\n\nexport type TransactionSummary<TTransactionType = void> = {\n  id?: string;\n  time?: string;\n  operations: Operation[];\n  gasUsed: BN;\n  fee: BN;\n  type: TransactionTypeName;\n  blockId?: BlockId;\n  status?: TransactionStatus;\n  isTypeMint: boolean;\n  isTypeCreate: boolean;\n  isTypeScript: boolean;\n  isStatusPending: boolean;\n  isStatusSuccess: boolean;\n  isStatusFailure: boolean;\n  mintedAssets: MintedAsset[];\n  burnedAssets: BurnedAsset[];\n  date?: Date;\n  receipts: TransactionResultReceipt[];\n  transaction: Transaction<TTransactionType>;\n};\n","import { ReceiptType } from '@fuel-ts/transactions';\n\nimport type { GqlReceipt } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\nimport { assembleReceiptByType } from '../utils';\n\nimport type { BurnedAsset, MintedAsset } from './types';\n\nexport const processGqlReceipt = (gqlReceipt: GqlReceipt): TransactionResultReceipt => {\n  const receipt = assembleReceiptByType(gqlReceipt);\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data || '0x',\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data || '0x',\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nexport const extractMintedAssetsFromReceipts = (\n  receipts: Array<TransactionResultReceipt>\n): MintedAsset[] => {\n  const mintedAssets: MintedAsset[] = [];\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.Mint) {\n      mintedAssets.push({\n        subId: receipt.subId,\n        contractId: receipt.contractId,\n        assetId: receipt.assetId,\n        amount: receipt.val,\n      });\n    }\n  });\n\n  return mintedAssets;\n};\n\nexport const extractBurnedAssetsFromReceipts = (\n  receipts: Array<TransactionResultReceipt>\n): BurnedAsset[] => {\n  const burnedAssets: BurnedAsset[] = [];\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.Burn) {\n      burnedAssets.push({\n        subId: receipt.subId,\n        contractId: receipt.contractId,\n        assetId: receipt.assetId,\n        amount: receipt.val,\n      });\n    }\n  });\n\n  return burnedAssets;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type {\n  BlockId,\n  GqlTransactionStatusesNames,\n  GraphqlTransactionStatus,\n  Time,\n  TransactionSummary,\n} from './types';\nimport { TransactionStatus } from './types';\n\n/** @hidden */\nexport const getTransactionStatusName = (gqlStatus: GqlTransactionStatusesNames) => {\n  switch (gqlStatus) {\n    case 'FailureStatus':\n      return TransactionStatus.failure;\n    case 'SuccessStatus':\n      return TransactionStatus.success;\n    case 'SubmittedStatus':\n      return TransactionStatus.submitted;\n    case 'SqueezedOutStatus':\n      return TransactionStatus.squeezedout;\n    default:\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_STATUS,\n        `Invalid transaction status: ${gqlStatus}.`\n      );\n  }\n};\n\ntype IProcessGraphqlStatusResponse = Pick<\n  TransactionSummary,\n  'time' | 'blockId' | 'isStatusPending' | 'isStatusSuccess' | 'isStatusFailure' | 'status'\n>;\n\n/** @hidden */\nexport const processGraphqlStatus = (gqlTransactionStatus?: GraphqlTransactionStatus) => {\n  let time: Time;\n  let blockId: BlockId | undefined;\n  let status: TransactionStatus | undefined;\n\n  let isStatusFailure = false;\n  let isStatusSuccess = false;\n  let isStatusPending = false;\n\n  if (gqlTransactionStatus?.type) {\n    status = getTransactionStatusName(gqlTransactionStatus.type);\n\n    switch (gqlTransactionStatus.type) {\n      case 'SuccessStatus':\n        time = gqlTransactionStatus.time;\n        blockId = gqlTransactionStatus.block.id;\n        isStatusSuccess = true;\n        break;\n\n      case 'FailureStatus':\n        time = gqlTransactionStatus.time;\n        blockId = gqlTransactionStatus.block.id;\n        isStatusFailure = true;\n        break;\n\n      case 'SubmittedStatus':\n        time = gqlTransactionStatus.time;\n        isStatusPending = true;\n        break;\n      default:\n    }\n  }\n\n  const processedGraphqlStatus: IProcessGraphqlStatusResponse = {\n    time,\n    blockId,\n    status,\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n  };\n\n  return processedGraphqlStatus;\n};\n","import type { Interface } from '@fuel-ts/abi-coder';\nimport { U64Coder } from '@fuel-ts/abi-coder';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport type { TransactionResultReceipt } from './transaction-response';\n\n/** @hidden */\nexport function getDecodedLogs<T = unknown>(\n  receipts: Array<TransactionResultReceipt>,\n  abiInterface: Interface\n): T[] {\n  return receipts.reduce((logs: T[], r) => {\n    if (r.type === ReceiptType.LogData) {\n      logs.push(abiInterface.decodeLog(r.data, r.val1.toNumber(), r.id)[0]);\n    }\n\n    if (r.type === ReceiptType.Log) {\n      logs.push(abiInterface.decodeLog(new U64Coder().encode(r.val0), r.val1.toNumber(), r.id)[0]);\n    }\n\n    return logs;\n  }, []);\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { TransactionCoder } from '@fuel-ts/transactions';\n\nimport type {\n  GqlGetTransactionsByOwnerQueryVariables,\n  GqlPageInfo,\n} from '../__generated__/operations';\nimport type Provider from '../provider';\nimport type { TransactionRequest } from '../transaction-request';\nimport type { TransactionResult } from '../transaction-response';\n\nimport { assembleTransactionSummary } from './assemble-transaction-summary';\nimport { processGqlReceipt } from './receipt';\nimport type { AbiMap, TransactionSummary } from './types';\n\n/** @hidden */\nexport interface GetTransactionSummaryParams {\n  id: string;\n  provider: Provider;\n  abiMap?: AbiMap;\n}\n\nexport async function getTransactionSummary<TTransactionType = void>(\n  params: GetTransactionSummaryParams\n): Promise<TransactionResult> {\n  const { id, provider, abiMap } = params;\n\n  const { transaction: gqlTransaction } = await provider.operations.getTransactionWithReceipts({\n    transactionId: id,\n  });\n\n  if (!gqlTransaction) {\n    throw new FuelError(\n      ErrorCode.TRANSACTION_NOT_FOUND,\n      `Transaction not found for given id: ${id}.`\n    );\n  }\n\n  const [decodedTransaction] = new TransactionCoder().decode(\n    arrayify(gqlTransaction.rawPayload),\n    0\n  );\n\n  const receipts = gqlTransaction.receipts?.map(processGqlReceipt) || [];\n\n  const {\n    consensusParameters: { gasPerByte, gasPriceFactor },\n  } = await provider.getChain();\n\n  const transactionInfo = assembleTransactionSummary<TTransactionType>({\n    id: gqlTransaction.id,\n    receipts,\n    transaction: decodedTransaction,\n    transactionBytes: arrayify(gqlTransaction.rawPayload),\n    gqlTransactionStatus: gqlTransaction.status,\n    gasPerByte: bn(gasPerByte),\n    gasPriceFactor: bn(gasPriceFactor),\n    abiMap,\n  });\n\n  return {\n    gqlTransaction,\n    ...transactionInfo,\n  };\n}\n\nexport interface GetTransactionSummaryFromRequestParams {\n  transactionRequest: TransactionRequest;\n  provider: Provider;\n  abiMap?: AbiMap;\n}\n\n/** @hidden */\nexport async function getTransactionSummaryFromRequest<TTransactionType = void>(\n  params: GetTransactionSummaryFromRequestParams\n): Promise<TransactionSummary<TTransactionType>> {\n  const { provider, transactionRequest, abiMap } = params;\n\n  const { receipts } = await provider.call(transactionRequest);\n\n  const { gasPerByte, gasPriceFactor } = provider.getGasConfig();\n\n  const transaction = transactionRequest.toTransaction();\n  const transactionBytes = transactionRequest.toTransactionBytes();\n\n  const transactionSummary = assembleTransactionSummary<TTransactionType>({\n    receipts,\n    transaction,\n    transactionBytes,\n    abiMap,\n    gasPerByte,\n    gasPriceFactor,\n  });\n\n  return transactionSummary;\n}\n\nexport interface GetTransactionsSummariesParams {\n  provider: Provider;\n  filters: GqlGetTransactionsByOwnerQueryVariables;\n  abiMap?: AbiMap;\n}\n\nexport interface GetTransactionsSummariesReturns {\n  transactions: TransactionResult[];\n  pageInfo: GqlPageInfo;\n}\n\n/** @hidden */\nexport async function getTransactionsSummaries(\n  params: GetTransactionsSummariesParams\n): Promise<GetTransactionsSummariesReturns> {\n  const { filters, provider, abiMap } = params;\n\n  const { transactionsByOwner } = await provider.operations.getTransactionsByOwner(filters);\n\n  const { edges, pageInfo } = transactionsByOwner;\n\n  const {\n    consensusParameters: { gasPerByte, gasPriceFactor },\n  } = await provider.getChain();\n\n  const transactions = edges.map((edge) => {\n    const { node: gqlTransaction } = edge;\n\n    const { id, rawPayload, receipts: gqlReceipts, status } = gqlTransaction;\n\n    const [decodedTransaction] = new TransactionCoder().decode(arrayify(rawPayload), 0);\n\n    const receipts = gqlReceipts?.map(processGqlReceipt) || [];\n\n    const transactionSummary = assembleTransactionSummary({\n      id,\n      receipts,\n      transaction: decodedTransaction,\n      transactionBytes: arrayify(rawPayload),\n      gqlTransactionStatus: status,\n      abiMap,\n      gasPerByte,\n      gasPriceFactor,\n    });\n\n    const output: TransactionResult = {\n      gqlTransaction,\n      ...transactionSummary,\n    };\n\n    return output;\n  });\n\n  return {\n    transactions,\n    pageInfo,\n  };\n}\n"],"mappings":"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","names":["max","import_bytes","import_address","import_errors","import_math","import_transactions","import_ramda","gql","import_bytes","import_bytes","import_configs","import_errors","import_math","import_bytes","import_configs","import_errors","import_math","import_transactions","import_bytes","import_configs","import_math","import_transactions","import_bytes","import_configs","import_errors","import_math","import_transactions","import_math","import_transactions","isTypeCreate","import_errors","import_bytes","import_bytes","import_bytes","import_configs","import_transactions","import_bytes","import_bytes","import_address","import_configs","import_transactions","import_bytes","import_errors","import_transactions","import_bytes","import_errors","import_math","import_transactions","import_bytes","import_math","import_errors","import_math","import_transactions","import_abi_coder","import_math","import_errors","import_transactions","import_transactions","TransactionTypeName","TransactionStatus","OperationName","AddressType","ChainName","import_transactions","import_errors","import_abi_coder","import_transactions","import_bytes","import_errors","import_math","import_transactions"]}