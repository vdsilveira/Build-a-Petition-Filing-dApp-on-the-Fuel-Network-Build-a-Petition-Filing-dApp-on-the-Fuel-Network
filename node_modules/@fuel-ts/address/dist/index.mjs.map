{"version":3,"sources":["../src/utils.ts","../src/address.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { randomBytes } from '@fuel-ts/crypto';\nimport { FuelError } from '@fuel-ts/errors';\nimport { AbstractContract, AbstractAccount } from '@fuel-ts/interfaces';\nimport type {\n  Bech32Address,\n  B256Address,\n  AddressLike,\n  ContractIdLike,\n  AbstractAddress,\n  B256AddressEvm,\n} from '@fuel-ts/interfaces';\nimport type { Decoded } from 'bech32';\nimport { bech32m } from 'bech32';\n\n/**\n * Fuel Network HRP (human-readable part) for bech32 encoding\n *\n * @hidden\n */\nexport const FUEL_BECH32_HRP_PREFIX = 'fuel';\n\n/**\n * Decodes a Bech32 address string into Decoded\n *\n * @hidden\n */\nexport function fromBech32(address: Bech32Address): Decoded {\n  return bech32m.decode(address);\n}\n\n/**\n * Converts a B256 address string into Bech32\n *\n * @hidden\n */\nexport function toBech32(address: B256Address): Bech32Address {\n  return bech32m.encode(\n    FUEL_BECH32_HRP_PREFIX,\n    bech32m.toWords(arrayify(hexlify(address)))\n  ) as Bech32Address;\n}\n\n/**\n * Determines if a given string is Bech32 format\n *\n * @hidden\n */\nexport function isBech32(address: BytesLike): boolean {\n  return (\n    typeof address === 'string' &&\n    address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 &&\n    fromBech32(address as Bech32Address).prefix === FUEL_BECH32_HRP_PREFIX\n  );\n}\n\n/**\n * Determines if a given string is B256 format\n *\n * @hidden\n */\nexport function isB256(address: string): boolean {\n  return (address.length === 66 || address.length === 64) && /(0x)?[0-9a-f]{64}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in Public Key format (512 bits)\n *\n * @hidden\n */\nexport function isPublicKey(address: string): boolean {\n  return (address.length === 130 || address.length === 128) && /(0x)?[0-9a-f]{128}$/i.test(address);\n}\n\n/**\n * Takes a Bech32 address and returns the byte data\n *\n * @hidden\n */\nexport function getBytesFromBech32(address: Bech32Address): Uint8Array {\n  return new Uint8Array(bech32m.fromWords(fromBech32(address).words));\n}\n\n/**\n * Converts a Bech32 address string into B256\n *\n * @hidden\n */\nexport function toB256(address: Bech32Address): B256Address {\n  if (!isBech32(address)) {\n    throw new FuelError(\n      FuelError.CODES.INVALID_BECH32_ADDRESS,\n      `Invalid Bech32 Address: ${address}.`\n    );\n  }\n\n  return hexlify(getBytesFromBech32(address));\n}\n\n/**\n * Takes a Bech32 address and returns a normalized (i.e. lower case) representation of it.\n *\n * The input is validated along the way, which makes this significantly safer than\n * using `address.toLowerCase()`.\n *\n * @hidden\n */\nexport function normalizeBech32(address: Bech32Address): Bech32Address {\n  const { words } = fromBech32(address);\n  return bech32m.encode(FUEL_BECH32_HRP_PREFIX, words) as Bech32Address;\n}\n\n/**\n * Takes an indeterminate address type and returns an address\n *\n * @hidden\n */\nexport const addressify = (addressLike: AddressLike | ContractIdLike): AbstractAddress => {\n  if (addressLike instanceof AbstractAccount) {\n    return addressLike.address;\n  }\n\n  if (addressLike instanceof AbstractContract) {\n    return addressLike.id;\n  }\n\n  return addressLike;\n};\n\n/**\n * @hidden\n */\nexport const getRandomB256 = () => hexlify(randomBytes(32));\n\n/**\n * Takes a B256 address and clears the first 12 bytes, this is required for an EVM Address\n *\n * @param b256 - the address to clear\n * @returns b256 with first 12 bytes cleared\n *\n * @hidden\n */\nexport const clearFirst12BytesFromB256 = (b256: B256Address): B256AddressEvm => {\n  let bytes;\n\n  try {\n    if (!isB256(b256)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_BECH32_ADDRESS,\n        `Invalid Bech32 Address: ${b256}.`\n      );\n    }\n\n    bytes = getBytesFromBech32(toBech32(b256));\n    bytes = hexlify(bytes.fill(0, 0, 12)) as B256AddressEvm;\n  } catch (error) {\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Cannot generate EVM Address B256 from: ${b256}.`\n    );\n  }\n\n  return bytes;\n};\n","import { sha256 } from '@ethersproject/sha2';\nimport { FuelError } from '@fuel-ts/errors';\nimport { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Bech32Address, B256Address, EvmAddress } from '@fuel-ts/interfaces';\n\nimport {\n  normalizeBech32,\n  isBech32,\n  toB256,\n  getBytesFromBech32,\n  toBech32,\n  getRandomB256,\n  isPublicKey,\n  isB256,\n  clearFirst12BytesFromB256,\n} from './utils';\n\n/**\n * `Address` provides a type safe wrapper for converting between different address formats\n * ands comparing them for equality.\n */\nexport default class Address extends AbstractAddress {\n  // #region address-2\n  readonly bech32Address: Bech32Address;\n  // #endregion address-2\n\n  /**\n   * @param address - A Bech32 address\n   */\n  constructor(address: Bech32Address) {\n    super();\n    this.bech32Address = normalizeBech32(address);\n\n    if (!isBech32(this.bech32Address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_BECH32_ADDRESS,\n        `Invalid Bech32 Address: ${address}.`\n      );\n    }\n  }\n\n  /**\n   * Returns the `bech32Address` property\n   *\n   * @returns The `bech32Address` property\n   */\n  toAddress(): Bech32Address {\n    return this.bech32Address;\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property to a 256 bit hash string\n   *\n   * @returns The `bech32Address` property as a 256 bit hash string\n   */\n  toB256(): B256Address {\n    return toB256(this.bech32Address);\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property to a byte array\n   *\n   * @returns The `bech32Address` property as a byte array\n   */\n  toBytes(): Uint8Array {\n    return getBytesFromBech32(this.bech32Address);\n  }\n\n  /**\n   * Converts\n   *\n   * @returns The `bech32Address` property as a 256 bit hash string\n   */\n  toHexString(): B256Address {\n    return this.toB256();\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property as a string\n   *\n   * @returns The `bech32Address` property as a string\n   */\n  toString(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property as a string\n   *\n   * @returns The `bech32Address` property as a string\n   */\n  toJSON(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`\n   *\n   * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}\n   */\n  toEvmAddress(): EvmAddress {\n    const b256Address = toB256(this.bech32Address);\n\n    return {\n      value: clearFirst12BytesFromB256(b256Address),\n    } as EvmAddress;\n  }\n\n  /**\n   * Returns the value of the `bech32Address` property\n   *\n   * @returns The value of `bech32Address` property\n   */\n  valueOf(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Compares this the `bech32Address` property to another for direct equality\n   *\n   * @param other - Another address to compare against\n   * @returns The equality of the comparison\n   */\n  equals(other: Address): boolean {\n    return this.bech32Address === other.bech32Address;\n  }\n\n  /**\n   * Takes a Public Key, hashes it, and creates an `Address`\n   *\n   * @param publicKey - A wallets public key\n   * @returns A new `Address` instance\n   */\n  static fromPublicKey(publicKey: string): Address {\n    const b256Address = sha256(publicKey);\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Takes a B256 Address and creates an `Address`\n   *\n   * @param b256Address - A b256 hash\n   * @returns A new `Address` instance\n   */\n  static fromB256(b256Address: string): Address {\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Creates an `Address` with a randomized `bech32Address` property\n   *\n   * @returns A new `Address` instance\n   */\n  static fromRandom(): Address {\n    return this.fromB256(getRandomB256());\n  }\n\n  /**\n   * Takes an ambiguous string and attempts to create an `Address`\n   *\n   * @param address - An ambiguous string\n   * @returns A new `Address` instance\n   */\n  static fromString(address: string): Address {\n    return isBech32(address) ? new Address(address as Bech32Address) : this.fromB256(address);\n  }\n\n  /**\n   * Takes an ambiguous string or address and creates an `Address`\n   *\n   * @returns a new `Address` instance\n   */\n  static fromAddressOrString(address: string | AbstractAddress): AbstractAddress {\n    return typeof address === 'string' ? this.fromString(address) : address;\n  }\n\n  /**\n   * Takes a dynamic string or `AbstractAddress` and creates an `Address`\n   *\n   * @param addressId - A string containing Bech32, B256, or Public Key\n   * @throws Error - Unknown address if the format is not recognised\n   * @returns A new `Address` instance\n   */\n  static fromDynamicInput(address: string | AbstractAddress): Address {\n    // If address is a object than we assume it's a AbstractAddress\n    // we don't check by instanceof because it's possible to\n    // the host app to have a different reference to this same class type\n    if (typeof address !== 'string' && 'toB256' in address) {\n      return Address.fromB256(address.toB256());\n    }\n    if (isPublicKey(address)) {\n      return Address.fromPublicKey(address);\n    }\n\n    if (isBech32(address)) {\n      return new Address(address as Bech32Address);\n    }\n\n    if (isB256(address)) {\n      return Address.fromB256(address);\n    }\n\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`\n    );\n  }\n\n  /**\n   * Takes an `EvmAddress` and returns back an `Address`\n   *\n   * @returns A new `Address` instance\n   */\n  static fromEvmAddress(evmAddress: EvmAddress): Address {\n    return new Address(toBech32(evmAddress.value));\n  }\n}\n"],"mappings":"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","names":["FuelError","FuelError"]}