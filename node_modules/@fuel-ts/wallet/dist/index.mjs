var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/base-unlocked-wallet.ts
import { hashMessage, hashTransaction } from "@fuel-ts/hasher";
import { transactionRequestify as transactionRequestify2 } from "@fuel-ts/providers";
import { Signer } from "@fuel-ts/signer";

// src/account.ts
import { arrayify as arrayify2, hexlify } from "@ethersproject/bytes";
import { Address } from "@fuel-ts/address";
import { BaseAssetId } from "@fuel-ts/address/configs";
import { ErrorCode, FuelError } from "@fuel-ts/errors";
import { AbstractAccount } from "@fuel-ts/interfaces";
import { bn } from "@fuel-ts/math";
import {
  withdrawScript,
  ScriptTransactionRequest,
  transactionRequestify
} from "@fuel-ts/providers";

// src/utils.ts
import { arrayify } from "@ethersproject/bytes";
import { NumberCoder } from "@fuel-ts/abi-coder";
import { BN } from "@fuel-ts/math";
import * as asm from "@fuels/vm-asm";
var composeScriptForTransferringToContract = async () => {
  await asm.initWasm();
  const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
  const addi2 = asm.addi(17, 16, 32);
  const lw2 = asm.lw(18, 17, 0);
  const addi22 = asm.addi(19, 17, 8);
  const tr2 = asm.tr(16, 18, 19);
  const ret2 = asm.ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return script;
};
var formatScriptDataForTransferringToContract = (hexelifiedContractId, amountToTransfer, assetId) => {
  const numberCoder = new NumberCoder("u16");
  const encoded = numberCoder.encode(new BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...arrayify(hexelifiedContractId),
    ...encoded,
    ...arrayify(assetId)
  ]);
  return scriptData;
};

// src/account.ts
var Account = class extends AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  provider;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance.
   */
  constructor(address, provider) {
    super();
    this.provider = provider;
    this.address = Address.fromDynamicInput(address);
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this.provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve.
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError(
        ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
      );
    }
    return coins;
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError(
        ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
      );
    }
    return messages;
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for.
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId = BaseAssetId) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError(
        ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
      );
    }
    return balances;
  }
  /**
   * Adds resources to the transaction enough to fund it.
   *
   * @param request - The transaction request.
   * @returns A promise that resolves when the resources are added to the transaction.
   */
  async fund(request) {
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    const resources = await this.getResourcesToSpend([fee]);
    request.addResources(resources);
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { gasLimit: maxGasPerTx, ...txParams };
    const request = new ScriptTransactionRequest(params);
    request.addCoinOutput(destination, amount, assetId);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    if (fee.assetId === hexlify(assetId)) {
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
    } else {
      quantities = [[amount, assetId], fee];
    }
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId = BaseAssetId, txParams = {}) {
    const script = await composeScriptForTransferringToContract();
    const scriptData = formatScriptDataForTransferringToContract(
      contractId.toB256(),
      amount,
      assetId
    );
    const { maxGasPerTx } = this.provider.getGasConfig();
    const request = new ScriptTransactionRequest({
      gasLimit: maxGasPerTx,
      ...txParams,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractId);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    if (fee.assetId === hexlify(assetId)) {
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
    } else {
      quantities = [[amount, assetId], fee];
    }
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientDataArray = arrayify2(
      "0x".concat(recipient.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = arrayify2(
      "0x".concat(bn(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...arrayify2(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { script, gasLimit: maxGasPerTx, ...txParams };
    const request = new ScriptTransactionRequest(params);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    fee.amount = fee.amount.add(amount);
    quantities = [fee];
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(transactionRequest);
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.simulate(transactionRequest);
  }
};

// src/keystore-wallet.ts
import { hexlify as hexlify2 } from "@ethersproject/bytes";
import {
  bufferFromString,
  keccak256,
  randomBytes,
  scrypt,
  stringFromBuffer,
  decryptJsonWalletData,
  encryptJsonWalletData
} from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode2, FuelError as FuelError2 } from "@fuel-ts/errors";
import { v4 as uuidv4 } from "uuid";
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = bufferFromString(removeHexPrefix(privateKey), "hex");
  const salt = randomBytes(DEFAULT_KEY_SIZE);
  const key = scrypt({
    password: bufferFromString(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = randomBytes(DEFAULT_IV_SIZE);
  const ciphertext = await encryptJsonWalletData(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = keccak256(data);
  const mac = stringFromBuffer(macHashUint8Array, "hex");
  const keystore = {
    id: uuidv4(),
    version: 3,
    address: removeHexPrefix(address.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: stringFromBuffer(iv, "hex") },
      ciphertext: stringFromBuffer(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: stringFromBuffer(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = bufferFromString(ciphertext, "hex");
  const ivBuffer = bufferFromString(iv, "hex");
  const saltBuffer = bufferFromString(salt, "hex");
  const passwordBuffer = bufferFromString(password);
  const key = scrypt({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = keccak256(data);
  const macHash = stringFromBuffer(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new FuelError2(
      ErrorCode2.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await decryptJsonWalletData(ciphertextBuffer, key, ivBuffer);
  const privateKey = hexlify2(buffer);
  return privateKey;
}

// src/base-unlocked-wallet.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * The provider used to interact with the Fuel network.
   */
  provider;
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance.
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
    this.provider = provider;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign(hashMessage(message));
    return signedMessage;
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify2(transactionRequestLike);
    const chainId = (await this.provider.getChain()).consensusParameters.chainId.toNumber();
    const hashedTransaction = hashTransaction(transactionRequest, chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return signature;
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify2(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify2(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest)
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify2(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.call(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true
      }
    );
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/wallets.ts
import { HDWallet } from "@fuel-ts/hdwallet";
import { Mnemonic } from "@fuel-ts/mnemonic";
import { Signer as Signer2 } from "@fuel-ts/signer";
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this.provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer2("0x00");
    return new WalletLocked(this.address, this.provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer2.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance.
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, provider, path) {
    const hdWallet = HDWallet.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance.
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, provider, path, passphrase) {
    const seed = Mnemonic.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = HDWallet.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance.
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = HDWallet.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance.
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance.
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param path - The derivation path (optional).
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);
export {
  Account,
  BaseWalletUnlocked,
  Wallet,
  WalletLocked,
  WalletUnlocked
};
//# sourceMappingURL=index.mjs.map