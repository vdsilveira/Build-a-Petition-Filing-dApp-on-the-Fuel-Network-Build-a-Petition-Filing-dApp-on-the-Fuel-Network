"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/test-utils.ts
var test_utils_exports = {};
__export(test_utils_exports, {
  generateTestWallet: () => generateTestWallet,
  launchNode: () => launchNode,
  launchNodeAndGetWallets: () => launchNodeAndGetWallets,
  seedTestWallet: () => seedTestWallet
});
module.exports = __toCommonJS(test_utils_exports);

// src/wallets.ts
var import_hdwallet = require("@fuel-ts/hdwallet");
var import_mnemonic = require("@fuel-ts/mnemonic");
var import_signer2 = require("@fuel-ts/signer");

// src/account.ts
var import_bytes2 = require("@ethersproject/bytes");
var import_address = require("@fuel-ts/address");
var import_configs = require("@fuel-ts/address/configs");
var import_errors = require("@fuel-ts/errors");
var import_interfaces = require("@fuel-ts/interfaces");
var import_math2 = require("@fuel-ts/math");
var import_providers = require("@fuel-ts/providers");

// src/utils.ts
var import_bytes = require("@ethersproject/bytes");
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_math = require("@fuel-ts/math");
var asm = __toESM(require("@fuels/vm-asm"));
var composeScriptForTransferringToContract = async () => {
  await asm.initWasm();
  const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
  const addi2 = asm.addi(17, 16, 32);
  const lw2 = asm.lw(18, 17, 0);
  const addi22 = asm.addi(19, 17, 8);
  const tr2 = asm.tr(16, 18, 19);
  const ret2 = asm.ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return script;
};
var formatScriptDataForTransferringToContract = (hexelifiedContractId, amountToTransfer, assetId) => {
  const numberCoder = new import_abi_coder.NumberCoder("u16");
  const encoded = numberCoder.encode(new import_math.BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...(0, import_bytes.arrayify)(hexelifiedContractId),
    ...encoded,
    ...(0, import_bytes.arrayify)(assetId)
  ]);
  return scriptData;
};

// src/account.ts
var Account = class extends import_interfaces.AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  provider;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance.
   */
  constructor(address, provider) {
    super();
    this.provider = provider;
    this.address = import_address.Address.fromDynamicInput(address);
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this.provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve.
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors.FuelError(
        import_errors.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
      );
    }
    return coins;
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors.FuelError(
        import_errors.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
      );
    }
    return messages;
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for.
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId = import_configs.BaseAssetId) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors.FuelError(
        import_errors.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
      );
    }
    return balances;
  }
  /**
   * Adds resources to the transaction enough to fund it.
   *
   * @param request - The transaction request.
   * @returns A promise that resolves when the resources are added to the transaction.
   */
  async fund(request) {
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    const resources = await this.getResourcesToSpend([fee]);
    request.addResources(resources);
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId = import_configs.BaseAssetId, txParams = {}) {
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { gasLimit: maxGasPerTx, ...txParams };
    const request = new import_providers.ScriptTransactionRequest(params);
    request.addCoinOutput(destination, amount, assetId);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    if (fee.assetId === (0, import_bytes2.hexlify)(assetId)) {
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
    } else {
      quantities = [[amount, assetId], fee];
    }
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId = import_configs.BaseAssetId, txParams = {}) {
    const script = await composeScriptForTransferringToContract();
    const scriptData = formatScriptDataForTransferringToContract(
      contractId.toB256(),
      amount,
      assetId
    );
    const { maxGasPerTx } = this.provider.getGasConfig();
    const request = new import_providers.ScriptTransactionRequest({
      gasLimit: maxGasPerTx,
      ...txParams,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractId);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    if (fee.assetId === (0, import_bytes2.hexlify)(assetId)) {
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
    } else {
      quantities = [[amount, assetId], fee];
    }
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientDataArray = (0, import_bytes2.arrayify)(
      "0x".concat(recipient.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = (0, import_bytes2.arrayify)(
      "0x".concat((0, import_math2.bn)(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...(0, import_bytes2.arrayify)(import_providers.withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { script, gasLimit: maxGasPerTx, ...txParams };
    const request = new import_providers.ScriptTransactionRequest(params);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    fee.amount = fee.amount.add(amount);
    quantities = [fee];
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(transactionRequest);
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.simulate(transactionRequest);
  }
};

// src/base-unlocked-wallet.ts
var import_hasher = require("@fuel-ts/hasher");
var import_providers2 = require("@fuel-ts/providers");
var import_signer = require("@fuel-ts/signer");

// src/keystore-wallet.ts
var import_bytes3 = require("@ethersproject/bytes");
var import_crypto = require("@fuel-ts/crypto");
var import_errors2 = require("@fuel-ts/errors");
var import_uuid = require("uuid");
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = (0, import_crypto.bufferFromString)(removeHexPrefix(privateKey), "hex");
  const salt = (0, import_crypto.randomBytes)(DEFAULT_KEY_SIZE);
  const key = (0, import_crypto.scrypt)({
    password: (0, import_crypto.bufferFromString)(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = (0, import_crypto.randomBytes)(DEFAULT_IV_SIZE);
  const ciphertext = await (0, import_crypto.encryptJsonWalletData)(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = (0, import_crypto.keccak256)(data);
  const mac = (0, import_crypto.stringFromBuffer)(macHashUint8Array, "hex");
  const keystore = {
    id: (0, import_uuid.v4)(),
    version: 3,
    address: removeHexPrefix(address.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: (0, import_crypto.stringFromBuffer)(iv, "hex") },
      ciphertext: (0, import_crypto.stringFromBuffer)(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: (0, import_crypto.stringFromBuffer)(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = (0, import_crypto.bufferFromString)(ciphertext, "hex");
  const ivBuffer = (0, import_crypto.bufferFromString)(iv, "hex");
  const saltBuffer = (0, import_crypto.bufferFromString)(salt, "hex");
  const passwordBuffer = (0, import_crypto.bufferFromString)(password);
  const key = (0, import_crypto.scrypt)({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = (0, import_crypto.keccak256)(data);
  const macHash = (0, import_crypto.stringFromBuffer)(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new import_errors2.FuelError(
      import_errors2.ErrorCode.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await (0, import_crypto.decryptJsonWalletData)(ciphertextBuffer, key, ivBuffer);
  const privateKey = (0, import_bytes3.hexlify)(buffer);
  return privateKey;
}

// src/base-unlocked-wallet.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * The provider used to interact with the Fuel network.
   */
  provider;
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance.
   */
  constructor(privateKey, provider) {
    const signer = new import_signer.Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
    this.provider = provider;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign((0, import_hasher.hashMessage)(message));
    return signedMessage;
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    const chainId = (await this.provider.getChain()).consensusParameters.chainId.toNumber();
    const hashedTransaction = (0, import_hasher.hashTransaction)(transactionRequest, chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return signature;
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest)
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.call(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true
      }
    );
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/wallets.ts
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this.provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new import_signer2.Signer("0x00");
    return new WalletLocked(this.address, this.provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = import_signer2.Signer.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance.
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, provider, path2) {
    const hdWallet = import_hdwallet.HDWallet.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance.
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, provider, path2, passphrase) {
    const seed = import_mnemonic.Mnemonic.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = import_hdwallet.HDWallet.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance.
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = import_hdwallet.HDWallet.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance.
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance.
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param path - The derivation path (optional).
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

// src/test-utils/seedTestWallet.ts
var import_crypto2 = require("@fuel-ts/crypto");
var import_providers3 = require("@fuel-ts/providers");
var seedTestWallet = async (wallet, quantities) => {
  const genesisWallet = new WalletUnlocked(
    process.env.GENESIS_SECRET || (0, import_crypto2.randomBytes)(32),
    wallet.provider
  );
  const resources = await genesisWallet.getResourcesToSpend(quantities);
  const request = new import_providers3.ScriptTransactionRequest({
    gasLimit: 1e4,
    gasPrice: 1
  });
  request.addResources(resources);
  quantities.map(import_providers3.coinQuantityfy).forEach(({ amount, assetId }) => request.addCoinOutput(wallet.address, amount, assetId));
  const response = await genesisWallet.sendTransaction(request);
  await response.wait();
};

// src/test-utils/generateTestWallet.ts
var generateTestWallet = async (provider, quantities) => {
  const wallet = Wallet.generate({ provider });
  if (quantities) {
    await seedTestWallet(wallet, quantities);
  }
  return wallet;
};

// src/test-utils/launchNode.ts
var import_configs2 = require("@fuel-ts/address/configs");
var import_providers4 = require("@fuel-ts/providers");
var import_child_process = require("child_process");
var import_crypto3 = require("crypto");
var import_fs = __toESM(require("fs"));
var import_promises = __toESM(require("fs/promises"));
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_portfinder = require("portfinder");
var import_tree_kill = __toESM(require("tree-kill"));

// src/test-utils/defaultChainConfig.ts
var defaultChainConfig = {
  chain_name: "local_testnet",
  block_gas_limit: 5e9,
  initial_state: {
    coins: [
      {
        owner: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0xbca334a06d19db5041c78fe2f465b07be5bec828f38b7796b2877e7d1542c950",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0xbca334a06d19db5041c78fe2f465b07be5bec828f38b7796b2877e7d1542c950",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0xbca334a06d19db5041c78fe2f465b07be5bec828f38b7796b2877e7d1542c950",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0xbd9a1dc8d3ec3521c43f6c2c01611b4d0204c7610204ff0178488c8738a30bd2",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0xbd9a1dc8d3ec3521c43f6c2c01611b4d0204c7610204ff0178488c8738a30bd2",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0xbd9a1dc8d3ec3521c43f6c2c01611b4d0204c7610204ff0178488c8738a30bd2",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0xb32197cf75efe05bf453c26178139f09b391582065549c1422bc92555ecffb64",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0xb32197cf75efe05bf453c26178139f09b391582065549c1422bc92555ecffb64",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0xb32197cf75efe05bf453c26178139f09b391582065549c1422bc92555ecffb64",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x3b24509ed4ab3c7959f5c9391c1445c59290cdb5f13d6f780922f376b7029f30",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x3b24509ed4ab3c7959f5c9391c1445c59290cdb5f13d6f780922f376b7029f30",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x3b24509ed4ab3c7959f5c9391c1445c59290cdb5f13d6f780922f376b7029f30",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x77c6f40b7da70d885f68efaad7c661327482a63ea10dcb4271de819438254ae1",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x77c6f40b7da70d885f68efaad7c661327482a63ea10dcb4271de819438254ae1",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x77c6f40b7da70d885f68efaad7c661327482a63ea10dcb4271de819438254ae1",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x6a2c4691c547c43924650dbd30620b184b5fe3fb6dbe5c4446110b08f6f405bf",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x6a2c4691c547c43924650dbd30620b184b5fe3fb6dbe5c4446110b08f6f405bf",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x6a2c4691c547c43924650dbd30620b184b5fe3fb6dbe5c4446110b08f6f405bf",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      },
      {
        owner: "0x49075a7538e2c88ebe1926ce4d898198a2a4e790d14512943a9864bc536b3c82",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        owner: "0x49075a7538e2c88ebe1926ce4d898198a2a4e790d14512943a9864bc536b3c82",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
      },
      {
        owner: "0x49075a7538e2c88ebe1926ce4d898198a2a4e790d14512943a9864bc536b3c82",
        amount: "0xFFFFFFFFFFFFFFFF",
        asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
      }
    ],
    messages: [
      {
        sender: "0xc43454aa38dd91f88109a4b7aef5efb96ce34e3f24992fe0f81d233ca686f80f",
        recipient: "0x69a2b736b60159b43bb8a4f98c0589f6da5fa3a3d101e8e269c499eb942753ba",
        nonce: "0101010101010101010101010101010101010101010101010101010101010101",
        amount: "0x000000000000FFFF",
        data: "",
        da_height: "0x00"
      },
      {
        sender: "0x69a2b736b60159b43bb8a4f98c0589f6da5fa3a3d101e8e269c499eb942753ba",
        recipient: "0xc43454aa38dd91f88109a4b7aef5efb96ce34e3f24992fe0f81d233ca686f80f",
        nonce: "0e1ef2963832068b0e1ef2963832068b0e1ef2963832068b0e1ef2963832068b",
        amount: "0xb04f3c08f59b309e",
        data: "",
        da_height: "0x00"
      }
    ]
  },
  transaction_parameters: {
    contract_max_size: 16777216,
    max_inputs: 255,
    max_outputs: 255,
    max_witnesses: 255,
    max_gas_per_tx: 5e8,
    max_script_length: 1048576,
    max_script_data_length: 1048576,
    max_static_contracts: 255,
    max_storage_slots: 255,
    max_predicate_length: 1048576,
    max_predicate_data_length: 1048576,
    max_gas_per_predicate: 1e8,
    gas_price_factor: 1e9,
    gas_per_byte: 4,
    max_message_data_length: 1048576
  },
  gas_costs: {
    add: 1,
    addi: 1,
    aloc: 1,
    and: 1,
    andi: 1,
    bal: 21,
    bhei: 1,
    bhsh: 1,
    burn: 35,
    cb: 2,
    cfei: 1,
    cfsi: 1,
    croo: 28,
    div: 1,
    divi: 1,
    ecr: 1703,
    eq: 1,
    exp: 1,
    expi: 1,
    flag: 1,
    gm: 1,
    gt: 1,
    gtf: 1,
    ji: 1,
    jmp: 1,
    jne: 1,
    jnei: 1,
    jnzi: 1,
    k256: 19,
    lb: 1,
    log: 40,
    lt: 1,
    lw: 1,
    mcpi: 3,
    mint: 35,
    mlog: 1,
    mod: 1,
    modi: 1,
    move: 1,
    movi: 1,
    mroo: 2,
    mul: 1,
    muli: 1,
    noop: 1,
    not: 1,
    or: 1,
    ori: 1,
    ret_contract: 61,
    rvrt_contract: 61,
    s256: 5,
    sb: 1,
    scwq: 11,
    sll: 1,
    slli: 1,
    srl: 1,
    srli: 1,
    srw: 23,
    sub: 1,
    subi: 1,
    sw: 1,
    sww: 79,
    swwq: 72,
    time: 1,
    tr: 120,
    tro: 99,
    xor: 1,
    xori: 1,
    call: {
      base: 116,
      dep_per_unit: 14
    },
    ccp: {
      base: 24,
      dep_per_unit: 13
    },
    csiz: {
      base: 17,
      dep_per_unit: 15
    },
    ldc: {
      base: 23,
      dep_per_unit: 14
    },
    logd: {
      base: 46,
      dep_per_unit: 19
    },
    mcl: {
      base: 1,
      dep_per_unit: 2359
    },
    mcli: {
      base: 1,
      dep_per_unit: 2322
    },
    mcp: {
      base: 1,
      dep_per_unit: 1235
    },
    meq: {
      base: 1,
      dep_per_unit: 2343
    },
    retd_contract: {
      base: 65,
      dep_per_unit: 19
    },
    smo: {
      base: 84,
      dep_per_unit: 13
    },
    srwq: {
      base: 54,
      dep_per_unit: 2
    }
  },
  consensus: {
    PoA: {
      signing_key: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d"
    }
  }
};

// src/test-utils/launchNode.ts
var defaultFuelCoreArgs = ["--vm-backtrace", "--utxo-validation", "--manual_blocks_enabled"];
var launchNode = async ({
  chainConfigPath,
  consensusKey = "0xa449b1ffee0e2205fa924c6740cc48b3b473aa28587df6dab12abc245d1f5298",
  ip,
  port,
  args = defaultFuelCoreArgs,
  useSystemFuelCore = false
}) => (
  // eslint-disable-next-line no-async-promise-executor
  new Promise(async (resolve) => {
    const graphQLStartSubstring = "Binding GraphQL provider to";
    const command = useSystemFuelCore ? "fuel-core" : "./node_modules/.bin/fuels-core";
    const ipToUse = ip || "0.0.0.0";
    const portToUse = port || (await (0, import_portfinder.getPortPromise)({
      port: 4e3,
      // tries 4000 first, then 4001, then 4002, etc.
      stopPort: 5e3
      // don't try ports above 5000
    })).toString();
    let chainConfigPathToUse = chainConfigPath;
    const tempDirPath = import_path.default.join(import_os.default.tmpdir(), ".fuels-ts", (0, import_crypto3.randomUUID)());
    if (!chainConfigPath) {
      if (!import_fs.default.existsSync(tempDirPath)) {
        import_fs.default.mkdirSync(tempDirPath, { recursive: true });
      }
      const tempChainConfigFilePath = import_path.default.join(tempDirPath, ".chainConfig.json");
      await import_promises.default.writeFile(tempChainConfigFilePath, JSON.stringify(defaultChainConfig), "utf8");
      chainConfigPathToUse = tempChainConfigFilePath;
    }
    const child = (0, import_child_process.spawn)(command, [
      "run",
      "--ip",
      ipToUse,
      "--port",
      portToUse,
      "--db-type",
      "in-memory",
      "--consensus-key",
      consensusKey,
      "--chain",
      chainConfigPathToUse,
      ...args
    ]);
    const cleanup = () => {
      if (child.pid) {
        (0, import_tree_kill.default)(Number(child.pid));
      }
      child.stdout.removeAllListeners();
      child.stderr.removeAllListeners();
      if (!chainConfigPath) {
        (0, import_child_process.spawn)("rm", ["-rf", tempDirPath]);
      }
    };
    child.stderr.setEncoding("utf8");
    child.stderr.on("data", (chunk) => {
      if (chunk.indexOf(graphQLStartSubstring) !== -1) {
        resolve({
          cleanup,
          ip: ipToUse,
          port: portToUse
        });
      }
    });
    process.on("exit", cleanup);
    process.on("SIGINT", cleanup);
    process.on("SIGUSR1", cleanup);
    process.on("SIGUSR2", cleanup);
    process.on("uncaughtException", cleanup);
  })
);
var generateWallets = async (count, provider) => {
  const wallets = [];
  for (let i = 0; i < count; i += 1) {
    const wallet = await generateTestWallet(provider, [[1e3, import_configs2.BaseAssetId]]);
    wallets.push(wallet);
  }
  return wallets;
};
var launchNodeAndGetWallets = async ({
  launchNodeOptions,
  walletCount = 10
} = {}) => {
  const defaultNodeOptions = {
    chainConfigPath: launchNodeOptions?.chainConfigPath,
    consensusKey: launchNodeOptions?.consensusKey
  };
  const {
    cleanup: closeNode,
    ip,
    port
  } = await launchNode({ ...defaultNodeOptions, ...launchNodeOptions });
  const provider = await import_providers4.Provider.create(`http://${ip}:${port}/graphql`);
  const wallets = await generateWallets(walletCount, provider);
  const cleanup = () => {
    closeNode();
  };
  return { wallets, stop: cleanup, provider };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateTestWallet,
  launchNode,
  launchNodeAndGetWallets,
  seedTestWallet
});
//# sourceMappingURL=test-utils.js.map