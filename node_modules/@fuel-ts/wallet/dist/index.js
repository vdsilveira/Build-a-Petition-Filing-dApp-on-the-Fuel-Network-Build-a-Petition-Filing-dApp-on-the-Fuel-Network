"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Account: () => Account,
  BaseWalletUnlocked: () => BaseWalletUnlocked,
  Wallet: () => Wallet,
  WalletLocked: () => WalletLocked,
  WalletUnlocked: () => WalletUnlocked
});
module.exports = __toCommonJS(src_exports);

// src/base-unlocked-wallet.ts
var import_hasher = require("@fuel-ts/hasher");
var import_providers2 = require("@fuel-ts/providers");
var import_signer = require("@fuel-ts/signer");

// src/account.ts
var import_bytes2 = require("@ethersproject/bytes");
var import_address = require("@fuel-ts/address");
var import_configs = require("@fuel-ts/address/configs");
var import_errors = require("@fuel-ts/errors");
var import_interfaces = require("@fuel-ts/interfaces");
var import_math2 = require("@fuel-ts/math");
var import_providers = require("@fuel-ts/providers");

// src/utils.ts
var import_bytes = require("@ethersproject/bytes");
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_math = require("@fuel-ts/math");
var asm = __toESM(require("@fuels/vm-asm"));
var composeScriptForTransferringToContract = async () => {
  await asm.initWasm();
  const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
  const addi2 = asm.addi(17, 16, 32);
  const lw2 = asm.lw(18, 17, 0);
  const addi22 = asm.addi(19, 17, 8);
  const tr2 = asm.tr(16, 18, 19);
  const ret2 = asm.ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return script;
};
var formatScriptDataForTransferringToContract = (hexelifiedContractId, amountToTransfer, assetId) => {
  const numberCoder = new import_abi_coder.NumberCoder("u16");
  const encoded = numberCoder.encode(new import_math.BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...(0, import_bytes.arrayify)(hexelifiedContractId),
    ...encoded,
    ...(0, import_bytes.arrayify)(assetId)
  ]);
  return scriptData;
};

// src/account.ts
var Account = class extends import_interfaces.AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  provider;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance.
   */
  constructor(address, provider) {
    super();
    this.provider = provider;
    this.address = import_address.Address.fromDynamicInput(address);
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this.provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve.
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors.FuelError(
        import_errors.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
      );
    }
    return coins;
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors.FuelError(
        import_errors.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
      );
    }
    return messages;
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for.
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId = import_configs.BaseAssetId) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors.FuelError(
        import_errors.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
      );
    }
    return balances;
  }
  /**
   * Adds resources to the transaction enough to fund it.
   *
   * @param request - The transaction request.
   * @returns A promise that resolves when the resources are added to the transaction.
   */
  async fund(request) {
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    const resources = await this.getResourcesToSpend([fee]);
    request.addResources(resources);
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId = import_configs.BaseAssetId, txParams = {}) {
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { gasLimit: maxGasPerTx, ...txParams };
    const request = new import_providers.ScriptTransactionRequest(params);
    request.addCoinOutput(destination, amount, assetId);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    if (fee.assetId === (0, import_bytes2.hexlify)(assetId)) {
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
    } else {
      quantities = [[amount, assetId], fee];
    }
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId = import_configs.BaseAssetId, txParams = {}) {
    const script = await composeScriptForTransferringToContract();
    const scriptData = formatScriptDataForTransferringToContract(
      contractId.toB256(),
      amount,
      assetId
    );
    const { maxGasPerTx } = this.provider.getGasConfig();
    const request = new import_providers.ScriptTransactionRequest({
      gasLimit: maxGasPerTx,
      ...txParams,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractId);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    if (fee.assetId === (0, import_bytes2.hexlify)(assetId)) {
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
    } else {
      quantities = [[amount, assetId], fee];
    }
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientDataArray = (0, import_bytes2.arrayify)(
      "0x".concat(recipient.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = (0, import_bytes2.arrayify)(
      "0x".concat((0, import_math2.bn)(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...(0, import_bytes2.arrayify)(import_providers.withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { script, gasLimit: maxGasPerTx, ...txParams };
    const request = new import_providers.ScriptTransactionRequest(params);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    fee.amount = fee.amount.add(amount);
    quantities = [fee];
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(transactionRequest);
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.simulate(transactionRequest);
  }
};

// src/keystore-wallet.ts
var import_bytes3 = require("@ethersproject/bytes");
var import_crypto = require("@fuel-ts/crypto");
var import_errors2 = require("@fuel-ts/errors");
var import_uuid = require("uuid");
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = (0, import_crypto.bufferFromString)(removeHexPrefix(privateKey), "hex");
  const salt = (0, import_crypto.randomBytes)(DEFAULT_KEY_SIZE);
  const key = (0, import_crypto.scrypt)({
    password: (0, import_crypto.bufferFromString)(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = (0, import_crypto.randomBytes)(DEFAULT_IV_SIZE);
  const ciphertext = await (0, import_crypto.encryptJsonWalletData)(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = (0, import_crypto.keccak256)(data);
  const mac = (0, import_crypto.stringFromBuffer)(macHashUint8Array, "hex");
  const keystore = {
    id: (0, import_uuid.v4)(),
    version: 3,
    address: removeHexPrefix(address.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: (0, import_crypto.stringFromBuffer)(iv, "hex") },
      ciphertext: (0, import_crypto.stringFromBuffer)(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: (0, import_crypto.stringFromBuffer)(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = (0, import_crypto.bufferFromString)(ciphertext, "hex");
  const ivBuffer = (0, import_crypto.bufferFromString)(iv, "hex");
  const saltBuffer = (0, import_crypto.bufferFromString)(salt, "hex");
  const passwordBuffer = (0, import_crypto.bufferFromString)(password);
  const key = (0, import_crypto.scrypt)({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = (0, import_crypto.keccak256)(data);
  const macHash = (0, import_crypto.stringFromBuffer)(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new import_errors2.FuelError(
      import_errors2.ErrorCode.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await (0, import_crypto.decryptJsonWalletData)(ciphertextBuffer, key, ivBuffer);
  const privateKey = (0, import_bytes3.hexlify)(buffer);
  return privateKey;
}

// src/base-unlocked-wallet.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * The provider used to interact with the Fuel network.
   */
  provider;
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance.
   */
  constructor(privateKey, provider) {
    const signer = new import_signer.Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
    this.provider = provider;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign((0, import_hasher.hashMessage)(message));
    return signedMessage;
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    const chainId = (await this.provider.getChain()).consensusParameters.chainId.toNumber();
    const hashedTransaction = (0, import_hasher.hashTransaction)(transactionRequest, chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return signature;
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest)
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = (0, import_providers2.transactionRequestify)(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.call(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true
      }
    );
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/wallets.ts
var import_hdwallet = require("@fuel-ts/hdwallet");
var import_mnemonic = require("@fuel-ts/mnemonic");
var import_signer2 = require("@fuel-ts/signer");
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this.provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new import_signer2.Signer("0x00");
    return new WalletLocked(this.address, this.provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = import_signer2.Signer.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance.
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, provider, path) {
    const hdWallet = import_hdwallet.HDWallet.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance.
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, provider, path, passphrase) {
    const seed = import_mnemonic.Mnemonic.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = import_hdwallet.HDWallet.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance.
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = import_hdwallet.HDWallet.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance.
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance.
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param path - The derivation path (optional).
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  BaseWalletUnlocked,
  Wallet,
  WalletLocked,
  WalletUnlocked
});
//# sourceMappingURL=index.js.map