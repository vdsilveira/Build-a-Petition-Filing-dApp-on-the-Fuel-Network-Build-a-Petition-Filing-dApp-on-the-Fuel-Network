{"version":3,"sources":["../src/utils.ts","../src/configs.ts","../src/errors.ts","../src/revert/revert-error-codes.ts","../src/revert/revert-error.ts","../src/functions/invocation-scope.ts","../src/functions/base-invocation-scope.ts","../src/contract-call-script.ts","../src/instruction-set.ts","../src/script-request.ts","../src/functions/invocation-results.ts","../src/functions/multicall-scope.ts","../src/contract.ts"],"sourcesContent":["import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { TransactionResult } from '@fuel-ts/providers';\n\nimport { PANIC_REASONS, PANIC_DOC_URL } from './configs';\n\n/**\n * @hidden\n */\nconst getFailureReason = (reason: string): string => {\n  if (PANIC_REASONS.includes(reason)) {\n    return reason;\n  }\n\n  return reason === 'Revert(123)' ? 'MismatchedSelector' : 'unknown';\n};\n\n/**\n * @hidden\n */\nexport const getDocs = (\n  status: TransactionResult['gqlTransaction']['status']\n): { doc: string; reason: string } => {\n  if (status?.type === 'FailureStatus') {\n    const reason = getFailureReason(status.reason);\n    return {\n      doc: reason !== 'unknown' ? `${PANIC_DOC_URL}#variant.${reason}` : PANIC_DOC_URL,\n      reason,\n    };\n  }\n  return { doc: PANIC_DOC_URL, reason: 'unknown' };\n};\n\n/**\n * @hidden\n *\n * Generic assert function to avoid undesirable errors\n */\nexport function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new FuelError(ErrorCode.TRANSACTION_ERROR, message);\n  }\n}\n","// From https://github.com/FuelLabs/fuel-asm/blob/eb78378c3b7c22a53b834381c387d89b3c0ef122/src/panic_reason.rs#L13\nexport const PANIC_REASONS = [\n  'Success',\n  'Revert',\n  'OutOfGas',\n  'TransactionValidity',\n  'MemoryOverflow',\n  'ArithmeticOverflow',\n  'ContractNotFound',\n  'MemoryOwnership',\n  'NotEnoughBalance',\n  'ExpectedInternalContext',\n  'AssetIdNotFound',\n  'InputNotFound',\n  'OutputNotFound',\n  'WitnessNotFound',\n  'TransactionMaturity',\n  'InvalidMetadataIdentifier',\n  'MalformedCallStructure',\n  'ReservedRegisterNotWritable',\n  'ErrorFlag',\n  'InvalidImmediateValue',\n  'ExpectedCoinInput',\n  'MaxMemoryAccess',\n  'MemoryWriteOverlap',\n  'ContractNotInInputs',\n  'InternalBalanceOverflow',\n  'ContractMaxSize',\n  'ExpectedUnallocatedStack',\n  'MaxStaticContractsReached',\n  'TransferAmountCannotBeZero',\n  'ExpectedOutputVariable',\n  'ExpectedParentInternalContext',\n  'IllegalJump',\n  'NonZeroMessageOutputRecipient',\n  'ZeroedMessageOutputRecipient',\n];\nexport const PANIC_DOC_URL = 'https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html';\n","import type { TransactionResult } from '@fuel-ts/providers';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport { RevertErrorCodes } from './revert/revert-error-codes';\nimport { getDocs } from './utils';\n\nconst bigintReplacer = (key: unknown, value: unknown) =>\n  typeof value === 'bigint' ? value.toString() : value;\n\n/**\n * @hidden\n */\nexport class ScriptResultDecoderError extends Error {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  logs: any[];\n  constructor(result: TransactionResult, message: string, logs: Array<unknown>) {\n    let docLink = '';\n\n    if (result?.gqlTransaction?.status) {\n      docLink = `${JSON.stringify(getDocs(result.gqlTransaction.status), null, 2)}\\n\\n`;\n    }\n\n    const logsText = logs.length ? `Logs:\\n${JSON.stringify(logs, null, 2)}\\n\\n` : '';\n\n    const receiptsText = `Receipts:\\n${JSON.stringify(\n      result.receipts.map(({ type, ...r }) => ({ type: ReceiptType[type], ...r })),\n      bigintReplacer,\n      2\n    )}`;\n\n    super(`${message}\\n\\n${docLink}${logsText}${receiptsText}`);\n    this.logs = logs;\n\n    new RevertErrorCodes(result.receipts).assert(this);\n  }\n}\n","import type { TransactionResultReceipt, TransactionResultRevertReceipt } from '@fuel-ts/providers';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport type { RevertError } from './revert-error';\nimport { revertErrorFactory } from './revert-error';\n\nconst { warn } = console;\n\nconst getRevertReceipts = (\n  receipts: TransactionResultReceipt[]\n): TransactionResultRevertReceipt[] =>\n  receipts.filter((r) => r.type === ReceiptType.Revert) as TransactionResultRevertReceipt[];\n\nexport class RevertErrorCodes {\n  private revertReceipts: TransactionResultRevertReceipt[];\n\n  constructor(receipts: TransactionResultReceipt[]) {\n    this.revertReceipts = getRevertReceipts(receipts);\n  }\n\n  assert(detailedError: Error): void {\n    const revertError = this.getError();\n    if (revertError) {\n      revertError.cause = detailedError;\n      throw revertError;\n    }\n  }\n\n  getError(): RevertError | undefined {\n    if (!this.revertReceipts.length) {\n      return undefined;\n    }\n\n    if (this.revertReceipts.length !== 1) {\n      warn(\n        'Multiple revert receipts found, expected one. Receipts:',\n        JSON.stringify(this.revertReceipts)\n      );\n    }\n\n    return revertErrorFactory(this.revertReceipts[0]);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport type { TransactionResultRevertReceipt } from '@fuel-ts/providers';\nimport {\n  FAILED_ASSERT_EQ_SIGNAL,\n  FAILED_ASSERT_SIGNAL,\n  FAILED_REQUIRE_SIGNAL,\n  FAILED_SEND_MESSAGE_SIGNAL,\n  FAILED_TRANSFER_TO_ADDRESS_SIGNAL,\n  FAILED_UNKNOWN_SIGNAL,\n} from '@fuel-ts/transactions/configs';\n\n/**\n * Represents the possible reasons for a revert.\n */\nexport type RevertReason =\n  | 'RequireFailed'\n  | 'TransferToAddressFailed'\n  | 'SendMessageFailed'\n  | 'AssertEqFailed'\n  | 'AssertFailed'\n  | 'Unknown';\n\n/**\n * A mapping of hex codes to their corresponding revert reasons.\n */\nconst REVERT_MAP: { [signal: string]: RevertReason } = {\n  [FAILED_REQUIRE_SIGNAL]: 'RequireFailed',\n  [FAILED_TRANSFER_TO_ADDRESS_SIGNAL]: 'TransferToAddressFailed',\n  [FAILED_SEND_MESSAGE_SIGNAL]: 'SendMessageFailed',\n  [FAILED_ASSERT_EQ_SIGNAL]: 'AssertEqFailed',\n  [FAILED_ASSERT_SIGNAL]: 'AssertFailed',\n  [FAILED_UNKNOWN_SIGNAL]: 'Unknown',\n};\n\n/**\n * Decode the revert error code from the given receipt.\n *\n * @param receipt - The transaction revert receipt.\n * @returns The revert reason, or undefined if not found.\n */\nconst decodeRevertErrorCode = (\n  receipt: TransactionResultRevertReceipt\n): RevertReason | undefined => {\n  const signalHex = receipt.val.toHex();\n  return REVERT_MAP[signalHex] ? REVERT_MAP[signalHex] : undefined;\n};\n\n/**\n * @hidden\n *\n * An error class for revert errors.\n */\nexport class RevertError extends Error {\n  /**\n   * The receipt associated with the revert error.\n   */\n  receipt: TransactionResultRevertReceipt;\n\n  /**\n   * Creates a new instance of RevertError.\n   *\n   * @param receipt - The transaction revert receipt.\n   * @param reason - The revert reason.\n   */\n  constructor(receipt: TransactionResultRevertReceipt, reason: RevertReason) {\n    super(`The script reverted with reason ${reason}`);\n    this.name = 'RevertError';\n    this.receipt = receipt;\n  }\n\n  /**\n   * Returns a string representation of the RevertError.\n   *\n   * @returns The string representation of the error.\n   */\n  toString() {\n    const { id, ...r } = this.receipt;\n    return `${this.name}: ${this.message}\n    ${id}: ${JSON.stringify(r)}`;\n  }\n}\n\n/**\n * @hidden\n *\n * An error class for Require revert errors.\n */\nexport class RequireRevertError extends RevertError {\n  /**\n   * Creates a new instance of RequireRevertError.\n   *\n   * @param receipt - The transaction revert receipt.\n   * @param reason - The revert reason.\n   */\n  constructor(receipt: TransactionResultRevertReceipt, reason: RevertReason) {\n    super(receipt, reason);\n    this.name = 'RequireRevertError';\n  }\n}\n\n/**\n * @hidden\n *\n * An error class for TransferToAddress revert errors.\n */\nexport class TransferToAddressRevertError extends RevertError {\n  /**\n   * Creates a new instance of TransferToAddressRevertError.\n   *\n   * @param receipt - The transaction revert receipt.\n   * @param reason - The revert reason.\n   */\n  constructor(receipt: TransactionResultRevertReceipt, reason: RevertReason) {\n    super(receipt, reason);\n    this.name = 'TransferToAddressRevertError';\n  }\n}\n\n/**\n * @hidden\n *\n * An error class for SendMessage revert errors.\n */\nexport class SendMessageRevertError extends RevertError {\n  /**\n   * Creates a new instance of SendMessageRevertError.\n   *\n   * @param receipt - The transaction revert receipt.\n   * @param reason - The revert reason.\n   */\n  constructor(receipt: TransactionResultRevertReceipt, reason: RevertReason) {\n    super(receipt, reason);\n    this.name = 'SendMessageRevertError';\n  }\n}\n\n/**\n * @hidden\n *\n * An error class for AssertFailed revert errors.\n */\nexport class AssertFailedRevertError extends RevertError {\n  /**\n   * Creates a new instance of AssertFailedRevertError.\n   *\n   * @param receipt - The transaction revert receipt.\n   * @param reason - The revert reason.\n   */\n  constructor(receipt: TransactionResultRevertReceipt, reason: RevertReason) {\n    super(receipt, reason);\n    this.name = 'AssertFailedRevertError';\n  }\n}\n\n/**\n * @hidden\n *\n * Factory function to create the appropriate RevertError instance based on the given receipt.\n *\n * @param receipt - The transaction revert receipt.\n * @returns The RevertError instance, or undefined if the revert reason is not recognized.\n */\nexport const revertErrorFactory = (\n  receipt: TransactionResultRevertReceipt\n): RevertError | undefined => {\n  const reason = decodeRevertErrorCode(receipt);\n  if (!reason) {\n    return undefined;\n  }\n\n  switch (reason) {\n    case 'RequireFailed':\n      return new RequireRevertError(receipt, reason);\n    case 'TransferToAddressFailed':\n      return new TransferToAddressRevertError(receipt, reason);\n    case 'SendMessageFailed':\n      return new SendMessageRevertError(receipt, reason);\n    case 'AssertFailed':\n      return new AssertFailedRevertError(receipt, reason);\n    default:\n      return new RevertError(receipt, reason);\n  }\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { FunctionFragment } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractProgram } from '@fuel-ts/interfaces';\nimport type { CoinQuantity } from '@fuel-ts/providers';\nimport { coinQuantityfy } from '@fuel-ts/providers';\n\nimport type { CallConfig, CallParams } from '../types';\n\nimport { BaseInvocationScope } from './base-invocation-scope';\n\n/**\n * Represents a scope for invoking a function.\n *\n * @template TArgs - The type of the function arguments.\n * @template TReturn - The type of the return value.\n */\nexport class FunctionInvocationScope<\n  TArgs extends Array<any> = Array<any>,\n  TReturn = any\n> extends BaseInvocationScope<TReturn> {\n  protected func: FunctionFragment;\n  private callParameters?: CallParams;\n  private forward?: CoinQuantity;\n  protected args: TArgs;\n\n  /**\n   * Constructs an instance of FunctionInvocationScope.\n   *\n   * @param program - The program.\n   * @param func - The function fragment.\n   * @param args - The arguments.\n   */\n  constructor(program: AbstractProgram, func: FunctionFragment, args: TArgs) {\n    super(program, false);\n    this.func = func;\n    this.args = args || [];\n    this.setArguments(...args);\n    super.addCall(this);\n  }\n\n  /**\n   * Gets the call configuration.\n   *\n   * @returns The call configuration.\n   */\n  getCallConfig(): CallConfig<TArgs> {\n    return {\n      func: this.func,\n      program: this.program,\n      callParameters: this.callParameters,\n      txParameters: this.txParameters,\n      forward: this.forward,\n      args: this.args,\n    };\n  }\n\n  /**\n   * Sets the arguments for the function invocation.\n   *\n   * @param args - The arguments.\n   * @returns The instance of FunctionInvocationScope.\n   */\n  setArguments(...args: TArgs) {\n    this.args = args || [];\n    return this;\n  }\n\n  /**\n   * Sets the call parameters for the function invocation.\n   *\n   * @param callParams - The call parameters.\n   * @returns The instance of FunctionInvocationScope.\n   * @throws If the function is not payable and forward is set.\n   */\n  callParams(callParams: CallParams) {\n    this.callParameters = callParams;\n\n    if (callParams?.forward) {\n      if (!this.func.attributes.find((attr) => attr.name === 'payable')) {\n        throw new FuelError(\n          ErrorCode.TRANSACTION_ERROR,\n          `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`\n        );\n      }\n\n      this.forward = coinQuantityfy(callParams.forward);\n    }\n\n    // Update transaction script with new forward params\n    this.setArguments(...this.args);\n\n    // Update required coins\n    this.updateRequiredCoins();\n\n    return this;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { InputValue } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractContract, AbstractProgram } from '@fuel-ts/interfaces';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type { Provider, CoinQuantity, TransactionRequest } from '@fuel-ts/providers';\nimport { transactionRequestify, ScriptTransactionRequest } from '@fuel-ts/providers';\nimport { InputType } from '@fuel-ts/transactions';\nimport type { BaseWalletUnlocked } from '@fuel-ts/wallet';\nimport * as asm from '@fuels/vm-asm';\n\nimport { getContractCallScript } from '../contract-call-script';\nimport { POINTER_DATA_OFFSET } from '../script-request';\nimport type { ContractCall, InvocationScopeLike, TransactionCostOptions, TxParams } from '../types';\nimport { assert } from '../utils';\n\nimport { InvocationCallResult, FunctionInvocationResult } from './invocation-results';\n\n/**\n * Creates a contract call object based on the provided invocation scope.\n *\n * @param funcScope - The invocation scope containing the necessary information for the contract call.\n * @returns The contract call object.\n */\nfunction createContractCall(funcScope: InvocationScopeLike, offset: number): ContractCall {\n  const { program, args, forward, func, callParameters } = funcScope.getCallConfig();\n  const DATA_POINTER_OFFSET = funcScope.getCallConfig().func.isInputDataPointer\n    ? POINTER_DATA_OFFSET\n    : 0;\n  const data = func.encodeArguments(args as Array<InputValue>, offset + DATA_POINTER_OFFSET);\n\n  return {\n    contractId: (program as AbstractContract).id,\n    fnSelector: func.selector,\n    data,\n    isInputDataPointer: func.isInputDataPointer,\n    isOutputDataHeap: func.outputMetadata.isHeapType,\n    outputEncodedLength: func.outputMetadata.encodedLength,\n    assetId: forward?.assetId,\n    amount: forward?.amount,\n    gas: callParameters?.gasLimit,\n  };\n}\n\n/**\n * Base class for managing invocation scopes and preparing transactions.\n */\nexport class BaseInvocationScope<TReturn = any> {\n  transactionRequest: ScriptTransactionRequest;\n  protected program: AbstractProgram;\n  protected functionInvocationScopes: Array<InvocationScopeLike> = [];\n  protected txParameters?: TxParams;\n  protected requiredCoins: CoinQuantity[] = [];\n  protected isMultiCall: boolean = false;\n\n  /**\n   * Constructs an instance of BaseInvocationScope.\n   *\n   * @param program - The abstract program to be invoked.\n   * @param isMultiCall - A flag indicating whether the invocation is a multi-call.\n   */\n  constructor(program: AbstractProgram, isMultiCall: boolean) {\n    this.program = program;\n    this.isMultiCall = isMultiCall;\n\n    const provider = program.provider as Provider;\n    const { maxGasPerTx } = provider.getGasConfig();\n    this.transactionRequest = new ScriptTransactionRequest({\n      gasLimit: maxGasPerTx,\n    });\n  }\n\n  /**\n   * Getter for the contract calls.\n   *\n   * @returns An array of contract calls.\n   */\n  protected get calls() {\n    const script = getContractCallScript(this.functionInvocationScopes);\n    const provider = this.getProvider();\n    const consensusParams = provider.getChain().consensusParameters;\n    if (!consensusParams) {\n      throw new FuelError(\n        FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,\n        'Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()``'\n      );\n    }\n    const maxInputs = consensusParams.maxInputs.toNumber();\n    return this.functionInvocationScopes.map((funcScope) =>\n      createContractCall(funcScope, script.getScriptDataOffset(maxInputs))\n    );\n  }\n\n  /**\n   * Updates the script request with the current contract calls.\n   */\n  protected updateScriptRequest() {\n    const contractCallScript = getContractCallScript(this.functionInvocationScopes);\n    this.transactionRequest.setScript(contractCallScript, this.calls);\n  }\n\n  /**\n   * Updates the transaction request with the current input/output.\n   */\n  protected updateContractInputAndOutput() {\n    const calls = this.calls;\n    calls.forEach((c) => {\n      if (c.contractId) {\n        this.transactionRequest.addContractInputAndOutput(c.contractId);\n      }\n    });\n  }\n\n  /**\n   * Gets the required coins for the transaction.\n   *\n   * @returns An array of required coin quantities.\n   */\n  protected getRequiredCoins(): Array<CoinQuantity> {\n    const { gasPriceFactor } = this.getProvider().getGasConfig();\n\n    const assets = this.calls\n      .map((call) => ({\n        assetId: String(call.assetId),\n        amount: bn(call.amount || 0),\n      }))\n      .concat(this.transactionRequest.calculateFee(gasPriceFactor))\n      .filter(({ assetId, amount }) => assetId && !bn(amount).isZero());\n    return assets;\n  }\n\n  /**\n   * Updates the required coins for the transaction.\n   */\n  protected updateRequiredCoins() {\n    const assets = this.getRequiredCoins();\n    const reduceForwardCoins = (\n      requiredCoins: Map<any, CoinQuantity>,\n      { assetId, amount }: CoinQuantity\n    ) => {\n      const currentAmount = requiredCoins.get(assetId)?.amount || bn(0);\n\n      return requiredCoins.set(assetId, {\n        assetId: String(assetId),\n        amount: currentAmount.add(amount),\n      });\n    };\n    this.requiredCoins = Array.from(\n      assets.reduce(reduceForwardCoins, new Map<any, CoinQuantity>()).values()\n    );\n  }\n\n  /**\n   * Adds a single call to the invocation scope.\n   *\n   * @param funcScope - The function scope to add.\n   * @returns The current instance of the class.\n   */\n  protected addCall(funcScope: InvocationScopeLike) {\n    this.addCalls([funcScope]);\n    return this;\n  }\n\n  /**\n   * Adds multiple calls to the invocation scope.\n   *\n   * @param funcScopes - An array of function scopes to add.\n   * @returns The current instance of the class.\n   */\n  protected addCalls(funcScopes: Array<InvocationScopeLike>) {\n    this.functionInvocationScopes.push(...funcScopes);\n    this.updateContractInputAndOutput();\n    this.updateRequiredCoins();\n    return this;\n  }\n\n  /**\n   * Prepares the transaction by updating the script request, required coins, and checking the gas limit.\n   */\n  protected async prepareTransaction() {\n    // @ts-expect-error Property 'initWasm' does exist on type and is defined\n    await asm.initWasm();\n\n    // Update request scripts before call\n    this.updateScriptRequest();\n\n    // Update required coins before call\n    this.updateRequiredCoins();\n\n    // Check if gasLimit is less than the\n    // sum of all call gasLimits\n    this.checkGasLimitTotal();\n\n    if (this.program.account) {\n      await this.fundWithRequiredCoins();\n    }\n  }\n\n  /**\n   * Checks if the total gas limit is within the acceptable range.\n   */\n  protected checkGasLimitTotal() {\n    const gasLimitOnCalls = this.calls.reduce((total, call) => total.add(call.gas || 0), bn(0));\n    if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {\n      throw new FuelError(\n        ErrorCode.TRANSACTION_ERROR,\n        \"Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls.\"\n      );\n    }\n  }\n\n  /**\n   * Gets the transaction cost ny dry running the transaction.\n   *\n   * @param options - Optional transaction cost options.\n   * @returns The transaction cost details.\n   */\n  async getTransactionCost(options?: TransactionCostOptions) {\n    const provider = this.getProvider();\n\n    await this.prepareTransaction();\n    const request = transactionRequestify(this.transactionRequest);\n    request.gasPrice = bn(toNumber(request.gasPrice) || toNumber(options?.gasPrice || 0));\n    const txCost = await provider.getTransactionCost(request, options?.tolerance);\n\n    return txCost;\n  }\n\n  /**\n   * Funds the transaction with the required coins.\n   *\n   * @returns The current instance of the class.\n   */\n  async fundWithRequiredCoins() {\n    // Clean coin inputs before add new coins to the request\n    this.transactionRequest.inputs = this.transactionRequest.inputs.filter(\n      (i) => i.type !== InputType.Coin\n    );\n    const resources = await this.program.account?.getResourcesToSpend(this.requiredCoins);\n    this.transactionRequest.addResources(resources || []);\n    return this;\n  }\n\n  /**\n   * Sets the transaction parameters.\n   *\n   * @param txParams - The transaction parameters to set.\n   * @returns The current instance of the class.\n   */\n  txParams(txParams: TxParams) {\n    this.txParameters = txParams;\n    const request = this.transactionRequest;\n\n    request.gasLimit = bn(txParams.gasLimit || request.gasLimit);\n    request.gasPrice = bn(txParams.gasPrice || request.gasPrice);\n    request.addVariableOutputs(this.txParameters?.variableOutputs || 0);\n\n    return this;\n  }\n\n  /**\n   * Adds contracts to the invocation scope.\n   *\n   * @param contracts - An array of contracts to add.\n   * @returns The current instance of the class.\n   */\n  addContracts(contracts: Array<AbstractContract>) {\n    contracts.forEach((contract) => {\n      this.transactionRequest.addContractInputAndOutput(contract.id);\n      this.program.interface.updateExternalLoggedTypes(contract.id.toB256(), contract.interface);\n    });\n    return this;\n  }\n\n  /**\n   * Prepares and returns the transaction request object.\n   *\n   * @returns The prepared transaction request.\n   */\n  async getTransactionRequest(): Promise<TransactionRequest> {\n    await this.prepareTransaction();\n    return this.transactionRequest;\n  }\n\n  /**\n   * Submits a transaction.\n   *\n   * @returns The result of the function invocation.\n   */\n  async call<T = TReturn>(): Promise<FunctionInvocationResult<T>> {\n    assert(this.program.account, 'Wallet is required!');\n\n    const transactionRequest = await this.getTransactionRequest();\n    const response = await this.program.account.sendTransaction(transactionRequest);\n\n    return FunctionInvocationResult.build<T>(\n      this.functionInvocationScopes,\n      response,\n      this.isMultiCall,\n      this.program as AbstractContract\n    );\n  }\n\n  /**\n   * Simulates a transaction.\n   *\n   * @returns The result of the invocation call.\n   */\n  async simulate<T = TReturn>(): Promise<InvocationCallResult<T>> {\n    assert(this.program.account, 'Wallet is required!');\n    /**\n     * NOTE: Simulating a transaction with UTXOs validation requires the transaction\n     * to be signed by the wallet. This is only possible if the wallet is unlocked.\n     * Since there is no garantee at this point that the account instance is an unlocked wallet\n     * (BaseWalletUnlocked instance), we need to check it before run the simulation. Perhaps\n     * we should think in a redesign of the AbstractAccount class to avoid this problem.\n     */\n    const isUnlockedWallet = (<BaseWalletUnlocked>this.program.account)\n      .populateTransactionWitnessesSignature;\n\n    if (!isUnlockedWallet) {\n      return this.dryRun<T>();\n    }\n\n    const transactionRequest = await this.getTransactionRequest();\n    const result = await this.program.account.simulateTransaction(transactionRequest);\n\n    return InvocationCallResult.build<T>(this.functionInvocationScopes, result, this.isMultiCall);\n  }\n\n  /**\n   * Executes a transaction in dry run mode.\n   *\n   * @returns The result of the invocation call.\n   */\n  async dryRun<T = TReturn>(): Promise<InvocationCallResult<T>> {\n    const provider = this.getProvider();\n\n    const transactionRequest = await this.getTransactionRequest();\n    const request = transactionRequestify(transactionRequest);\n    const response = await provider.call(request, {\n      utxoValidation: false,\n    });\n\n    const result = await InvocationCallResult.build<T>(\n      this.functionInvocationScopes,\n      response,\n      this.isMultiCall\n    );\n\n    return result;\n  }\n\n  getProvider(): Provider {\n    const provider = <Provider>this.program.provider;\n\n    return provider;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { arrayify, concat } from '@ethersproject/bytes';\nimport { WORD_SIZE, U64Coder, B256Coder, ASSET_ID_LEN, CONTRACT_ID_LEN } from '@fuel-ts/abi-coder';\nimport { BaseAssetId, ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type {\n  CallResult,\n  TransactionResultCallReceipt,\n  TransactionResultReturnDataReceipt,\n  TransactionResultReturnReceipt,\n} from '@fuel-ts/providers';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport * as asm from '@fuels/vm-asm';\n\nimport { InstructionSet } from './instruction-set';\nimport type { EncodedScriptCall, ScriptResult } from './script-request';\nimport {\n  decodeCallResult,\n  ScriptRequest,\n  SCRIPT_DATA_BASE_OFFSET,\n  POINTER_DATA_OFFSET,\n} from './script-request';\nimport type { ContractCall, InvocationScopeLike } from './types';\n\ntype CallOpcodeParamsOffset = {\n  callDataOffset: number;\n  gasForwardedOffset: number;\n  amountOffset: number;\n  assetIdOffset: number;\n};\n\ntype CallOutputInfo = {\n  isHeap: boolean;\n  encodedLength: number;\n};\n\nconst DEFAULT_OPCODE_PARAMS: CallOpcodeParamsOffset = {\n  assetIdOffset: 0,\n  amountOffset: 0,\n  gasForwardedOffset: 0,\n  callDataOffset: 0,\n};\n\n// During a script execution, this script's contract id is the **null** contract id\nconst SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;\n\n// Returns the VM instructions for calling a contract method\n// We use the [`Opcode`] to call a contract: [`CALL`](Opcode::CALL)\n// pointing at the following registers:\n//\n// 0x10 Script data offset\n// 0x11 Coin amount\n// 0x12 Asset ID\n// 0x13 Gas forwarded\n//\n// These are arbitrary non-reserved registers, no special meaning\nconst getSingleCallInstructions = (\n  { callDataOffset, gasForwardedOffset, amountOffset, assetIdOffset }: CallOpcodeParamsOffset,\n  outputInfo: CallOutputInfo\n): InstructionSet => {\n  const inst = new InstructionSet(\n    asm.movi(0x10, callDataOffset),\n    asm.movi(0x11, amountOffset),\n    asm.lw(0x11, 0x11, 0),\n    asm.movi(0x12, assetIdOffset)\n  );\n\n  if (gasForwardedOffset) {\n    inst.push(\n      asm.movi(0x13, gasForwardedOffset),\n      asm.lw(0x13, 0x13, 0),\n      asm.call(0x10, 0x11, 0x12, 0x13)\n    );\n  } else {\n    inst.push(asm.call(0x10, 0x11, 0x12, asm.RegId.cgas().to_u8()));\n  }\n\n  if (outputInfo.isHeap) {\n    inst.extend([\n      // The RET register contains the pointer address of the `CALL` return (a stack\n      // address).\n      // The RETL register contains the length of the `CALL` return (=24 because the Vec/Bytes\n      // struct takes 3 WORDs). We don't actually need it unless the Vec/Bytes struct encoding\n      // changes in the compiler.\n      // Load the word located at the address contained in RET, it's a word that\n      // translates to a heap address. 0x15 is a free register.\n      asm.lw(0x15, asm.RegId.ret().to_u8(), 0),\n      // We know a Vec/Bytes struct has its third WORD contain the length of the underlying\n      // vector, so use a 2 offset to store the length in 0x16, which is a free register.\n      asm.lw(0x16, asm.RegId.ret().to_u8(), 2),\n      // The in-memory size of the type is (in-memory size of the inner type) * length\n      asm.muli(0x16, 0x16, outputInfo.encodedLength),\n      asm.retd(0x15, 0x16),\n    ]);\n  }\n\n  return inst;\n};\n// Given a list of contract calls, create the actual opcodes used to call the contract\nfunction getInstructions(offsets: CallOpcodeParamsOffset[], outputs: CallOutputInfo[]): Uint8Array {\n  if (!offsets.length) {\n    return new Uint8Array();\n  }\n\n  const multiCallInstructions = new InstructionSet();\n  for (let i = 0; i < offsets.length; i += 1) {\n    multiCallInstructions.extend(getSingleCallInstructions(offsets[i], outputs[i]).entries());\n  }\n\n  multiCallInstructions.push(asm.ret(0x01));\n  return multiCallInstructions.toBytes();\n}\n\ntype ReturnReceipt = TransactionResultReturnReceipt | TransactionResultReturnDataReceipt;\n\nconst isReturnType = (type: ReturnReceipt['type']) =>\n  type === ReceiptType.Return || type === ReceiptType.ReturnData;\n\nconst getMainCallReceipt = (\n  receipts: TransactionResultCallReceipt[],\n  contractId: string\n): TransactionResultCallReceipt | undefined =>\n  receipts.find(\n    ({ type, from, to }) =>\n      type === ReceiptType.Call && from === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId\n  );\n\nconst scriptResultDecoder =\n  (contractId: AbstractAddress, isOutputDataHeap: boolean) => (result: ScriptResult) => {\n    if (toNumber(result.code) !== 0) {\n      throw new FuelError(\n        ErrorCode.TRANSACTION_ERROR,\n        `Execution of the script associated with contract ${contractId} resulted in a non-zero exit code: ${result.code}.`\n      );\n    }\n\n    const mainCallResult = getMainCallReceipt(\n      result.receipts as TransactionResultCallReceipt[],\n      contractId.toB256()\n    );\n    const mainCallInstructionStart = bn(mainCallResult?.is);\n\n    const receipts = result.receipts as ReturnReceipt[];\n    return receipts\n      .filter(({ type }) => isReturnType(type))\n      .flatMap((receipt: ReturnReceipt, index, filtered) => {\n        if (!mainCallInstructionStart.eq(bn(receipt.is))) {\n          return [];\n        }\n        if (receipt.type === ReceiptType.Return) {\n          return [new U64Coder().encode((receipt as TransactionResultReturnReceipt).val)];\n        }\n        if (receipt.type === ReceiptType.ReturnData) {\n          const encodedScriptReturn = arrayify(receipt.data);\n          if (isOutputDataHeap && isReturnType(filtered[index + 1]?.type)) {\n            const nextReturnData: TransactionResultReturnDataReceipt = filtered[\n              index + 1\n            ] as TransactionResultReturnDataReceipt;\n            return concat([encodedScriptReturn, arrayify(nextReturnData.data)]);\n          }\n\n          return [encodedScriptReturn];\n        }\n\n        return [new Uint8Array()];\n      });\n  };\n\nexport const decodeContractCallScriptResult = (\n  callResult: CallResult,\n  contractId: AbstractAddress,\n  isOutputDataHeap: boolean,\n  logs: Array<any> = []\n): Uint8Array[] =>\n  decodeCallResult(callResult, scriptResultDecoder(contractId, isOutputDataHeap), logs);\n\nconst getCallInstructionsLength = (contractCalls: ContractCall[]): number =>\n  contractCalls.reduce(\n    (sum, call) => {\n      const offset: CallOpcodeParamsOffset = { ...DEFAULT_OPCODE_PARAMS };\n      if (call.gas) {\n        offset.gasForwardedOffset = 1;\n      }\n      const output: CallOutputInfo = {\n        isHeap: call.isOutputDataHeap,\n        encodedLength: call.outputEncodedLength,\n      };\n      return sum + getSingleCallInstructions(offset, output).byteLength();\n    },\n    asm.Instruction.size() // placeholder for single RET instruction which is added later\n  );\n\nconst getFunctionOutputInfos = (functionScopes: InvocationScopeLike[]): CallOutputInfo[] =>\n  functionScopes.map((funcScope) => {\n    const { func } = funcScope.getCallConfig();\n    return {\n      isHeap: func.outputMetadata.isHeapType,\n      encodedLength: func.outputMetadata.encodedLength,\n    };\n  });\n\nexport const getContractCallScript = (\n  functionScopes: InvocationScopeLike[]\n): ScriptRequest<ContractCall[], Uint8Array[]> =>\n  new ScriptRequest<ContractCall[], Uint8Array[]>(\n    // Script to call the contract, start with stub size matching length of calls\n    getInstructions(\n      new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS),\n      getFunctionOutputInfos(functionScopes)\n    ),\n    (contractCalls): EncodedScriptCall => {\n      const TOTAL_CALLS = contractCalls.length;\n      if (TOTAL_CALLS === 0) {\n        return { data: new Uint8Array(), script: new Uint8Array() };\n      }\n\n      // Calculate instructions length for call instructions\n      const callInstructionsLength = getCallInstructionsLength(contractCalls);\n\n      // pad length\n      const paddingLength = (8 - (callInstructionsLength % 8)) % 8;\n      const paddedInstructionsLength = callInstructionsLength + paddingLength;\n\n      // get total data offset AFTER all scripts\n      const dataOffset = SCRIPT_DATA_BASE_OFFSET + paddedInstructionsLength;\n\n      // The data for each call is ordered into segments\n      const paramOffsets: CallOpcodeParamsOffset[] = [];\n      let segmentOffset = dataOffset;\n\n      // the data about the contract output\n      const outputInfos: CallOutputInfo[] = [];\n\n      const scriptData: Uint8Array[] = [];\n      for (let i = 0; i < TOTAL_CALLS; i += 1) {\n        const call = contractCalls[i];\n\n        // store output and param offsets for asm instructions later\n        outputInfos.push({\n          isHeap: call.isOutputDataHeap,\n          encodedLength: call.outputEncodedLength,\n        });\n        paramOffsets.push({\n          gasForwardedOffset: call.gas\n            ? segmentOffset + WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE\n            : 0,\n          amountOffset: segmentOffset,\n          assetIdOffset: segmentOffset + WORD_SIZE,\n          callDataOffset: segmentOffset + WORD_SIZE + ASSET_ID_LEN,\n        });\n\n        /// script data, consisting of the following items in the given order:\n        /// 1. Amount to be forwarded `(1 * `[`WORD_SIZE`]`)`\n        scriptData.push(new U64Coder().encode(call.amount || 0));\n        /// 2. Asset ID to be forwarded ([`AssetId::LEN`])\n        scriptData.push(new B256Coder().encode(call.assetId?.toString() || BaseAssetId));\n        /// 3. Contract ID ([`ContractId::LEN`]);\n        scriptData.push(call.contractId.toBytes());\n        /// 4. Function selector `(1 * `[`WORD_SIZE`]`)`\n        scriptData.push(new U64Coder().encode(call.fnSelector));\n        /// 5. Gas to be forwarded `(1 * `[`WORD_SIZE`]`)`\n        let gasForwardedSize = 0;\n\n        if (call.gas) {\n          scriptData.push(new U64Coder().encode(call.gas));\n\n          gasForwardedSize = WORD_SIZE;\n        }\n\n        /// 6. Calldata offset (optional) `(1 * `[`WORD_SIZE`]`)`\n        // If the method call takes custom inputs or has more than\n        // one argument, we need to calculate the `call_data_offset`,\n        // which points to where the data for the custom types start in the\n        // transaction. If it doesn't take any custom inputs, this isn't necessary.\n        if (call.isInputDataPointer) {\n          const pointerInputOffset = segmentOffset + POINTER_DATA_OFFSET + gasForwardedSize;\n          scriptData.push(new U64Coder().encode(pointerInputOffset));\n        }\n\n        /// 7. Encoded arguments (optional) (variable length)\n        const args = arrayify(call.data);\n        scriptData.push(args);\n\n        // move offset for next call\n        segmentOffset = dataOffset + concat(scriptData).byteLength;\n      }\n\n      // get asm instructions\n      const script = getInstructions(paramOffsets, outputInfos);\n      const finalScriptData = concat(scriptData);\n      return { data: finalScriptData, script };\n    },\n    () => [new Uint8Array()]\n  );\n","import { concat, hexlify } from '@ethersproject/bytes';\nimport type * as asm from '@fuels/vm-asm';\n\n/**\n * A wrapper around fuel-asm to make dynamic instructions and convert to different formats\n */\nexport class InstructionSet {\n  #operations: asm.Instruction[];\n\n  constructor(...args: asm.Instruction[]) {\n    this.#operations = args || [];\n  }\n\n  entries(): asm.Instruction[] {\n    return this.#operations;\n  }\n\n  push(...args: asm.Instruction[]) {\n    this.#operations.push(...args);\n  }\n\n  concat(ops: asm.Instruction[]): asm.Instruction[] {\n    return this.#operations.concat(ops);\n  }\n\n  extend(ops: asm.Instruction[]) {\n    this.#operations.push(...ops);\n  }\n\n  toBytes(): Uint8Array {\n    return concat(\n      this.#operations.reduce((instructions, line) => {\n        instructions.push(line.to_bytes());\n        return instructions;\n      }, [] as Uint8Array[])\n    );\n  }\n\n  toHex(): string {\n    return hexlify(this.toBytes());\n  }\n\n  toString() {\n    return `Program:\\n${JSON.stringify(this.#operations, null, 2)}`;\n  }\n\n  byteLength() {\n    return this.toBytes().byteLength;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport {\n  VM_TX_MEMORY,\n  ASSET_ID_LEN,\n  CONTRACT_ID_LEN,\n  SCRIPT_FIXED_SIZE,\n  WORD_SIZE,\n  calculateVmTxMemory,\n} from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport type {\n  TransactionResultReturnDataReceipt,\n  TransactionResultRevertReceipt,\n  CallResult,\n  TransactionResultReceipt,\n  TransactionResultReturnReceipt,\n  TransactionResultScriptResultReceipt,\n  TransactionResult,\n} from '@fuel-ts/providers';\nimport type { ReceiptScriptResult } from '@fuel-ts/transactions';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport { ScriptResultDecoderError } from './errors';\nimport type { CallConfig } from './types';\n\nexport const SCRIPT_DATA_BASE_OFFSET = VM_TX_MEMORY + SCRIPT_FIXED_SIZE;\nexport const POINTER_DATA_OFFSET =\n  WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;\n/**\n * Represents a script result, containing information about the script execution.\n */\nexport type ScriptResult = {\n  code: BN;\n  gasUsed: BN;\n  receipts: TransactionResultReceipt[];\n  scriptResultReceipt: TransactionResultScriptResultReceipt;\n  returnReceipt:\n    | TransactionResultReturnReceipt\n    | TransactionResultReturnDataReceipt\n    | TransactionResultRevertReceipt;\n  callResult: CallResult;\n};\n\n/**\n * Converts a CallResult to a ScriptResult by extracting relevant information.\n *\n * @param callResult - The CallResult from the script call.\n * @returns The converted ScriptResult.\n */\nfunction callResultToScriptResult(callResult: CallResult): ScriptResult {\n  const receipts = [...callResult.receipts];\n\n  let scriptResultReceipt: ReceiptScriptResult | undefined;\n  let returnReceipt:\n    | TransactionResultReturnReceipt\n    | TransactionResultReturnDataReceipt\n    | TransactionResultRevertReceipt\n    | undefined;\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.ScriptResult) {\n      scriptResultReceipt = receipt;\n    } else if (\n      receipt.type === ReceiptType.Return ||\n      receipt.type === ReceiptType.ReturnData ||\n      receipt.type === ReceiptType.Revert\n    ) {\n      returnReceipt = receipt;\n    }\n  });\n\n  if (!scriptResultReceipt) {\n    throw new FuelError(\n      ErrorCode.TRANSACTION_ERROR,\n      `The script call result does not contain a 'scriptResultReceipt'.`\n    );\n  }\n\n  if (!returnReceipt) {\n    throw new FuelError(\n      ErrorCode.TRANSACTION_ERROR,\n      `The script call result does not contain a 'returnReceipt'.`\n    );\n  }\n\n  const scriptResult: ScriptResult = {\n    code: scriptResultReceipt.result,\n    gasUsed: scriptResultReceipt.gasUsed,\n    receipts,\n    scriptResultReceipt,\n    returnReceipt,\n    callResult,\n  };\n\n  return scriptResult;\n}\n\n/**\n * Decodes a CallResult using the provided decoder function.\n *\n * @param callResult - The CallResult to decode.\n * @param decoder - The decoding function to apply on the ScriptResult.\n * @param logs - Optional logs associated with the decoding.\n * @returns The decoded result.\n * @throws Throws an error if decoding fails.\n */\nexport function decodeCallResult<TResult>(\n  callResult: CallResult,\n  decoder: (scriptResult: ScriptResult) => TResult,\n  logs: Array<any> = []\n): TResult {\n  try {\n    const scriptResult = callResultToScriptResult(callResult);\n    return decoder(scriptResult);\n  } catch (error) {\n    throw new ScriptResultDecoderError(\n      callResult as TransactionResult,\n      (error as Error).message,\n      logs\n    );\n  }\n}\n\n/**\n * Converts a CallResult to an invocation result based on the provided call configuration.\n *\n * @param callResult - The CallResult from the script call.\n * @param call - The call configuration.\n * @param logs - Optional logs associated with the decoding.\n * @returns The decoded invocation result.\n */\nexport function callResultToInvocationResult<TReturn>(\n  callResult: CallResult,\n  call: CallConfig,\n  logs?: unknown[]\n): TReturn {\n  return decodeCallResult(\n    callResult,\n    (scriptResult: ScriptResult) => {\n      if (scriptResult.returnReceipt.type === ReceiptType.Revert) {\n        throw new FuelError(\n          ErrorCode.SCRIPT_REVERTED,\n          `Script Reverted. Logs: ${JSON.stringify(logs)}`\n        );\n      }\n\n      if (\n        scriptResult.returnReceipt.type !== ReceiptType.Return &&\n        scriptResult.returnReceipt.type !== ReceiptType.ReturnData\n      ) {\n        const { type } = scriptResult.returnReceipt;\n        throw new FuelError(\n          ErrorCode.SCRIPT_REVERTED,\n          `Script Return Type [${type}] Invalid. Logs: ${JSON.stringify({\n            logs,\n            receipt: scriptResult.returnReceipt,\n          })}`\n        );\n      }\n\n      let value;\n      if (scriptResult.returnReceipt.type === ReceiptType.Return) {\n        value = scriptResult.returnReceipt.val;\n      }\n      if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {\n        const decoded = call.func.decodeOutput(scriptResult.returnReceipt.data);\n        value = decoded[0];\n      }\n\n      return value as TReturn;\n    },\n    logs\n  );\n}\n\nexport type EncodedScriptCall = Uint8Array | { data: Uint8Array; script: Uint8Array };\n\n/**\n * `ScriptRequest` provides functionality to encode and decode script data and results.\n *\n * @template TData - Type of the script data.\n * @template TResult - Type of the script result.\n */\nexport class ScriptRequest<TData = void, TResult = void> {\n  /**\n   * The bytes of the script.\n   */\n  bytes: Uint8Array;\n\n  /**\n   * A function to encode the script data.\n   */\n  scriptDataEncoder: (data: TData) => EncodedScriptCall;\n\n  /**\n   * A function to decode the script result.\n   */\n  scriptResultDecoder: (scriptResult: ScriptResult) => TResult;\n\n  /**\n   * Creates an instance of the ScriptRequest class.\n   *\n   * @param bytes - The bytes of the script.\n   * @param scriptDataEncoder - The script data encoder function.\n   * @param scriptResultDecoder - The script result decoder function.\n   */\n  constructor(\n    bytes: BytesLike,\n    scriptDataEncoder: (data: TData) => EncodedScriptCall,\n    scriptResultDecoder: (scriptResult: ScriptResult) => TResult\n  ) {\n    this.bytes = arrayify(bytes);\n    this.scriptDataEncoder = scriptDataEncoder;\n    this.scriptResultDecoder = scriptResultDecoder;\n  }\n\n  /**\n   * Gets the script data offset for the given bytes.\n   *\n   * @param byteLength - The byte length of the script.\n   * @param maxInputs - The maxInputs value from the chain's consensus params.\n   * @returns The script data offset.\n   */\n  static getScriptDataOffsetWithScriptBytes(byteLength: number, maxInputs: number): number {\n    const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;\n    return scriptDataBaseOffset + byteLength;\n  }\n\n  /**\n   * Gets the script data offset.\n   *\n   * @param maxInputs - The maxInputs value from the chain's consensus params.\n   * @returns The script data offset.\n   */\n  getScriptDataOffset(maxInputs: number) {\n    return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);\n  }\n\n  /**\n   * Encodes the data for a script call.\n   *\n   * @param data - The script data.\n   * @returns The encoded data.\n   */\n  encodeScriptData(data: TData): Uint8Array {\n    const callScript = this.scriptDataEncoder(data);\n    // if Uint8Array\n    if (ArrayBuffer.isView(callScript)) {\n      return callScript;\n    }\n\n    // object\n    this.bytes = arrayify(callScript.script);\n    return callScript.data;\n  }\n\n  /**\n   * Decodes the result of a script call.\n   *\n   * @param callResult - The CallResult from the script call.\n   * @param logs - Optional logs associated with the decoding.\n   * @returns The decoded result.\n   */\n  decodeCallResult(callResult: CallResult, logs: Array<any> = []): TResult {\n    return decodeCallResult(callResult, this.scriptResultDecoder, logs);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable max-classes-per-file */\nimport type { Interface } from '@fuel-ts/abi-coder';\nimport type { AbstractContract, AbstractProgram } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  CallResult,\n  TransactionResponse,\n  TransactionResult,\n  TransactionResultReceipt,\n} from '@fuel-ts/providers';\nimport { getDecodedLogs } from '@fuel-ts/providers';\nimport type { ReceiptScriptResult } from '@fuel-ts/transactions';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport { decodeContractCallScriptResult } from '../contract-call-script';\nimport { callResultToInvocationResult } from '../script-request';\nimport type { CallConfig, InvocationScopeLike } from '../types';\n\n/**\n * Calculates the gas usage from a CallResult.\n *\n * @param callResult - The CallResult containing receipt data.\n * @returns The gas usage.\n */\nfunction getGasUsage(callResult: CallResult) {\n  const scriptResult = callResult.receipts.find((r) => r.type === ReceiptType.ScriptResult) as\n    | ReceiptScriptResult\n    | undefined;\n  return scriptResult?.gasUsed || bn(0);\n}\n\n/**\n * Represents the result of a function invocation, with decoded logs and gas usage.\n *\n * @template T - The type of the returned value.\n */\nexport class InvocationResult<T = any> {\n  readonly functionScopes: Array<InvocationScopeLike>;\n  readonly isMultiCall: boolean;\n  readonly gasUsed: BN;\n  readonly value: T;\n\n  /**\n   * Constructs an instance of InvocationResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param callResult - The call result.\n   * @param isMultiCall - Whether it's a multi-call.\n   */\n  constructor(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    callResult: CallResult,\n    isMultiCall: boolean\n  ) {\n    this.functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];\n    this.isMultiCall = isMultiCall;\n    this.value = this.getDecodedValue(callResult);\n    this.gasUsed = getGasUsage(callResult);\n  }\n\n  /**\n   * Gets the first call config.\n   *\n   * @returns The first call config.\n   */\n  private getFirstCallConfig(): CallConfig | undefined {\n    if (!this.functionScopes[0]) {\n      return undefined;\n    }\n\n    return this.functionScopes[0].getCallConfig();\n  }\n\n  /**\n   * Decodes the value from the call result.\n   *\n   * @param callResult - The call result.\n   * @returns The decoded value.\n   */\n  protected getDecodedValue(callResult: CallResult) {\n    const logs = this.getDecodedLogs(callResult.receipts);\n    const callConfig = this.getFirstCallConfig();\n    if (this.functionScopes.length === 1 && callConfig && 'bytes' in callConfig.program) {\n      return callResultToInvocationResult<T>(callResult, callConfig, logs);\n    }\n\n    const encodedResults = decodeContractCallScriptResult(\n      callResult,\n      (callConfig?.program as AbstractContract).id,\n      callConfig?.func.outputMetadata.isHeapType || false,\n      logs\n    );\n    const returnValues = encodedResults.map((encodedResult, i) => {\n      const { func } = this.functionScopes[i].getCallConfig();\n      return func.decodeOutput(encodedResult)?.[0];\n    });\n    return (this.isMultiCall ? returnValues : returnValues?.[0]) as T;\n  }\n\n  /**\n   * Decodes the logs from the receipts.\n   *\n   * @param receipts - The transaction result receipts.\n   * @returns The decoded logs.\n   */\n  protected getDecodedLogs(receipts: Array<TransactionResultReceipt>) {\n    const callConfig = this.getFirstCallConfig();\n    if (!callConfig) {\n      return [];\n    }\n\n    const { program } = callConfig;\n    return getDecodedLogs(receipts, program.interface as Interface);\n  }\n}\n\n/**\n * Represents the result of a function invocation with transaction details.\n *\n * @template T - The type of the returned value.\n * @template TTransactionType - The type of the transaction.\n */\nexport class FunctionInvocationResult<\n  T = any,\n  TTransactionType = void\n> extends InvocationResult<T> {\n  readonly transactionId: string;\n  readonly transactionResponse: TransactionResponse;\n  readonly transactionResult: TransactionResult<TTransactionType>;\n  readonly program: AbstractProgram;\n  readonly logs!: Array<any>;\n\n  /**\n   * Constructs an instance of FunctionInvocationResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param transactionResponse - The transaction response.\n   * @param transactionResult - The transaction result.\n   * @param program - The program.\n   * @param isMultiCall - Whether it's a multi-call.\n   */\n  constructor(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    transactionResponse: TransactionResponse,\n    transactionResult: TransactionResult<TTransactionType>,\n    program: AbstractProgram,\n    isMultiCall: boolean\n  ) {\n    super(funcScopes, transactionResult, isMultiCall);\n    this.transactionResponse = transactionResponse;\n    this.transactionResult = transactionResult;\n    this.transactionId = this.transactionResponse.id;\n    this.program = program;\n    this.logs = this.getDecodedLogs(transactionResult.receipts);\n  }\n\n  /**\n   * Builds an instance of FunctionInvocationResult.\n   *\n   * @param funcScope - The function scope.\n   * @param transactionResponse - The transaction response.\n   * @param isMultiCall - Whether it's a multi-call.\n   * @param program - The program.\n   * @returns The function invocation result.\n   */\n  static async build<T, TTransactionType = void>(\n    funcScope: InvocationScopeLike | Array<InvocationScopeLike>,\n    transactionResponse: TransactionResponse,\n    isMultiCall: boolean,\n    program: AbstractProgram\n  ) {\n    const txResult = await transactionResponse.waitForResult<TTransactionType>();\n    const fnResult = new FunctionInvocationResult<T, TTransactionType>(\n      funcScope,\n      transactionResponse,\n      txResult,\n      program,\n      isMultiCall\n    );\n    return fnResult;\n  }\n}\n\n/**\n * Represents the result of an invocation call.\n *\n * @template T - The type of the returned value.\n */\nexport class InvocationCallResult<T = any> extends InvocationResult<T> {\n  readonly callResult: CallResult;\n\n  /**\n   * Constructs an instance of InvocationCallResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param callResult - The call result.\n   * @param isMultiCall - Whether it's a multi-call.\n   */\n  constructor(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    callResult: CallResult,\n    isMultiCall: boolean\n  ) {\n    super(funcScopes, callResult, isMultiCall);\n    this.callResult = callResult;\n  }\n\n  /**\n   * Builds an instance of InvocationCallResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param callResult - The call result.\n   * @param isMultiCall - Whether it's a multi-call.\n   * @returns The invocation call result.\n   */\n  static async build<T>(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    callResult: CallResult,\n    isMultiCall: boolean\n  ) {\n    const fnResult = await new InvocationCallResult<T>(funcScopes, callResult, isMultiCall);\n    return fnResult;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractContract } from '@fuel-ts/interfaces';\n\nimport { BaseInvocationScope } from './base-invocation-scope';\nimport type { FunctionInvocationScope } from './invocation-scope';\n\n/**\n * Represents a scope for invoking multiple calls.\n *\n * @template TReturn - The type of the return value.\n */\nexport class MultiCallInvocationScope<TReturn = any> extends BaseInvocationScope<TReturn> {\n  /**\n   * Constructs an instance of MultiCallInvocationScope.\n   *\n   * @param contract - The contract.\n   * @param funcScopes - An array of function invocation scopes.\n   */\n  constructor(contract: AbstractContract, funcScopes: Array<FunctionInvocationScope>) {\n    super(contract, true);\n    this.addCalls(funcScopes);\n    this.validateHeapTypeReturnCalls();\n  }\n\n  /**\n   * Adds a single function invocation scope to the multi-call invocation scope.\n   *\n   * @param funcScope - The function invocation scope.\n   * @returns The instance of MultiCallInvocationScope.\n   */\n  addCall(funcScope: FunctionInvocationScope) {\n    return super.addCalls([funcScope]);\n  }\n\n  /**\n   * Adds multiple function invocation scopes to the multi-call invocation scope.\n   *\n   * @param funcScopes - An array of function invocation scopes.\n   * @returns The instance of MultiCallInvocationScope.\n   */\n  addCalls(funcScopes: Array<FunctionInvocationScope>) {\n    return super.addCalls(funcScopes);\n  }\n\n  private validateHeapTypeReturnCalls() {\n    let heapOutputIndex = -1;\n    let numberOfHeaps = 0;\n\n    this.calls.forEach((call, callIndex) => {\n      const { isOutputDataHeap } = call;\n\n      if (isOutputDataHeap) {\n        heapOutputIndex = callIndex;\n\n        if (++numberOfHeaps > 1) {\n          throw new FuelError(\n            ErrorCode.INVALID_MULTICALL,\n            'A multicall can have only one call that returns a heap type.'\n          );\n        }\n      }\n    });\n\n    const hasHeapTypeReturn = heapOutputIndex !== -1;\n    const isOnLastCall = heapOutputIndex === this.calls.length - 1;\n\n    if (hasHeapTypeReturn && !isOnLastCall) {\n      throw new FuelError(\n        ErrorCode.INVALID_MULTICALL,\n        'In a multicall, the contract call returning a heap type must be the last call.'\n      );\n    }\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport type { FunctionFragment, JsonAbi } from '@fuel-ts/abi-coder';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport { Address } from '@fuel-ts/address';\nimport type { AbstractAddress, AbstractContract } from '@fuel-ts/interfaces';\nimport type { Provider } from '@fuel-ts/providers';\nimport type { Account } from '@fuel-ts/wallet';\n\nimport { FunctionInvocationScope } from './functions/invocation-scope';\nimport { MultiCallInvocationScope } from './functions/multicall-scope';\nimport type { InvokeFunctions } from './types';\n\n/**\n * `Contract` provides a way to interact with the contract program type.\n */\nexport default class Contract implements AbstractContract {\n  /**\n   * The unique contract identifier.\n   */\n  id!: AbstractAddress;\n\n  /**\n   * The provider for interacting with the contract.\n   */\n  provider!: Provider;\n\n  /**\n   * The contract's ABI interface.\n   */\n  interface!: Interface;\n\n  /**\n   * The account associated with the contract, if available.\n   */\n  account!: Account | null;\n\n  /**\n   * A collection of functions available on the contract.\n   */\n  functions: InvokeFunctions = {};\n\n  /**\n   * Creates an instance of the Contract class.\n   *\n   * @param id - The contract's address.\n   * @param abi - The contract's ABI (JSON ABI or Interface instance).\n   * @param accountOrProvider - The account or provider for interaction.\n   */\n  constructor(\n    id: string | AbstractAddress,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider\n  ) {\n    this.interface = abi instanceof Interface ? abi : new Interface(abi);\n    this.id = Address.fromAddressOrString(id);\n\n    /**\n      Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` have a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n        - ./contract-factory.ts\n\n      @see ContractFactory\n    */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n\n    Object.keys(this.interface.functions).forEach((name) => {\n      const fragment = this.interface.getFunction(name);\n      Object.defineProperty(this.functions, fragment.name, {\n        value: this.buildFunction(fragment),\n        writable: false,\n      });\n    });\n  }\n\n  /**\n   * Build a function invocation scope for the provided function fragment.\n   *\n   * @param func - The function fragment to build a scope for.\n   * @returns A function that creates a FunctionInvocationScope.\n   */\n  buildFunction(func: FunctionFragment) {\n    return (...args: Array<unknown>) => new FunctionInvocationScope(this, func, args);\n  }\n\n  /**\n   * Create a multi-call invocation scope for the provided function invocation scopes.\n   *\n   * @param calls - An array of FunctionInvocationScopes to execute in a batch.\n   * @returns A MultiCallInvocationScope instance.\n   */\n  multiCall(calls: Array<FunctionInvocationScope>) {\n    return new MultiCallInvocationScope(this, calls);\n  }\n\n  /**\n   * Get the balance for a given asset ID for this contract.\n   *\n   * @param assetId - The specified asset ID.\n   * @returns The balance of the contract for the specified asset.\n   */\n  // #region contract-balance-1\n  getBalance(assetId: BytesLike) {\n    return this.provider.getContractBalance(this.id, assetId);\n  }\n  // #endregion contract-balance-1\n}\n"],"mappings":"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","names":["ReceiptType","ReceiptType","ErrorCode","FuelError","ErrorCode","FuelError","bn","toNumber","asm","arrayify","concat","WORD_SIZE","ASSET_ID_LEN","CONTRACT_ID_LEN","ErrorCode","FuelError","ReceiptType","ErrorCode","FuelError","ReceiptType","ReceiptType","FuelError","ErrorCode","call","scriptResultDecoder","ReceiptType","FuelError","ErrorCode","arrayify","concat","call","WORD_SIZE","ASSET_ID_LEN","CONTRACT_ID_LEN","bn","ReceiptType","ReceiptType","bn","FuelError","call","bn","ErrorCode","toNumber","FuelError","ErrorCode","ErrorCode","FuelError","call","FuelError","ErrorCode"]}