import type { BytesLike } from '@ethersproject/bytes';
import type { InputValue } from './coders/abstract-coder';
import { FunctionFragment } from './function-fragment';
import type { JsonAbi, JsonAbiConfigurable } from './json-abi';
export declare class Interface<TAbi extends JsonAbi = JsonAbi> {
    readonly functions: Record<string, FunctionFragment>;
    readonly configurables: Record<string, JsonAbiConfigurable>;
    private externalLoggedTypes;
    readonly jsonAbi: TAbi;
    constructor(jsonAbi: TAbi);
    /**
     * Returns function fragment for a dynamic input.
     * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment
     */
    getFunction(nameOrSignatureOrSelector: string): FunctionFragment;
    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any;
    encodeFunctionData(functionFragment: FunctionFragment | string, values: Array<InputValue>, offset?: number): Uint8Array;
    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any;
    decodeLog(data: BytesLike, logId: number, receiptId: string): any;
    updateExternalLoggedTypes(id: string, loggedTypes: Interface): void;
    encodeConfigurable(name: string, value: InputValue): Uint8Array;
    getTypeById(typeId: number): import("./json-abi").JsonAbiType;
}
//# sourceMappingURL=interface.d.ts.map