{"version":3,"sources":["../src/coders/abstract-coder.ts","../src/coders/array.ts","../src/utilities.ts","../src/coders/u64.ts","../src/constants.ts","../src/coders/b256.ts","../src/coders/b512.ts","../src/coders/boolean.ts","../src/coders/enum.ts","../src/coders/number.ts","../src/coders/string.ts","../src/coders/struct.ts","../src/coders/option.ts","../src/coders/tuple.ts","../src/coders/vec.ts","../src/interface.ts","../src/abi-coder.ts","../src/coders/byte.ts","../src/coders/raw-slice.ts","../src/resolved-abi-type.ts","../src/function-fragment.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { FuelError, type ErrorCode } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\n\nimport type { Option } from './option';\n\ntype Primitive = string | number | boolean;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue<T = void> =\n  | Primitive\n  | BN\n  | Option<T>\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  throwError(errorCode: ErrorCode, message: string): never {\n    throw new FuelError(errorCode, message);\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { ErrorCode } from '@fuel-ts/errors';\n\nimport { concatWithDynamicData } from '../utilities';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport { Coder } from './abstract-coder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    if (this.length !== value.length) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { concat, arrayify } from '@ethersproject/bytes';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { U64Coder } from './coders/u64';\nimport { BYTES_CODER_TYPE, VEC_CODER_TYPE, WORD_SIZE } from './constants';\n\nexport type DynamicData = {\n  [pointerIndex: number]: Uint8ArrayWithDynamicData;\n};\n\nexport type Uint8ArrayWithDynamicData = Uint8Array & {\n  dynamicData?: DynamicData;\n};\n\nconst VEC_PROPERTY_SPACE = 3; // ptr + cap + length\nexport const BASE_VECTOR_OFFSET = VEC_PROPERTY_SPACE * WORD_SIZE;\n\nconst RAW_SLICE_PROPERTY_SPACE = 2; // ptr + length\nexport const BASE_RAW_SLICE_OFFSET = RAW_SLICE_PROPERTY_SPACE * WORD_SIZE;\n\n// this is a fork of @ethersproject/bytes:concat\n// this collects individual dynamicData data and relocates it to top level\nexport function concatWithDynamicData(items: ReadonlyArray<BytesLike>): Uint8ArrayWithDynamicData {\n  const topLevelData: DynamicData = {};\n\n  let totalIndex = 0;\n  const objects = items.map((item) => {\n    const dynamicData = (item as Uint8ArrayWithDynamicData).dynamicData;\n    if (dynamicData) {\n      Object.entries(dynamicData).forEach(([pointerIndex, vData]) => {\n        topLevelData[parseInt(pointerIndex, 10) + totalIndex] = vData;\n      });\n    }\n\n    const byteArray = arrayify(item);\n    totalIndex += byteArray.byteLength / WORD_SIZE;\n\n    return byteArray;\n  });\n\n  const length = objects.reduce((accum, item) => accum + item.length, 0);\n  const result: Uint8ArrayWithDynamicData = new Uint8Array(length);\n\n  objects.reduce((offset, object) => {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n\n  // store vector data and pointer indices, but only if data exist\n  if (Object.keys(topLevelData).length) {\n    result.dynamicData = topLevelData;\n  }\n\n  return result;\n}\n\nexport function unpackDynamicData(\n  results: Uint8ArrayWithDynamicData,\n  baseOffset: number,\n  dataOffset: number\n): Uint8Array {\n  if (!results.dynamicData) {\n    return concat([results]);\n  }\n\n  let cumulativeDynamicByteLength = 0;\n  let updatedResults = results;\n  Object.entries(results.dynamicData).forEach(([pointerIndex, vData]) => {\n    // update value of pointer\n    const pointerOffset = parseInt(pointerIndex, 10) * WORD_SIZE;\n    const adjustedValue = new U64Coder().encode(\n      dataOffset + baseOffset + cumulativeDynamicByteLength\n    );\n    updatedResults.set(adjustedValue, pointerOffset);\n\n    // append dynamic data at the end\n    const dataToAppend = vData.dynamicData\n      ? // unpack child dynamic data\n        unpackDynamicData(\n          vData,\n          baseOffset,\n          dataOffset + vData.byteLength + cumulativeDynamicByteLength\n        )\n      : vData;\n    updatedResults = concat([updatedResults, dataToAppend]);\n\n    cumulativeDynamicByteLength += dataToAppend.byteLength;\n  });\n\n  return updatedResults;\n}\n\n/**\n * Turns:\n  Uint8Array(24) [\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 24\n  ]\n\n  Into:\n  Array [\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 1\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 2\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 24\n    ]\n  ]\n *\n */\nexport const chunkByLength = (data: Uint8Array, length = WORD_SIZE): Uint8Array[] => {\n  const chunks = [];\n  let offset = 0;\n  let chunk = data.slice(offset, offset + length);\n  while (chunk.length) {\n    chunks.push(chunk);\n    offset += length;\n    chunk = data.slice(offset, offset + length);\n  }\n\n  return chunks;\n};\n\n/**\n * Checks if a given type is a pointer type\n * See: https://github.com/FuelLabs/sway/issues/1368\n */\nexport const isPointerType = (type: string) => {\n  switch (type) {\n    case 'u8':\n    case 'u16':\n    case 'u32':\n    case 'u64':\n    case 'bool': {\n      return false;\n    }\n    default: {\n      return true;\n    }\n  }\n};\n\nexport const isHeapType = (type: string) => type === VEC_CODER_TYPE || type === BYTES_CODER_TYPE;\n\nexport function findOrThrow<T>(\n  arr: readonly T[],\n  predicate: (val: T) => boolean,\n  throwFn: () => never = () => {\n    throw new FuelError(ErrorCode.ELEMENT_NOT_FOUND, 'Element not found in the array.');\n  }\n): T {\n  const found = arr.find(predicate);\n  if (found === undefined) throwFn();\n\n  return found;\n}\n","import { ErrorCode } from '@fuel-ts/errors';\nimport type { BN, BNInput } from '@fuel-ts/math';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from './abstract-coder';\n\nexport class U64Coder extends Coder<BNInput, BN> {\n  constructor() {\n    super('u64', 'u64', 8);\n  }\n\n  encode(value: BNInput): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value, 8);\n    } catch (error) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n\n    return bytes;\n  }\n\n  decode(data: Uint8Array, offset: number): [BN, number] {\n    let bytes = data.slice(offset, offset + 8);\n    bytes = bytes.slice(0, 8);\n\n    return [bn(bytes), offset + 8];\n  }\n}\n","export const OPTION_CODER_TYPE = 'enum Option';\nexport const VEC_CODER_TYPE = 'struct Vec';\nexport const BYTES_CODER_TYPE = 'struct Bytes';\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\nexport const genericRegEx = /^generic (?<name>\\w+)$/;\n\nexport const WORD_SIZE = 8;\nexport const BYTES_32 = 32;\nexport const MAX_INPUTS = 255;\n\nexport const ASSET_ID_LEN = BYTES_32;\nexport const CONTRACT_ID_LEN = BYTES_32;\nexport const ADDRESS_LEN = BYTES_32;\nexport const NONCE_LEN = BYTES_32;\nexport const UTXO_LEN = WORD_SIZE * 5;\nexport const TX_POINTER_LEN = WORD_SIZE * 2;\n\nexport const calculateVmTxMemory = ({ maxInputs }: { maxInputs: number }) =>\n  BYTES_32 + // Tx ID\n  WORD_SIZE + // Tx size\n  // Asset ID/Balance coin input pairs\n  maxInputs * (ASSET_ID_LEN + WORD_SIZE);\n\n// VM_TX_MEMORY = 10240\nexport const VM_TX_MEMORY =\n  BYTES_32 + // Tx ID\n  WORD_SIZE + // Tx size\n  // Asset ID/Balance coin input pairs\n  MAX_INPUTS * (ASSET_ID_LEN + WORD_SIZE);\n\n// SCRIPT_FIXED_SIZE = 104\nexport const SCRIPT_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  WORD_SIZE + // Gas price\n  WORD_SIZE + // Gas limit\n  WORD_SIZE + // Maturity\n  WORD_SIZE + // Script size\n  WORD_SIZE + // Script data size\n  WORD_SIZE + // Inputs size\n  WORD_SIZE + // Outputs size\n  WORD_SIZE + // Witnesses size\n  BYTES_32; // Receipts root\n\n// INPUT_COIN_FIXED_SIZE = 176\nexport const INPUT_COIN_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  UTXO_LEN + // Utxo Length\n  ADDRESS_LEN + // Owner\n  WORD_SIZE + // Amount\n  ASSET_ID_LEN + // Asset id\n  TX_POINTER_LEN + // TxPointer\n  WORD_SIZE + // Witnesses index\n  WORD_SIZE + // Maturity\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n\n// INPUT_MESSAGE_FIXED_SIZE = 168\nexport const INPUT_MESSAGE_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  ADDRESS_LEN + // Sender\n  ADDRESS_LEN + // Recipient\n  WORD_SIZE + // Amount\n  NONCE_LEN + // Nonce\n  WORD_SIZE + // witness_index\n  WORD_SIZE + // Data size\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n","import { arrayify } from '@ethersproject/bytes';\nimport { ErrorCode } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\n\nimport { Coder } from './abstract-coder';\n\nexport class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', 32);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== 32) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let bytes = data.slice(offset, offset + 32);\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n    if (bytes.length !== 32) {\n      this.throwError(ErrorCode.DECODE_ERROR, `'Invalid size for b256'.`);\n    }\n    return [toHex(bytes, 32), offset + 32];\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { ErrorCode } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\n\nimport { Coder } from './abstract-coder';\n\nexport class B512Coder extends Coder<string, string> {\n  constructor() {\n    super('b512', 'struct B512', 64);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== 64) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let bytes = data.slice(offset, offset + 64);\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(64);\n    }\n    if (bytes.length !== 64) {\n      this.throwError(ErrorCode.DECODE_ERROR, `Invalid size for b512.`);\n    }\n    return [toHex(bytes, 64), offset + 64];\n  }\n}\n","import { ErrorCode } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from './abstract-coder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  constructor() {\n    super('boolean', 'boolean', 8);\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n    if (!isTrueBool) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return toBytes(value ? 1 : 0, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    const bytes = bn(data.slice(offset, offset + 8));\n    if (bytes.isZero()) {\n      return [false, offset + 8];\n    }\n    if (!bytes.eq(bn(1))) {\n      this.throwError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n    return [true, offset + 8];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { concatWithDynamicData } from '../utilities';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport { Coder } from './abstract-coder';\nimport { U64Coder } from './u64';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nconst isFullyNativeEnum = (enumCoders: { [s: string]: unknown } | ArrayLike<unknown>): boolean =>\n  Object.values(enumCoders).every(\n    // @ts-expect-error complicated types\n    ({ type, coders }) => type === '()' && JSON.stringify(coders) === JSON.stringify([])\n  );\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: U64Coder;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new U64Coder();\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  #encodeNativeEnum(value: string): Uint8Array {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (typeof value === 'string' && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'A field for the case must be provided.');\n    }\n    if (empty.length !== 0) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'Only one field must be provided.');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concatWithDynamicData([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n\n    let decoded;\n    [decoded, newOffset] = new U64Coder().decode(data, newOffset);\n    const caseIndex = toNumber(decoded);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n\n    const valueCoder = this.coders[caseKey];\n    const padding = this.#encodedValueSize - valueCoder.encodedLength;\n    newOffset += padding;\n    [decoded, newOffset] = valueCoder.decode(data, newOffset);\n\n    if (isFullyNativeEnum(this.coders)) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from './abstract-coder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32';\n\nexport class NumberCoder extends Coder<number, number> {\n  // This is to align the bits to the total bytes\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers\n  length: number;\n  baseType: NumberCoderType;\n\n  constructor(baseType: NumberCoderType) {\n    super('number', baseType, 8);\n    this.baseType = baseType;\n    switch (baseType) {\n      case 'u8':\n        this.length = 1;\n        break;\n      case 'u16':\n        this.length = 2;\n        break;\n      case 'u32':\n      default:\n        this.length = 4;\n        break;\n    }\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.length) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    return toBytes(bytes, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    let bytes = data.slice(offset, offset + 8);\n    bytes = bytes.slice(8 - this.length, 8);\n\n    return [toNumber(bytes), offset + 8];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';\nimport { ErrorCode } from '@fuel-ts/errors';\n\nimport { Coder } from './abstract-coder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  length: TLength;\n  #paddingLength: number;\n\n  constructor(length: TLength) {\n    let paddingLength = (8 - length) % 8;\n    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;\n    super('string', `str[${length}]`, length + paddingLength);\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: string): Uint8Array {\n    if (this.length !== value.length) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    const encoded = toUtf8Bytes(value);\n    const padding = new Uint8Array(this.#paddingLength);\n    return concat([encoded, padding]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    const bytes = data.slice(offset, offset + this.length);\n    const value = toUtf8String(bytes);\n\n    const padding = this.#paddingLength;\n    return [value, offset + this.length + padding];\n  }\n}\n","import { ErrorCode } from '@fuel-ts/errors';\n\nimport { concatWithDynamicData } from '../utilities';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport { Coder } from './abstract-coder';\nimport { OptionCoder } from './option';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>) {\n    const encodedFields = Object.keys(this.coders).map((fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      const fieldValue = value[fieldName];\n      if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n        this.throwError(\n          ErrorCode.ENCODE_ERROR,\n          `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n        );\n      }\n      const encoded = fieldCoder.encode(fieldValue);\n      return encoded;\n    });\n\n    return concatWithDynamicData([concatWithDynamicData(encodedFields)]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import type { Coder } from './abstract-coder';\nimport type { InputValueOf, DecodedValueOf } from './enum';\nimport { EnumCoder } from './enum';\n\ntype SwayOption<T> = { None: [] } | { Some: T };\nexport type Option<T> = T | undefined;\n\nexport class OptionCoder<TCoders extends Record<string, Coder>> extends EnumCoder<TCoders> {\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const result = super.encode(this.toSwayOption(value) as unknown as InputValueOf<TCoders>);\n    return result;\n  }\n\n  toSwayOption(input: InputValueOf<TCoders>): SwayOption<unknown> {\n    if (input !== undefined) {\n      return { Some: input };\n    }\n\n    return { None: [] };\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded) as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  toOption(output?: DecodedValueOf<TCoders>): Option<unknown> {\n    if (output && 'Some' in output) {\n      return output.Some;\n    }\n\n    return undefined;\n  }\n}\n","import { ErrorCode } from '@fuel-ts/errors';\n\nimport { concatWithDynamicData } from '../utilities';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport { Coder } from './abstract-coder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatWithDynamicData(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport type { Uint8ArrayWithDynamicData } from '../utilities';\nimport { concatWithDynamicData, BASE_VECTOR_OFFSET, chunkByLength } from '../utilities';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport { Coder } from './abstract-coder';\nimport { U64Coder } from './u64';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, coder.encodedLength + BASE_VECTOR_OFFSET);\n    this.coder = coder;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_VECTOR_OFFSET);\n    // pointer dynamicData, encode the vector now and attach to its pointer\n    pointer.dynamicData = {\n      0: concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v))),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new U64Coder().encode(value.length));\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    const len = data.slice(16, 24);\n    const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();\n    const vectorRawData = data.slice(\n      BASE_VECTOR_OFFSET,\n      BASE_VECTOR_OFFSET + length * this.coder.encodedLength\n    );\n    return [\n      chunkByLength(vectorRawData, this.coder.encodedLength).map(\n        (chunk) => this.coder.decode(chunk, 0)[0]\n      ),\n      offset + BASE_VECTOR_OFFSET,\n    ];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { AbiCoder } from './abi-coder';\nimport type { InputValue } from './coders/abstract-coder';\nimport { FunctionFragment } from './function-fragment';\nimport type { JsonAbi, JsonAbiConfigurable } from './json-abi';\nimport { findOrThrow } from './utilities';\n\nexport class Interface<TAbi extends JsonAbi = JsonAbi> {\n  readonly functions!: Record<string, FunctionFragment>;\n\n  readonly configurables: Record<string, JsonAbiConfigurable>;\n  /*\n  TODO: Refactor so that there's no need for externalLoggedTypes\n\n  This is dedicated to external contracts added via `<base-invocation-scope.ts>.addContracts()` method.\n  This is used to decode logs from contracts other than the main contract\n  we're interacting with.\n  */\n  private externalLoggedTypes: Record<string, Interface>;\n  readonly jsonAbi: TAbi;\n\n  constructor(jsonAbi: TAbi) {\n    this.jsonAbi = jsonAbi;\n\n    this.externalLoggedTypes = {};\n\n    this.functions = Object.fromEntries(\n      this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)])\n    );\n\n    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));\n  }\n\n  /**\n   * Returns function fragment for a dynamic input.\n   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment\n   */\n  getFunction(nameOrSignatureOrSelector: string): FunctionFragment {\n    const fn = Object.values<FunctionFragment>(this.functions).find(\n      (f) =>\n        f.name === nameOrSignatureOrSelector ||\n        f.signature === nameOrSignatureOrSelector ||\n        f.selector === nameOrSignatureOrSelector\n    );\n\n    if (fn !== undefined) return fn;\n\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`\n    );\n  }\n\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, 'Fragment not found.');\n    }\n\n    return fragment.decodeArguments(data);\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>,\n    offset = 0\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, 'Fragment not found.');\n    }\n\n    return fragment.encodeArguments(values, offset);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.decodeOutput(data);\n  }\n\n  decodeLog(data: BytesLike, logId: number, receiptId: string): any {\n    const isExternalLoggedType = this.externalLoggedTypes[receiptId];\n    if (isExternalLoggedType) {\n      const externalInterface = this.externalLoggedTypes[receiptId];\n      return externalInterface.decodeLog(data, logId, receiptId);\n    }\n\n    const { loggedType } = findOrThrow(this.jsonAbi.loggedTypes, (type) => type.logId === logId);\n\n    return AbiCoder.decode(this.jsonAbi, loggedType, arrayify(data), 0);\n  }\n\n  updateExternalLoggedTypes(id: string, loggedTypes: Interface) {\n    this.externalLoggedTypes[id] = loggedTypes;\n  }\n\n  encodeConfigurable(name: string, value: InputValue) {\n    const configurable = findOrThrow(\n      this.jsonAbi.configurables,\n      (c) => c.name === name,\n      () => {\n        throw new FuelError(\n          ErrorCode.CONFIGURABLE_NOT_FOUND,\n          `A configurable with the '${name}' was not found in the ABI.`\n        );\n      }\n    );\n\n    return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value);\n  }\n\n  getTypeById(typeId: number) {\n    return findOrThrow(\n      this.jsonAbi.types,\n      (t) => t.typeId === typeId,\n      () => {\n        throw new FuelError(\n          ErrorCode.TYPE_NOT_FOUND,\n          `Type with typeId '${typeId}' doesn't exist in the ABI.`\n        );\n      }\n    );\n  }\n}\n","// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { DecodedValue, InputValue, Coder } from './coders/abstract-coder';\nimport { ArrayCoder } from './coders/array';\nimport { B256Coder } from './coders/b256';\nimport { B512Coder } from './coders/b512';\nimport { BooleanCoder } from './coders/boolean';\nimport { ByteCoder } from './coders/byte';\nimport { EnumCoder } from './coders/enum';\nimport { NumberCoder } from './coders/number';\nimport { OptionCoder } from './coders/option';\nimport { RawSliceCoder } from './coders/raw-slice';\nimport { StringCoder } from './coders/string';\nimport { StructCoder } from './coders/struct';\nimport { TupleCoder } from './coders/tuple';\nimport { U64Coder } from './coders/u64';\nimport { VecCoder } from './coders/vec';\nimport {\n  arrayRegEx,\n  enumRegEx,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n  OPTION_CODER_TYPE,\n  VEC_CODER_TYPE,\n  BYTES_CODER_TYPE,\n} from './constants';\nimport type { JsonAbi, JsonAbiArgument } from './json-abi';\nimport { ResolvedAbiType } from './resolved-abi-type';\nimport { findOrThrow } from './utilities';\n\nexport abstract class AbiCoder {\n  static getCoder(abi: JsonAbi, argument: JsonAbiArgument): Coder {\n    const resolvedAbiType = new ResolvedAbiType(abi, argument);\n\n    return AbiCoder.getCoderImpl(resolvedAbiType);\n  }\n\n  static encode(abi: JsonAbi, argument: JsonAbiArgument, value: InputValue) {\n    return this.getCoder(abi, argument).encode(value);\n  }\n\n  static decode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    data: Uint8Array,\n    offset: number\n  ): [DecodedValue | undefined, number] {\n    return this.getCoder(abi, argument).decode(data, offset) as [DecodedValue | undefined, number];\n  }\n\n  private static getCoderImpl(resolvedAbiType: ResolvedAbiType): Coder {\n    switch (resolvedAbiType.type) {\n      case 'u8':\n      case 'u16':\n      case 'u32':\n        return new NumberCoder(resolvedAbiType.type);\n      case 'u64':\n      case 'raw untyped ptr':\n        return new U64Coder();\n      case 'raw untyped slice':\n        return new RawSliceCoder();\n      case 'bool':\n        return new BooleanCoder();\n      case 'b256':\n        return new B256Coder();\n      case 'struct B512':\n        return new B512Coder();\n      case BYTES_CODER_TYPE:\n        return new ByteCoder();\n      default:\n        break;\n    }\n\n    const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n    if (stringMatch) {\n      const length = parseInt(stringMatch.length, 10);\n\n      return new StringCoder(length);\n    }\n\n    // ABI types underneath MUST have components by definition\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const components = resolvedAbiType.components!;\n\n    const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n    if (arrayMatch) {\n      const length = parseInt(arrayMatch.length, 10);\n      const arg = components[0];\n      if (!arg) {\n        throw new FuelError(\n          ErrorCode.INVALID_COMPONENT,\n          `The provided Array type is missing an item of 'component'.`\n        );\n      }\n\n      const arrayElementCoder = AbiCoder.getCoderImpl(arg);\n      return new ArrayCoder(arrayElementCoder, length);\n    }\n\n    if (resolvedAbiType.type === VEC_CODER_TYPE) {\n      const arg = findOrThrow(components, (c) => c.name === 'buf').originalTypeArguments?.[0];\n      if (!arg) {\n        throw new FuelError(\n          ErrorCode.INVALID_COMPONENT,\n          `The provided Vec type is missing the 'type argument'.`\n        );\n      }\n      const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n\n      const itemCoder = AbiCoder.getCoderImpl(argType);\n      return new VecCoder(itemCoder);\n    }\n\n    const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;\n    if (structMatch) {\n      const coders = AbiCoder.getCoders(components);\n      return new StructCoder(structMatch.name, coders);\n    }\n\n    const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;\n    if (enumMatch) {\n      const coders = AbiCoder.getCoders(components);\n\n      const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n      if (isOptionEnum) {\n        return new OptionCoder(enumMatch.name, coders);\n      }\n      return new EnumCoder(enumMatch.name, coders);\n    }\n\n    const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n    if (tupleMatch) {\n      const coders = components.map((component) => AbiCoder.getCoderImpl(component));\n      return new TupleCoder(coders);\n    }\n\n    throw new FuelError(\n      ErrorCode.CODER_NOT_FOUND,\n      `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n    );\n  }\n\n  private static getCoders(components: readonly ResolvedAbiType[]) {\n    return components.reduce((obj, component) => {\n      const o: Record<string, Coder> = obj;\n\n      o[component.name] = AbiCoder.getCoderImpl(component);\n      return o;\n    }, {});\n  }\n}\n","import { arrayify, concat } from '@ethersproject/bytes';\nimport { ErrorCode } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../constants';\nimport type { Uint8ArrayWithDynamicData } from '../utilities';\nimport { BASE_VECTOR_OFFSET, concatWithDynamicData } from '../utilities';\n\nimport { Coder } from './abstract-coder';\nimport { U64Coder } from './u64';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', BASE_VECTOR_OFFSET);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_VECTOR_OFFSET);\n\n    // pointer dynamicData, encode the byte vector now and attach to its pointer\n    const data = this.#getPaddedData(value);\n    pointer.dynamicData = {\n      0: concatWithDynamicData([data]),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new U64Coder().encode(data.byteLength));\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  #getPaddedData(value: number[]): Uint8Array {\n    const data: Uint8Array[] = [arrayify(value)];\n\n    const paddingLength = (WORD_SIZE - (value.length % WORD_SIZE)) % WORD_SIZE;\n    if (paddingLength) {\n      data.push(new Uint8Array(paddingLength));\n    }\n\n    return concat(data);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    const len = data.slice(16, 24);\n    const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();\n    const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + length * 8);\n\n    return [byteData, offset + BASE_VECTOR_OFFSET];\n  }\n}\n","import { ErrorCode } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../constants';\nimport type { Uint8ArrayWithDynamicData } from '../utilities';\nimport { BASE_RAW_SLICE_OFFSET, concatWithDynamicData } from '../utilities';\n\nimport { Coder } from './abstract-coder';\nimport { ArrayCoder } from './array';\nimport { U64Coder } from './u64';\n\nexport class RawSliceCoder extends Coder<number[], BN[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', BASE_RAW_SLICE_OFFSET);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n    const coder = new U64Coder();\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new U64Coder().encode(BASE_RAW_SLICE_OFFSET);\n\n    // pointer dynamicData, encode the vector now and attach to its pointer\n    pointer.dynamicData = {\n      0: concatWithDynamicData(value.map((v) => coder.encode(v))),\n    };\n\n    parts.push(pointer);\n\n    // length (len)\n    parts.push(new U64Coder().encode(value.length * WORD_SIZE));\n\n    return concatWithDynamicData(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [BN[], number] {\n    const internalCoder = new ArrayCoder(new U64Coder(), data.length / 8);\n    const decoded = internalCoder.decode(data, offset);\n\n    return decoded;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { arrayRegEx, enumRegEx, genericRegEx, stringRegEx, structRegEx } from './constants';\nimport type { JsonAbi, JsonAbiArgument } from './json-abi';\nimport { findOrThrow } from './utilities';\n\nexport class ResolvedAbiType {\n  readonly abi: JsonAbi;\n  name: string;\n  readonly type: string;\n  readonly originalTypeArguments: readonly JsonAbiArgument[] | null;\n  readonly components: readonly ResolvedAbiType[] | null;\n\n  constructor(abi: JsonAbi, argument: JsonAbiArgument) {\n    this.abi = abi;\n    const type = findOrThrow(\n      abi.types,\n      (t) => t.typeId === argument.type,\n      () => {\n        throw new FuelError(\n          ErrorCode.TYPE_NOT_FOUND,\n          `Type does not exist in the provided abi: ${JSON.stringify({\n            argument,\n            abi: this.abi,\n          })}`\n        );\n      }\n    );\n\n    this.name = argument.name;\n\n    this.type = type.type;\n    this.originalTypeArguments = argument.typeArguments;\n    this.components = ResolvedAbiType.getResolvedGenericComponents(\n      abi,\n      argument,\n      type.components,\n      type.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, type.components)\n    );\n  }\n\n  private static getResolvedGenericComponents(\n    abi: JsonAbi,\n    arg: JsonAbiArgument,\n    components: readonly JsonAbiArgument[] | null,\n    typeParameters: readonly number[] | null\n  ) {\n    if (components === null) return null;\n    if (typeParameters === null || typeParameters.length === 0)\n      return components.map((c) => new ResolvedAbiType(abi, c));\n\n    const typeParametersAndArgsMap = typeParameters.reduce(\n      (obj, typeParameter, typeParameterIndex) => {\n        const o: Record<number, JsonAbiArgument> = { ...obj };\n        o[typeParameter] = structuredClone(arg.typeArguments?.[typeParameterIndex]);\n        return o;\n      },\n      {} as Record<number, JsonAbiArgument>\n    );\n\n    const resolvedComponents = this.resolveGenericArgTypes(\n      abi,\n      components,\n      typeParametersAndArgsMap\n    );\n\n    return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));\n  }\n\n  private static resolveGenericArgTypes(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[],\n    typeParametersAndArgsMap: Record<number, JsonAbiArgument>\n  ): readonly JsonAbiArgument[] {\n    return args.map((arg) => {\n      if (typeParametersAndArgsMap[arg.type] !== undefined) {\n        return {\n          ...typeParametersAndArgsMap[arg.type],\n          name: arg.name,\n        };\n      }\n\n      if (arg.typeArguments) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: this.resolveGenericArgTypes(\n            abi,\n            arg.typeArguments,\n            typeParametersAndArgsMap\n          ),\n        };\n      }\n\n      const argType = findOrThrow(abi.types, (t) => t.typeId === arg.type);\n      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);\n\n      if (implicitTypeParameters && implicitTypeParameters.length > 0) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp]),\n        };\n      }\n\n      return arg;\n    });\n  }\n\n  private static getImplicitGenericTypeParameters(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[] | null,\n    implicitGenericParametersParam?: number[]\n  ) {\n    if (!Array.isArray(args)) return null;\n\n    const implicitGenericParameters: number[] = implicitGenericParametersParam ?? [];\n\n    args.forEach((a) => {\n      const argType = findOrThrow(abi.types, (t) => t.typeId === a.type);\n\n      if (genericRegEx.test(argType.type)) {\n        implicitGenericParameters.push(argType.typeId);\n        return;\n      }\n\n      if (!Array.isArray(a.typeArguments)) return;\n      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);\n    });\n\n    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;\n  }\n\n  getSignature(): string {\n    const prefix = this.getArgSignaturePrefix();\n    const content = this.getArgSignatureContent();\n\n    return `${prefix}${content}`;\n  }\n\n  private getArgSignaturePrefix(): string {\n    const structMatch = structRegEx.test(this.type);\n    if (structMatch) return 's';\n\n    const arrayMatch = arrayRegEx.test(this.type);\n    if (arrayMatch) return 'a';\n\n    const enumMatch = enumRegEx.test(this.type);\n    if (enumMatch) return 'e';\n\n    return '';\n  }\n\n  private getArgSignatureContent(): string {\n    if (this.type === 'raw untyped ptr') {\n      return 'rawptr';\n    }\n\n    if (this.type === 'raw untyped slice') {\n      return 'rawslice';\n    }\n\n    const strMatch = stringRegEx.exec(this.type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n\n    if (this.components === null) return this.type;\n\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n\n    if (arrayMatch) {\n      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;\n    }\n\n    const typeArgumentsSignature =\n      this.originalTypeArguments !== null\n        ? `<${this.originalTypeArguments\n            .map((a) => new ResolvedAbiType(this.abi, a).getSignature())\n            .join(',')}>`\n        : '';\n\n    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(',')})`;\n\n    return `${typeArgumentsSignature}${componentsSignature}`;\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\nimport { bufferFromString } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { AbiCoder } from './abi-coder';\nimport type { DecodedValue, InputValue } from './coders/abstract-coder';\nimport type { ArrayCoder } from './coders/array';\nimport { ByteCoder } from './coders/byte';\nimport { TupleCoder } from './coders/tuple';\nimport type { U64Coder } from './coders/u64';\nimport { VecCoder } from './coders/vec';\nimport { OPTION_CODER_TYPE } from './constants';\nimport type {\n  JsonAbi,\n  JsonAbiArgument,\n  JsonAbiFunction,\n  JsonAbiFunctionAttribute,\n} from './json-abi';\nimport { ResolvedAbiType } from './resolved-abi-type';\nimport type { Uint8ArrayWithDynamicData } from './utilities';\nimport { isPointerType, unpackDynamicData, findOrThrow, isHeapType } from './utilities';\n\nexport class FunctionFragment<\n  TAbi extends JsonAbi = JsonAbi,\n  FnName extends TAbi['functions'][number]['name'] = string\n> {\n  readonly signature: string;\n  readonly selector: string;\n  readonly name: string;\n  readonly jsonFn: JsonAbiFunction;\n  readonly attributes: readonly JsonAbiFunctionAttribute[];\n  readonly isInputDataPointer: boolean;\n  readonly outputMetadata: {\n    isHeapType: boolean;\n    encodedLength: number;\n  };\n\n  private readonly jsonAbi: JsonAbi;\n\n  constructor(jsonAbi: JsonAbi, name: FnName) {\n    this.jsonAbi = jsonAbi;\n    this.jsonFn = findOrThrow(this.jsonAbi.functions, (f) => f.name === name);\n    this.name = name;\n    this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);\n    this.selector = FunctionFragment.getFunctionSelector(this.signature);\n    this.isInputDataPointer = this.#isInputDataPointer();\n    this.outputMetadata = {\n      isHeapType: this.#isOutputDataHeap(),\n      encodedLength: this.#getOutputEncodedLength(),\n    };\n\n    this.attributes = this.jsonFn.attributes ?? [];\n  }\n\n  private static getSignature(abi: JsonAbi, fn: JsonAbiFunction): string {\n    const inputsSignatures = fn.inputs.map((input) =>\n      new ResolvedAbiType(abi, input).getSignature()\n    );\n    return `${fn.name}(${inputsSignatures.join(',')})`;\n  }\n\n  private static getFunctionSelector(functionSignature: string) {\n    const hashedFunctionSignature = sha256(bufferFromString(functionSignature, 'utf-8'));\n    // get first 4 bytes of signature + 0x prefix. then left-pad it to 8 bytes using toHex(8)\n    return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);\n  }\n\n  #isInputDataPointer(): boolean {\n    const inputTypes = this.jsonFn.inputs.map((i) =>\n      this.jsonAbi.types.find((t) => t.typeId === i.type)\n    );\n\n    return this.jsonFn.inputs.length > 1 || isPointerType(inputTypes[0]?.type || '');\n  }\n\n  #isOutputDataHeap(): boolean {\n    const outputType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);\n\n    return isHeapType(outputType?.type || '');\n  }\n\n  #getOutputEncodedLength(): number {\n    try {\n      const heapCoder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);\n      if (heapCoder instanceof VecCoder) {\n        return heapCoder.coder.encodedLength;\n      }\n      if (heapCoder instanceof ByteCoder) {\n        return ByteCoder.memorySize;\n      }\n\n      return heapCoder.encodedLength;\n    } catch (e) {\n      return 0;\n    }\n  }\n\n  encodeArguments(values: InputValue[], offset = 0): Uint8Array {\n    FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);\n\n    const shallowCopyValues = values.slice();\n\n    const nonEmptyInputs = this.jsonFn.inputs.filter(\n      (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== '()'\n    );\n\n    if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {\n      shallowCopyValues.length = this.jsonFn.inputs.length;\n      shallowCopyValues.fill(undefined as unknown as InputValue, values.length);\n    }\n\n    const coders = nonEmptyInputs.map((t) => AbiCoder.getCoder(this.jsonAbi, t));\n\n    const coder = new TupleCoder(coders);\n    const results: Uint8ArrayWithDynamicData = coder.encode(shallowCopyValues);\n\n    return unpackDynamicData(results, offset, results.byteLength);\n  }\n\n  private static verifyArgsAndInputsAlign(\n    args: InputValue[],\n    inputs: readonly JsonAbiArgument[],\n    abi: JsonAbi\n  ) {\n    if (args.length === inputs.length) return;\n\n    const inputTypes = inputs.map((i) => findOrThrow(abi.types, (t) => t.typeId === i.type));\n    const optionalInputs = inputTypes.filter(\n      (x) => x.type === OPTION_CODER_TYPE || x.type === '()'\n    );\n    if (optionalInputs.length === inputTypes.length) return;\n    if (inputTypes.length - optionalInputs.length === args.length) return;\n\n    const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${\n      args.length\n    } arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${\n      optionalInputs.length\n    } optional inputs).`;\n\n    throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);\n  }\n\n  decodeArguments(data: BytesLike) {\n    const bytes = arrayify(data);\n    const nonEmptyInputs = this.jsonFn.inputs.filter(\n      (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== '()'\n    );\n\n    if (nonEmptyInputs.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      if (bytes.length === 0) return undefined;\n\n      throw new FuelError(\n        ErrorCode.DECODE_ERROR,\n        `Types/values length mismatch during decode. ${JSON.stringify({\n          count: {\n            types: this.jsonFn.inputs.length,\n            nonEmptyInputs: nonEmptyInputs.length,\n            values: bytes.length,\n          },\n          value: {\n            args: this.jsonFn.inputs,\n            nonEmptyInputs,\n            values: bytes,\n          },\n        })}`\n      );\n    }\n\n    const result = nonEmptyInputs.reduce(\n      (obj: { decoded: unknown[]; offset: number }, input) => {\n        const coder = AbiCoder.getCoder(this.jsonAbi, input);\n        const [decodedValue, decodedValueByteSize] = coder.decode(bytes, obj.offset);\n\n        return {\n          decoded: [...obj.decoded, decodedValue],\n          offset: obj.offset + decodedValueByteSize,\n        };\n      },\n      { decoded: [], offset: 0 }\n    );\n\n    return result.decoded;\n  }\n\n  decodeOutput(data: BytesLike): [DecodedValue | undefined, number] {\n    const outputAbiType = findOrThrow(\n      this.jsonAbi.types,\n      (t) => t.typeId === this.jsonFn.output.type\n    );\n    if (outputAbiType.type === '()') return [undefined, 0];\n\n    const bytes = arrayify(data);\n    const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);\n\n    if (outputAbiType.type === 'raw untyped slice') {\n      (coder as ArrayCoder<U64Coder>).length = bytes.length / 8;\n    }\n\n    return coder.decode(bytes, 0) as [DecodedValue | undefined, number];\n  }\n}\n"],"mappings":"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","names":["ErrorCode","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","arrayify","ErrorCode","bn","arrayify","ErrorCode","bn","arrayify","ErrorCode","bn","toHex","arrayify","ErrorCode","bn","toHex","ErrorCode","bn","toBytes","ErrorCode","toBytes","bn","concat","ErrorCode","FuelError","concat","FuelError","ErrorCode","ErrorCode","toNumber","toBytes","toBytes","ErrorCode","toNumber","concat","ErrorCode","ErrorCode","concat","ErrorCode","ErrorCode","ErrorCode","ErrorCode","ErrorCode","bn","ErrorCode","bn","arrayify","ErrorCode","FuelError","ErrorCode","FuelError","arrayify","concat","ErrorCode","bn","ErrorCode","bn","arrayify","concat","ErrorCode","ErrorCode","ErrorCode","FuelError","FuelError","ErrorCode","FuelError","ErrorCode","arrayify","ErrorCode","FuelError","bn","bn","FuelError","ErrorCode","arrayify","FuelError","ErrorCode","arrayify"]}