{"version":3,"sources":["../src/hasher.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { concat } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { bufferFromString } from '@fuel-ts/crypto';\nimport { bn } from '@fuel-ts/math';\nimport type { TransactionRequestLike } from '@fuel-ts/providers';\nimport { transactionRequestify, TransactionType } from '@fuel-ts/providers';\nimport type { UtxoId } from '@fuel-ts/transactions';\nimport { OutputType, InputType, TransactionCoder } from '@fuel-ts/transactions';\nimport { clone } from 'ramda';\n\n/**\n * hash string messages with sha256\n *\n * @param msg - The string message to be hashed\n * @returns A sha256 hash of the message\n */\nexport function hashMessage(msg: string) {\n  return sha256(bufferFromString(msg, 'utf-8'));\n}\n\n/**\n * Convert a uint64 number to a big-endian byte array\n */\nexport function uint64ToBytesBE(value: number): Uint8Array {\n  const bigIntValue = BigInt(value);\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setBigUint64(0, bigIntValue, false); // write the uint64 value in big-endian order\n  return new Uint8Array(dataView.buffer);\n}\n\n/**\n * Hash transaction request with sha256. [Read more](https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/identifiers.md#transaction-id)\n *\n * @param transactionRequest - Transaction request to be hashed\n * @returns sha256 hash of the transaction\n */\nexport function hashTransaction(transactionRequestLike: TransactionRequestLike, chainId: number) {\n  const transactionRequest = transactionRequestify(transactionRequestLike);\n  // Return a new transaction object without references to the original transaction request\n  const transaction = transactionRequest.toTransaction();\n\n  if (transaction.type === TransactionType.Script) {\n    transaction.receiptsRoot = ZeroBytes32;\n  }\n\n  // Zero out input fields\n  transaction.inputs = transaction.inputs.map((input) => {\n    const inputClone = clone(input);\n\n    switch (inputClone.type) {\n      // Zero out on signing: txPointer, predicateGasUsed\n      case InputType.Coin: {\n        inputClone.txPointer = {\n          blockHeight: 0,\n          txIndex: 0,\n        };\n        inputClone.predicateGasUsed = bn(0);\n        return inputClone;\n      }\n      // Zero out on signing: predicateGasUsed\n      case InputType.Message: {\n        inputClone.predicateGasUsed = bn(0);\n        return inputClone;\n      }\n      // Zero out on signing: txID, outputIndex, balanceRoot, stateRoot, and txPointer\n      case InputType.Contract: {\n        inputClone.txPointer = {\n          blockHeight: 0,\n          txIndex: 0,\n        };\n        inputClone.utxoID = <UtxoId>{\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        };\n        inputClone.balanceRoot = ZeroBytes32;\n        inputClone.stateRoot = ZeroBytes32;\n        return inputClone;\n      }\n      default:\n        return inputClone;\n    }\n  });\n  // Zero out output fields\n  transaction.outputs = transaction.outputs.map((output) => {\n    const outputClone = clone(output);\n\n    switch (outputClone.type) {\n      // Zero out on signing: balanceRoot, stateRoot\n      case OutputType.Contract: {\n        outputClone.balanceRoot = ZeroBytes32;\n        outputClone.stateRoot = ZeroBytes32;\n        return outputClone;\n      }\n      // Zero out on signing: amount\n      case OutputType.Change: {\n        outputClone.amount = bn(0);\n        return outputClone;\n      }\n      // Zero out on signing: amount, to and assetId\n      case OutputType.Variable: {\n        outputClone.to = ZeroBytes32;\n        outputClone.amount = bn(0);\n        outputClone.assetId = ZeroBytes32;\n        return outputClone;\n      }\n      default:\n        return outputClone;\n    }\n  });\n  transaction.witnessesCount = 0;\n  transaction.witnesses = [];\n\n  const chainIdBytes = uint64ToBytesBE(chainId);\n  const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);\n  return sha256(concatenatedData);\n}\n\n/**\n * wrap sha256\n *\n * @param data - The data to be hash\n * @returns A sha256 hash of the data\n */\nexport function hash(data: BytesLike) {\n  return sha256(data);\n}\n"],"mappings":";AACA,SAAS,cAAc;AACvB,SAAS,cAAc;AACvB,SAAS,mBAAmB;AAC5B,SAAS,wBAAwB;AACjC,SAAS,UAAU;AAEnB,SAAS,uBAAuB,uBAAuB;AAEvD,SAAS,YAAY,WAAW,wBAAwB;AACxD,SAAS,aAAa;AAQf,SAAS,YAAY,KAAa;AACvC,SAAO,OAAO,iBAAiB,KAAK,OAAO,CAAC;AAC9C;AAKO,SAAS,gBAAgB,OAA2B;AACzD,QAAM,cAAc,OAAO,KAAK;AAChC,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,QAAM,WAAW,IAAI,SAAS,MAAM;AACpC,WAAS,aAAa,GAAG,aAAa,KAAK;AAC3C,SAAO,IAAI,WAAW,SAAS,MAAM;AACvC;AAQO,SAAS,gBAAgB,wBAAgD,SAAiB;AAC/F,QAAM,qBAAqB,sBAAsB,sBAAsB;AAEvE,QAAM,cAAc,mBAAmB,cAAc;AAErD,MAAI,YAAY,SAAS,gBAAgB,QAAQ;AAC/C,gBAAY,eAAe;AAAA,EAC7B;AAGA,cAAY,SAAS,YAAY,OAAO,IAAI,CAAC,UAAU;AACrD,UAAM,aAAa,MAAM,KAAK;AAE9B,YAAQ,WAAW,MAAM;AAAA,MAEvB,KAAK,UAAU,MAAM;AACnB,mBAAW,YAAY;AAAA,UACrB,aAAa;AAAA,UACb,SAAS;AAAA,QACX;AACA,mBAAW,mBAAmB,GAAG,CAAC;AAClC,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,UAAU,SAAS;AACtB,mBAAW,mBAAmB,GAAG,CAAC;AAClC,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,UAAU,UAAU;AACvB,mBAAW,YAAY;AAAA,UACrB,aAAa;AAAA,UACb,SAAS;AAAA,QACX;AACA,mBAAW,SAAiB;AAAA,UAC1B,eAAe;AAAA,UACf,aAAa;AAAA,QACf;AACA,mBAAW,cAAc;AACzB,mBAAW,YAAY;AACvB,eAAO;AAAA,MACT;AAAA,MACA;AACE,eAAO;AAAA,IACX;AAAA,EACF,CAAC;AAED,cAAY,UAAU,YAAY,QAAQ,IAAI,CAAC,WAAW;AACxD,UAAM,cAAc,MAAM,MAAM;AAEhC,YAAQ,YAAY,MAAM;AAAA,MAExB,KAAK,WAAW,UAAU;AACxB,oBAAY,cAAc;AAC1B,oBAAY,YAAY;AACxB,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,WAAW,QAAQ;AACtB,oBAAY,SAAS,GAAG,CAAC;AACzB,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,WAAW,UAAU;AACxB,oBAAY,KAAK;AACjB,oBAAY,SAAS,GAAG,CAAC;AACzB,oBAAY,UAAU;AACtB,eAAO;AAAA,MACT;AAAA,MACA;AACE,eAAO;AAAA,IACX;AAAA,EACF,CAAC;AACD,cAAY,iBAAiB;AAC7B,cAAY,YAAY,CAAC;AAEzB,QAAM,eAAe,gBAAgB,OAAO;AAC5C,QAAM,mBAAmB,OAAO,CAAC,cAAc,IAAI,iBAAiB,EAAE,OAAO,WAAW,CAAC,CAAC;AAC1F,SAAO,OAAO,gBAAgB;AAChC;AAQO,SAAS,KAAK,MAAiB;AACpC,SAAO,OAAO,IAAI;AACpB;","names":[]}