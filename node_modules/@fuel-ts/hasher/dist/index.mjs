// src/hasher.ts
import { concat } from "@ethersproject/bytes";
import { sha256 } from "@ethersproject/sha2";
import { ZeroBytes32 } from "@fuel-ts/address/configs";
import { bufferFromString } from "@fuel-ts/crypto";
import { bn } from "@fuel-ts/math";
import { transactionRequestify, TransactionType } from "@fuel-ts/providers";
import { OutputType, InputType, TransactionCoder } from "@fuel-ts/transactions";
import { clone } from "ramda";
function hashMessage(msg) {
  return sha256(bufferFromString(msg, "utf-8"));
}
function uint64ToBytesBE(value) {
  const bigIntValue = BigInt(value);
  const buffer = new ArrayBuffer(8);
  const dataView = new DataView(buffer);
  dataView.setBigUint64(0, bigIntValue, false);
  return new Uint8Array(dataView.buffer);
}
function hashTransaction(transactionRequestLike, chainId) {
  const transactionRequest = transactionRequestify(transactionRequestLike);
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === TransactionType.Script) {
    transaction.receiptsRoot = ZeroBytes32;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = clone(input);
    switch (inputClone.type) {
      case InputType.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = bn(0);
        return inputClone;
      }
      case InputType.Message: {
        inputClone.predicateGasUsed = bn(0);
        return inputClone;
      }
      case InputType.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.utxoID = {
          transactionId: ZeroBytes32,
          outputIndex: 0
        };
        inputClone.balanceRoot = ZeroBytes32;
        inputClone.stateRoot = ZeroBytes32;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output) => {
    const outputClone = clone(output);
    switch (outputClone.type) {
      case OutputType.Contract: {
        outputClone.balanceRoot = ZeroBytes32;
        outputClone.stateRoot = ZeroBytes32;
        return outputClone;
      }
      case OutputType.Change: {
        outputClone.amount = bn(0);
        return outputClone;
      }
      case OutputType.Variable: {
        outputClone.to = ZeroBytes32;
        outputClone.amount = bn(0);
        outputClone.assetId = ZeroBytes32;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = uint64ToBytesBE(chainId);
  const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
  return sha256(concatenatedData);
}
function hash(data) {
  return sha256(data);
}
export {
  hash,
  hashMessage,
  hashTransaction,
  uint64ToBytesBE
};
//# sourceMappingURL=index.mjs.map