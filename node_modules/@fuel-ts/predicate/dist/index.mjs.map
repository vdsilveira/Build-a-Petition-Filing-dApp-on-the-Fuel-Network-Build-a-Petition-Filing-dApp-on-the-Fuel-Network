{"version":3,"sources":["../src/predicate.ts","../src/utils/getPredicateRoot.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport type { JsonAbi, InputValue } from '@fuel-ts/abi-coder';\nimport {\n  Interface,\n  INPUT_COIN_FIXED_SIZE,\n  SCRIPT_FIXED_SIZE,\n  VM_TX_MEMORY,\n  WORD_SIZE,\n} from '@fuel-ts/abi-coder';\nimport { Address } from '@fuel-ts/address';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractPredicate } from '@fuel-ts/interfaces';\nimport type {\n  CallResult,\n  Provider,\n  TransactionRequestLike,\n  TransactionResponse,\n} from '@fuel-ts/providers';\nimport { transactionRequestify } from '@fuel-ts/providers';\nimport { ByteArrayCoder, InputType } from '@fuel-ts/transactions';\nimport { Account } from '@fuel-ts/wallet';\n\nimport { getPredicateRoot } from './utils';\n\n/**\n * `Predicate` provides methods to populate transaction data with predicate information and sending transactions with them.\n */\nexport class Predicate<ARGS extends InputValue[]> extends Account implements AbstractPredicate {\n  bytes: Uint8Array;\n  predicateData: Uint8Array = Uint8Array.from([]);\n  interface?: Interface;\n\n  // TODO: Since provider is no longer optional, we can maybe remove `chainId` from the constructor.\n  /**\n   * Creates an instance of the Predicate class.\n   *\n   * @param bytes - The bytes of the predicate.\n   * @param chainId - The chain ID for which the predicate is used.\n   * @param provider - The provider used to interact with the blockchain.\n   * @param jsonAbi - The JSON ABI of the predicate.\n   * @param configurableConstants - Optional configurable constants for the predicate.\n   */\n  constructor(\n    bytes: BytesLike,\n    provider: Provider,\n    jsonAbi?: JsonAbi,\n    configurableConstants?: { [name: string]: unknown }\n  ) {\n    const { predicateBytes, predicateInterface } = Predicate.processPredicateData(\n      bytes,\n      jsonAbi,\n      configurableConstants\n    );\n    const chainId = provider.getChainId();\n    const address = Address.fromB256(getPredicateRoot(predicateBytes, chainId));\n    super(address, provider);\n\n    this.bytes = predicateBytes;\n    this.interface = predicateInterface;\n  }\n\n  /**\n   * Populates the transaction data with predicate data.\n   *\n   * @param transactionRequestLike - The transaction request-like object.\n   * @returns The transaction request with predicate data.\n   */\n  populateTransactionPredicateData(transactionRequestLike: TransactionRequestLike) {\n    const request = transactionRequestify(transactionRequestLike);\n\n    request.inputs?.forEach((input) => {\n      if (input.type === InputType.Coin && hexlify(input.owner) === this.address.toB256()) {\n        // eslint-disable-next-line no-param-reassign\n        input.predicate = this.bytes;\n        // eslint-disable-next-line no-param-reassign\n        input.predicateData = this.predicateData;\n      }\n    });\n\n    return request;\n  }\n\n  /**\n   * Sends a transaction with the populated predicate data.\n   *\n   * @param transactionRequestLike - The transaction request-like object.\n   * @returns A promise that resolves to the transaction response.\n   */\n  sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse> {\n    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);\n    return super.sendTransaction(transactionRequest);\n  }\n\n  /**\n   * Simulates a transaction with the populated predicate data.\n   *\n   * @param transactionRequestLike - The transaction request-like object.\n   * @returns A promise that resolves to the call result.\n   */\n  simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);\n    return super.simulateTransaction(transactionRequest);\n  }\n\n  /**\n   * Sets data for the predicate.\n   *\n   * @param args - Arguments for the predicate function.\n   * @returns The Predicate instance with updated predicate data.\n   */\n  setData<T extends ARGS>(...args: T) {\n    const mainFn = this.interface?.functions.main;\n    const paddedCode = new ByteArrayCoder(this.bytes.length).encode(this.bytes);\n\n    const OFFSET =\n      VM_TX_MEMORY + SCRIPT_FIXED_SIZE + INPUT_COIN_FIXED_SIZE + WORD_SIZE + paddedCode.byteLength;\n\n    this.predicateData = mainFn?.encodeArguments(args, OFFSET) || new Uint8Array();\n    return this;\n  }\n\n  /**\n   * Processes the predicate data and returns the altered bytecode and interface.\n   *\n   * @param bytes - The bytes of the predicate.\n   * @param jsonAbi - The JSON ABI of the predicate.\n   * @param configurableConstants - Optional configurable constants for the predicate.\n   * @returns An object containing the new predicate bytes and interface.\n   */\n  private static processPredicateData(\n    bytes: BytesLike,\n    jsonAbi?: JsonAbi,\n    configurableConstants?: { [name: string]: unknown }\n  ) {\n    let predicateBytes = arrayify(bytes);\n    let abiInterface: Interface | undefined;\n\n    if (jsonAbi) {\n      abiInterface = new Interface(jsonAbi);\n      if (abiInterface.functions.main === undefined) {\n        throw new FuelError(\n          ErrorCode.ABI_MAIN_METHOD_MISSING,\n          'Cannot use ABI without \"main\" function.'\n        );\n      }\n    }\n\n    if (configurableConstants && Object.keys(configurableConstants).length) {\n      predicateBytes = Predicate.setConfigurableConstants(\n        predicateBytes,\n        configurableConstants,\n        abiInterface\n      );\n    }\n\n    return {\n      predicateBytes,\n      predicateInterface: abiInterface,\n    };\n  }\n\n  /**\n   * Sets the configurable constants for the predicate.\n   *\n   * @param bytes - The bytes of the predicate.\n   * @param configurableConstants - Configurable constants to be set.\n   * @param abiInterface - The ABI interface of the predicate.\n   * @returns The mutated bytes with the configurable constants set.\n   */\n  private static setConfigurableConstants(\n    bytes: Uint8Array,\n    configurableConstants: { [name: string]: unknown },\n    abiInterface?: Interface\n  ) {\n    const mutatedBytes = bytes;\n\n    try {\n      if (!abiInterface) {\n        throw new Error(\n          'Cannot validate configurable constants because the Predicate was instantiated without a JSON ABI'\n        );\n      }\n\n      if (Object.keys(abiInterface.configurables).length === 0) {\n        throw new Error('Predicate has no configurable constants to be set');\n      }\n\n      Object.entries(configurableConstants).forEach(([key, value]) => {\n        if (!abiInterface?.configurables[key]) {\n          throw new Error(`No configurable constant named '${key}' found in the Predicate`);\n        }\n\n        const { offset } = abiInterface.configurables[key];\n\n        const encoded = abiInterface.encodeConfigurable(key, value as InputValue);\n\n        mutatedBytes.set(encoded, offset);\n      });\n    } catch (err) {\n      throw new FuelError(\n        ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,\n        `Error setting configurable constants: ${(<Error>err).message}.`\n      );\n    }\n\n    return mutatedBytes;\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { concat, hexlify, arrayify } from '@ethersproject/bytes';\nimport { hash, uint64ToBytesBE } from '@fuel-ts/hasher';\nimport { calcRoot } from '@fuel-ts/merkle';\nimport { chunkAndPadBytes } from '@fuel-ts/utils';\n\n/**\n * @hidden\n *\n * Calculates the predicate root for a given bytecode and chain ID.\n *\n * @param bytecode - The bytecode represented as a BytesLike object.\n * @param chainId - The ID of the chain associated with the bytecode.\n * @returns The predicate root as a string.\n */\nexport const getPredicateRoot = (bytecode: BytesLike, chainId: number): string => {\n  const chunkSize = 16 * 1024;\n  const bytes = arrayify(bytecode);\n  const chunks = chunkAndPadBytes(bytes, chunkSize);\n  const chainIdBytes = uint64ToBytesBE(chainId);\n  const codeRoot = calcRoot(chunks.map((c) => hexlify(c)));\n\n  const predicateRoot = hash(concat(['0x4655454C', chainIdBytes, codeRoot]));\n  return predicateRoot;\n};\n"],"mappings":"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","names":["hexlify","arrayify","hexlify","arrayify"]}