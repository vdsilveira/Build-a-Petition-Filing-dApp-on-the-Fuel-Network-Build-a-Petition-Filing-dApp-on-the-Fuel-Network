"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HDWallet: () => hdwallet_default
});
module.exports = __toCommonJS(src_exports);

// src/hdwallet.ts
var import_basex = require("@ethersproject/basex");
var import_bytes = require("@ethersproject/bytes");
var import_sha2 = require("@ethersproject/sha2");
var import_errors = require("@fuel-ts/errors");
var import_math = require("@fuel-ts/math");
var import_mnemonic = require("@fuel-ts/mnemonic");
var import_signer = require("@fuel-ts/signer");
var HARDENED_INDEX = 2147483648;
var MainnetPRV = (0, import_bytes.hexlify)("0x0488ade4");
var MainnetPUB = (0, import_bytes.hexlify)("0x0488b21e");
var TestnetPRV = (0, import_bytes.hexlify)("0x04358394");
var TestnetPUB = (0, import_bytes.hexlify)("0x043587cf");
function base58check(data) {
  return import_basex.Base58.encode((0, import_bytes.concat)([data, (0, import_bytes.hexDataSlice)((0, import_sha2.sha256)((0, import_sha2.sha256)(data)), 0, 4)]));
}
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV : MainnetPRV;
}
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes((0, import_bytes.hexlify)(extendedKey.slice(0, 4)));
}
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV, TestnetPRV, MainnetPUB, TestnetPUB].includes(
    (0, import_bytes.hexlify)(extendedKey.slice(0, 4))
  );
}
function parsePath(path, depth = 0) {
  const components = path.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new import_errors.FuelError(import_errors.ErrorCode.HD_WALLET_ERROR, `invalid path - ${path}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
  );
}
var HDWallet = class {
  depth = 0;
  index = 0;
  fingerprint = (0, import_bytes.hexlify)("0x00000000");
  parentFingerprint = (0, import_bytes.hexlify)("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config) {
    if (config.privateKey) {
      const signer = new import_signer.Signer(config.privateKey);
      this.publicKey = (0, import_bytes.hexlify)(signer.compressedPublicKey);
      this.privateKey = (0, import_bytes.hexlify)(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new import_errors.FuelError(
          import_errors.ErrorCode.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = (0, import_bytes.hexlify)(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = (0, import_bytes.hexDataSlice)((0, import_sha2.ripemd160)((0, import_sha2.sha256)(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && (0, import_bytes.arrayify)(this.privateKey);
    const publicKey = (0, import_bytes.arrayify)(this.publicKey);
    const chainCode = (0, import_bytes.arrayify)(this.chainCode);
    const data = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new import_errors.FuelError(
          import_errors.ErrorCode.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data.set(privateKey, 1);
    } else {
      data.set((0, import_bytes.arrayify)(this.publicKey));
    }
    data.set((0, import_math.toBytes)(index, 4), 33);
    const bytes = (0, import_bytes.arrayify)((0, import_sha2.computeHmac)(import_sha2.SupportedAlgorithm.sha512, chainCode, data));
    const IL = bytes.slice(0, 32);
    const IR = bytes.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = (0, import_math.bn)(IL).add(privateKey).mod(N).toBytes(32);
      return new HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new import_signer.Signer((0, import_bytes.hexlify)(IL));
    const Ki = signer.addPoint(publicKey);
    return new HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path) {
    const paths = parsePath(path, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new import_errors.FuelError(
        import_errors.ErrorCode.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = (0, import_bytes.hexlify)(this.depth);
    const parentFingerprint = this.parentFingerprint;
    const index = (0, import_math.toHex)(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? (0, import_bytes.concat)(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = (0, import_bytes.concat)([prefix, depth, parentFingerprint, index, chainCode, key]);
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed) {
    const masterKey = import_mnemonic.Mnemonic.masterKeysFromSeed(seed);
    return new HDWallet({
      chainCode: (0, import_bytes.arrayify)(masterKey.slice(32)),
      privateKey: (0, import_bytes.arrayify)(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const bytes = import_basex.Base58.decode(extendedKey);
    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;
    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {
      throw new import_errors.FuelError(import_errors.ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum)
      throw new import_errors.FuelError(import_errors.ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    const depth = bytes[4];
    const parentFingerprint = (0, import_bytes.hexlify)(bytes.slice(5, 9));
    const index = parseInt((0, import_bytes.hexlify)(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = (0, import_bytes.hexlify)(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new import_errors.FuelError(
        import_errors.ErrorCode.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes)) {
      if (key[0] !== 3) {
        throw new import_errors.FuelError(import_errors.ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new import_errors.FuelError(import_errors.ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HDWallet
});
//# sourceMappingURL=index.js.map