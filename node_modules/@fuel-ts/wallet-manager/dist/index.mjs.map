{"version":3,"sources":["../src/wallet-manager.ts","../src/storages/memory-storage.ts","../src/vaults/mnemonic-vault.ts","../src/vaults/privatekey-vault.ts","../src/types.ts"],"sourcesContent":["import type { Keystore } from '@fuel-ts/crypto';\nimport { encrypt, decrypt } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { EventEmitter } from 'events';\n\nimport MemoryStorage from './storages/memory-storage';\nimport type {\n  StorageAbstract,\n  Account,\n  VaultConfig,\n  VaultsState,\n  WalletManagerOptions,\n  WalletManagerState,\n  Vault,\n} from './types';\nimport { MnemonicVault } from './vaults/mnemonic-vault';\nimport { PrivateKeyVault } from './vaults/privatekey-vault';\n\nconst ERROR_MESSAGES = {\n  invalid_vault_type: 'The provided Vault type is invalid.',\n  address_not_found: 'No private key found for address the specified wallet address.',\n  vault_not_found: 'The specified vault was not found.',\n  wallet_not_unlocked: 'The wallet is currently locked.',\n  passphrase_not_match: 'The provided passphrase did not match the expected value.',\n};\n\n/**\n * Generic assert function to avoid undesirable errors\n */\nfunction assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new FuelError(ErrorCode.WALLET_MANAGER_ERROR, message);\n  }\n}\n\n/**\n * WalletManager is a upper package to manage multiple vaults like mnemonic and privateKeys.\n *\n * - VaultTypes can be add to `WalletManager.Vaults` enabling to add custom Vault types.\n * - Storage can be instantiate when initializing enabling custom storage types.\n */\nexport class WalletManager extends EventEmitter {\n  /**\n   * Vaults\n   *\n   * Vaults are responsible to store secret keys and return an `Wallet` instance,\n   * to interact with the network.\n   *\n   * Each vault has access to its own state\n   *\n   */\n  static Vaults = [MnemonicVault, PrivateKeyVault];\n  /**\n   * Storage\n   *\n   * Persistent encrypted data. `The default storage works only on memory`.\n   */\n  readonly storage: StorageAbstract = new MemoryStorage();\n  /* Key name passed to the storage */\n  readonly STORAGE_KEY: string = 'WalletManager';\n\n  // `This variables are only accessible from inside the class`\n  #vaults: VaultsState = [];\n  #passphrase = '';\n  #isLocked: boolean = true;\n\n  constructor(options?: WalletManagerOptions) {\n    super();\n    this.storage = options?.storage || this.storage;\n  }\n\n  get isLocked(): boolean {\n    return this.#isLocked;\n  }\n\n  /**\n   * Return the vault serialized object containing all the privateKeys,\n   * the format of the return depends on the Vault type.\n   */\n  exportVault<T extends Vault>(vaultId: number): ReturnType<T['serialize']> {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((_, idx) => idx === vaultId);\n    assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    return vaultState.vault.serialize() as ReturnType<T['serialize']>;\n  }\n\n  /**\n   * List all vaults on the Wallet Manager, this function not return secret's\n   */\n  getVaults(): Array<{ title?: string; type: string; vaultId: number }> {\n    return this.#vaults.map((v, idx) => ({\n      title: v.title,\n      type: v.type,\n      vaultId: idx,\n    }));\n  }\n\n  /**\n   * List all accounts on the Wallet Manager not vault information is revealed\n   */\n  getAccounts(): Array<Account> {\n    // Return all accounts from vaults\n    return this.#vaults.flatMap<Account>((vaultState, vaultId) =>\n      vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))\n    );\n  }\n\n  /**\n   * Create a Wallet instance for the specific account\n   */\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const vaultState = this.#vaults.find((vs) =>\n      vs.vault.getAccounts().find((a) => a.address.equals(address))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n\n    return vaultState.vault.getWallet(address);\n  }\n\n  /**\n   * Export specific account privateKey\n   */\n  exportPrivateKey(address: AbstractAddress) {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((vs) =>\n      vs.vault.getAccounts().find((a) => a.address.equals(address))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n\n    return vaultState.vault.exportAccount(address);\n  }\n\n  /**\n   * Add account to a selected vault or on the first vault as default.\n   * If not vaults are adds it will return error\n   */\n  async addAccount(options?: { vaultId: number }) {\n    // Make sure before add new vault state is fully loaded\n    await this.loadState();\n    // Get vault instance\n    const vaultState = this.#vaults[options?.vaultId || 0];\n    await assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    // Add account on vault\n    const account = vaultState.vault.addAccount();\n    // Save the accounts state\n    await this.saveState();\n    // Return account\n    return account;\n  }\n\n  /**\n   * Remove vault by index, by remove the vault you also remove all accounts\n   * created by the vault.\n   */\n  async removeVault(index: number) {\n    this.#vaults.splice(index, 1);\n    await this.saveState();\n  }\n\n  /**\n   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if\n   * didn't found it will throw.\n   */\n  async addVault(vaultConfig: VaultConfig) {\n    // Make sure before add new vault state is fully loaded\n    await this.loadState();\n    // Check if vault is supported\n    const Vault = this.getVaultClass(vaultConfig.type);\n    // create Vault instance\n    const vault = new Vault(vaultConfig);\n    // Push vaults to state\n    this.#vaults = this.#vaults.concat({\n      title: vaultConfig.title,\n      type: vaultConfig.type,\n      vault,\n    });\n    // Persist data on storage\n    await this.saveState();\n  }\n\n  /**\n   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and\n   * secrets.\n   */\n  lock() {\n    this.#isLocked = true;\n    // Clean state vaults from state\n    this.#vaults = [];\n    // Clean password from state\n    this.#passphrase = '';\n    // Emit event that wallet is locked\n    this.emit('lock');\n  }\n\n  /**\n   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.\n   * Vaults with secrets are not unlocked or instantiated on this moment.\n   */\n  async unlock(passphrase: string) {\n    // Set password on state\n    this.#passphrase = passphrase;\n    // Set locked state to false\n    this.#isLocked = false;\n    // Try to load state with passphrase\n    try {\n      // Load state with passphrase\n      await this.loadState();\n      // Emit event that wallet is unlocked\n      this.emit('unlock');\n    } catch (err) {\n      // If passphrase is wrong lock wallet\n      await this.lock();\n      // Forward error\n      throw err;\n    }\n  }\n\n  /**\n   * Update WalletManager encryption passphrase\n   */\n  async updatePassphrase(oldpass: string, newpass: string) {\n    const isLocked = this.#isLocked;\n    // Unlock wallet to decrypt data\n    await this.unlock(oldpass);\n    // Set new password on state\n    this.#passphrase = newpass;\n    // Persist data on storage\n    await this.saveState();\n    // Load state with new password\n    await this.loadState();\n    // If wallet was locked, lock the wallet again\n    if (isLocked) {\n      await this.lock();\n    }\n  }\n\n  /**\n   * Retrieve and decrypt WalletManager state from storage\n   */\n  async loadState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n\n    const data = await this.storage.getItem(this.STORAGE_KEY);\n    if (data) {\n      const state = await decrypt<WalletManagerState>(this.#passphrase, <Keystore>JSON.parse(data));\n      this.#vaults = this.#deserializeVaults(state.vaults);\n    }\n  }\n\n  /**\n   * Store encrypted WalletManager state on storage\n   */\n  private async saveState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n\n    const encryptedData = await encrypt(this.#passphrase, {\n      vaults: this.#serializeVaults(this.#vaults),\n    });\n    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));\n    this.emit('update');\n  }\n\n  /**\n   * Serialize all vaults to store\n   *\n   * `This is only accessible from inside the class`\n   */\n  #serializeVaults(vaults: VaultsState) {\n    return vaults.map(({ title, type, vault }) => ({\n      title,\n      type,\n      data: vault.serialize(),\n    }));\n  }\n\n  /**\n   * Deserialize all vaults to state\n   *\n   * `This is only accessible from inside the class`\n   */\n  #deserializeVaults(vaults: VaultsState) {\n    return vaults.map(({ title, type, data: vaultConfig }) => {\n      const VaultClass = this.getVaultClass(type);\n      return {\n        title,\n        type,\n        vault: new VaultClass(<VaultConfig>vaultConfig),\n      };\n    });\n  }\n\n  /**\n   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.\n   */\n  private getVaultClass(type: string) {\n    const VaultClass = WalletManager.Vaults.find((v) => v.type === type);\n\n    assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);\n\n    return VaultClass;\n  }\n}\n","import type { StorageAbstract } from '../types';\n\nclass MemoryStorage implements StorageAbstract {\n  storage = new Map<string, unknown>();\n\n  async getItem<T>(key: string): Promise<T | null> {\n    const item = await this.storage.get(key);\n    return item as T | null;\n  }\n\n  async setItem(key: string, value: string) {\n    await this.storage.set(key, value);\n  }\n\n  async removeItem(key: string) {\n    await this.storage.delete(key);\n  }\n\n  async clear() {\n    await this.storage.clear();\n  }\n}\n\nexport default MemoryStorage;\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport { Mnemonic } from '@fuel-ts/mnemonic';\nimport type { Provider } from '@fuel-ts/providers';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { Wallet } from '@fuel-ts/wallet';\n\nimport type { Vault } from '../types';\n\ninterface MnemonicVaultOptions {\n  secret?: string;\n  rootPath?: string;\n  numberOfAccounts?: number | null;\n  provider: Provider;\n}\n\nexport class MnemonicVault implements Vault<MnemonicVaultOptions> {\n  static readonly type = 'mnemonic';\n  readonly #secret: string;\n\n  pathKey = '{}';\n  rootPath: string = `m/44'/1179993420'/${this.pathKey}'/0/0`;\n  numberOfAccounts: number = 0;\n  provider: Provider;\n\n  constructor(options: MnemonicVaultOptions) {\n    this.#secret = options.secret || Mnemonic.generate();\n    this.rootPath = options.rootPath || this.rootPath;\n    // On creating the vault also adds one account\n    this.numberOfAccounts = options.numberOfAccounts || 1;\n    this.provider = options.provider;\n  }\n\n  getDerivePath(index: number) {\n    if (this.rootPath.includes(this.pathKey)) {\n      return this.rootPath.replace(this.pathKey, String(index));\n    }\n    return `${this.rootPath}/${index}`;\n  }\n\n  serialize(): MnemonicVaultOptions {\n    return {\n      secret: this.#secret,\n      rootPath: this.rootPath,\n      numberOfAccounts: this.numberOfAccounts,\n      provider: this.provider,\n    };\n  }\n\n  getAccounts() {\n    const accounts = [];\n    let numberOfAccounts = 0;\n\n    // Create all accounts to current vault\n    do {\n      const wallet = Wallet.fromMnemonic(\n        this.#secret,\n        this.provider,\n        this.getDerivePath(numberOfAccounts)\n      );\n      accounts.push({\n        publicKey: wallet.publicKey,\n        address: wallet.address,\n      });\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n\n    return accounts;\n  }\n\n  addAccount() {\n    this.numberOfAccounts += 1;\n    const wallet = Wallet.fromMnemonic(\n      this.#secret,\n      this.provider,\n      this.getDerivePath(this.numberOfAccounts - 1)\n    );\n\n    return {\n      publicKey: wallet.publicKey,\n      address: wallet.address,\n    };\n  }\n\n  exportAccount(address: AbstractAddress): string {\n    let numberOfAccounts = 0;\n\n    // Look for the account that has the same address\n    do {\n      const wallet = Wallet.fromMnemonic(\n        this.#secret,\n        this.provider,\n        this.getDerivePath(numberOfAccounts)\n      );\n      if (wallet.address.equals(address)) {\n        return wallet.privateKey;\n      }\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n\n    throw new FuelError(\n      ErrorCode.WALLET_MANAGER_ERROR,\n      `Account with address '${address}' not found in derived wallets.`\n    );\n  }\n\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey, this.provider);\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Provider } from '@fuel-ts/providers';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { Wallet } from '@fuel-ts/wallet';\n\nimport type { Account, Vault } from '../types';\n\ninterface PkVaultOptions {\n  secret?: string;\n  accounts?: Array<string>;\n  provider: Provider;\n}\n\nexport class PrivateKeyVault implements Vault<PkVaultOptions> {\n  static readonly type = 'privateKey';\n  provider: Provider;\n\n  #privateKeys: Array<string> = [];\n\n  /**\n   * If privateKey vault is initialized with a secretKey, it creates\n   * one account with the fallowing secret\n   */\n  constructor(options: PkVaultOptions) {\n    this.provider = options.provider;\n    if (options.secret) {\n      this.#privateKeys = [options.secret];\n    } else {\n      this.#privateKeys = options.accounts || [\n        Wallet.generate({\n          provider: options.provider,\n        }).privateKey,\n      ];\n    }\n  }\n\n  serialize(): PkVaultOptions {\n    return {\n      accounts: this.#privateKeys,\n      provider: this.provider,\n    };\n  }\n\n  getPublicAccount(privateKey: string) {\n    const wallet = Wallet.fromPrivateKey(privateKey, this.provider);\n    return {\n      address: wallet.address,\n      publicKey: wallet.publicKey,\n    };\n  }\n\n  getAccounts(): Account[] {\n    return this.#privateKeys.map((pk) => this.getPublicAccount(pk));\n  }\n\n  addAccount() {\n    const wallet = Wallet.generate({\n      provider: this.provider,\n    });\n\n    this.#privateKeys.push(wallet.privateKey);\n\n    return this.getPublicAccount(wallet.privateKey);\n  }\n\n  exportAccount(address: AbstractAddress): string {\n    const privateKey = this.#privateKeys.find((pk) =>\n      Wallet.fromPrivateKey(pk, this.provider).address.equals(address)\n    );\n\n    if (!privateKey) {\n      throw new FuelError(\n        ErrorCode.WALLET_MANAGER_ERROR,\n        `No private key found for address '${address}'.`\n      );\n    }\n\n    return privateKey;\n  }\n\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey, this.provider);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Provider } from '@fuel-ts/providers';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\n\nexport type Account = {\n  address: AbstractAddress;\n  publicKey: string;\n  vaultId?: number;\n};\n\nexport type WalletManagerOptions = {\n  storage: StorageAbstract;\n};\n\nexport type VaultConfig = {\n  type: string;\n  title?: string;\n  secret?: string;\n  provider: Provider;\n};\n\nexport type VaultsState = Array<{\n  type: string;\n  title?: string;\n  data?: VaultConfig;\n  vault: Vault;\n}>;\n\nexport interface WalletManagerState {\n  vaults: VaultsState;\n}\n\nexport abstract class Vault<TOptions = { secret?: string }> {\n  static readonly type: string;\n\n  constructor(_options: TOptions) {\n    throw new FuelError(ErrorCode.NOT_IMPLEMENTED, 'Not implemented.');\n  }\n\n  serialize(): TOptions {\n    throw new FuelError(ErrorCode.NOT_IMPLEMENTED, 'Not implemented.');\n  }\n\n  getAccounts(): Account[] {\n    throw new FuelError(ErrorCode.NOT_IMPLEMENTED, 'Not implemented.');\n  }\n\n  addAccount(): Account {\n    throw new FuelError(ErrorCode.NOT_IMPLEMENTED, 'Not implemented.');\n  }\n\n  exportAccount(_address: AbstractAddress): string {\n    throw new FuelError(ErrorCode.NOT_IMPLEMENTED, 'Not implemented.');\n  }\n\n  getWallet(_address: AbstractAddress): WalletUnlocked {\n    throw new FuelError(ErrorCode.NOT_IMPLEMENTED, 'Not implemented.');\n  }\n}\n\nexport abstract class StorageAbstract {\n  abstract setItem(key: string, value: string): Promise<void>;\n  abstract getItem(key: string): Promise<string | null | undefined>;\n  abstract removeItem(key: string): Promise<void>;\n  abstract clear(): Promise<void>;\n}\n"],"mappings":"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","names":["ErrorCode","FuelError","ErrorCode","FuelError","Wallet","Wallet","FuelError","ErrorCode","FuelError","ErrorCode","Vault","ErrorCode","FuelError","FuelError","ErrorCode"]}