// ../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.7.0";

// ../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode3) {
  ErrorCode3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode3["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode3["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode3["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode3["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode3["TIMEOUT"] = "TIMEOUT";
  ErrorCode3["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode3["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode3["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode3["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode3["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode3["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode3["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode3["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode3["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode3["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode3["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode3["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode3["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version3) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version3,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version3) {
    return new Logger(version3);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// ../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.7.0";

// ../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}

// src/test-utils/getForcProject.ts
import { existsSync, readFileSync } from "fs";
import { basename, join } from "path";

// ../versions/dist/index.mjs
function getSupportedVersions() {
  return {
    FORC: "0.44.0",
    FUEL_CORE: "0.20.5",
    FUELS: "0.60.0"
  };
}
var versions = getSupportedVersions();

// ../errors/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ErrorCode2 = /* @__PURE__ */ ((ErrorCode22) => {
  ErrorCode22["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
  ErrorCode22["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
  ErrorCode22["INVALID_COMPONENT"] = "invalid-component";
  ErrorCode22["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
  ErrorCode22["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
  ErrorCode22["TYPE_NOT_FOUND"] = "type-not-found";
  ErrorCode22["TYPE_NOT_SUPPORTED"] = "type-not-supported";
  ErrorCode22["INVALID_DECODE_VALUE"] = "invalid-decode-value";
  ErrorCode22["JSON_ABI_ERROR"] = "json-abi-error";
  ErrorCode22["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
  ErrorCode22["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
  ErrorCode22["CODER_NOT_FOUND"] = "coder-not-found";
  ErrorCode22["FUNCTION_NOT_FOUND"] = "function-not-found";
  ErrorCode22["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
  ErrorCode22["INVALID_URL"] = "invalid-url";
  ErrorCode22["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
  ErrorCode22["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
  ErrorCode22["MISSING_PROVIDER"] = "missing-provider";
  ErrorCode22["INSUFFICIENT_BALANCE"] = "insufficient-balance";
  ErrorCode22["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
  ErrorCode22["HD_WALLET_ERROR"] = "hd-wallet-error";
  ErrorCode22["PARSE_FAILED"] = "parse-failed";
  ErrorCode22["ENCODE_ERROR"] = "encode-error";
  ErrorCode22["DECODE_ERROR"] = "decode-error";
  ErrorCode22["INVALID_CREDENTIALS"] = "invalid-credentials";
  ErrorCode22["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
  ErrorCode22["INVALID_TTL"] = "invalid-ttl";
  ErrorCode22["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
  ErrorCode22["NOT_IMPLEMENTED"] = "not-implemented";
  ErrorCode22["NOT_SUPPORTED"] = "not-supported";
  ErrorCode22["CONVERTING_FAILED"] = "converting-error";
  ErrorCode22["ELEMENT_NOT_FOUND"] = "element-not-found";
  ErrorCode22["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
  ErrorCode22["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
  ErrorCode22["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
  ErrorCode22["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
  ErrorCode22["TRANSACTION_FAILED"] = "transaction-failed";
  ErrorCode22["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
  ErrorCode22["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
  ErrorCode22["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
  ErrorCode22["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
  ErrorCode22["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
  ErrorCode22["TRANSACTION_ERROR"] = "transaction-error";
  ErrorCode22["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
  ErrorCode22["INVALID_WORD_LIST"] = "invalid-word-list";
  ErrorCode22["INVALID_MNEMONIC"] = "invalid-mnemonic";
  ErrorCode22["INVALID_ENTROPY"] = "invalid-entropy";
  ErrorCode22["INVALID_SEED"] = "invalid-seed";
  ErrorCode22["INVALID_CHECKSUM"] = "invalid-checksum";
  ErrorCode22["INVALID_PASSWORD"] = "invalid-password";
  ErrorCode22["ACCOUNT_REQUIRED"] = "account-required";
  ErrorCode22["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
  ErrorCode22["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
  ErrorCode22["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
  ErrorCode22["INVALID_MULTICALL"] = "invalid-multicall";
  ErrorCode22["SCRIPT_REVERTED"] = "script-reverted";
  ErrorCode22["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
  ErrorCode22["FUEL_NODE_ERROR"] = "fuel-node-error";
  return ErrorCode22;
})(ErrorCode2 || {});
var _FuelError = class extends Error {
  VERSIONS = versions;
  static parse(e) {
    const error = e;
    if (error.code === void 0) {
      throw new _FuelError(
        "parse-failed",
        "Failed to parse the error object. The required 'code' property is missing."
      );
    }
    const enumValues = Object.values(ErrorCode2);
    const codeIsKnown = enumValues.includes(error.code);
    if (!codeIsKnown) {
      throw new _FuelError(
        "parse-failed",
        `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`
      );
    }
    return new _FuelError(error.code, error.message);
  }
  code;
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "FuelError";
  }
  toObject() {
    const { code, name, message, VERSIONS } = this;
    return { code, name, message, VERSIONS };
  }
};
var FuelError = _FuelError;
__publicField(FuelError, "CODES", ErrorCode2);

// src/utils/normalizeString.ts
var normalizeString = (str) => {
  const transformations = [
    (s) => s.replace(/\s+/g, "-"),
    // spaces to -
    (s) => s.replace(/\./g, "-"),
    // dots to -
    (s) => s.replace(/_/g, "-"),
    // underscore to -
    (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()),
    // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ""),
    // delete any '-' left
    (s) => s.replace(/^\d+/, ""),
    // removes leading digits
    (s) => s[0].toUpperCase() + s.slice(1)
    // capitalize first letter
  ];
  const output = transformations.reduce((s, t) => t(s), str);
  if (output === "") {
    const errMsg = `The provided string '${str}' results in an empty output after`.concat(
      ` normalization, therefore, it can't normalize string.`
    );
    throw new FuelError(ErrorCode2.PARSE_FAILED, errMsg);
  }
  return output;
};

// src/test-utils/getForcProject.ts
var getProjectDebugDir = (params) => join(params.projectDir, "out", "debug");
var getProjectTempDir = (params) => join(getProjectDebugDir(params), "__temp__");
var getProjectAbiPath = (params) => join(getProjectDebugDir(params), `${params.projectName}-abi.json`);
var getProjectBinPath = (params) => join(getProjectDebugDir(params), `${params.projectName}.bin`);
var getProjectStorageSlotsPath = (params) => join(getProjectDebugDir(params), `${params.projectName}-storage_slots.json`);
var getProjectAbiName = (params) => `${params.projectName}-abi`;
var getProjectNormalizedName = (params) => normalizeString(params.projectName);
var getProjectAbi = (params) => {
  const projectPath = getProjectAbiPath(params);
  const abiContents = JSON.parse(readFileSync(projectPath, "utf-8"));
  return abiContents;
};
var getProjectStorageSlots = (params) => {
  const storageSlotsFilePath = getProjectStorageSlotsPath(params);
  if (!existsSync(storageSlotsFilePath)) {
    return [];
  }
  const storageSlots = JSON.parse(readFileSync(storageSlotsFilePath, "utf-8"));
  return storageSlots;
};
var getForcProject = (projectDir) => {
  const projectName = basename(projectDir);
  const params = {
    projectDir,
    projectName
  };
  const debugDir = getProjectDebugDir(params);
  const tempDir = getProjectTempDir(params);
  const binPath = getProjectBinPath(params);
  const binHexlified = hexlify(readFileSync(binPath));
  const abiPath = getProjectAbiPath(params);
  const abiName = getProjectAbiName(params);
  const abiContents = getProjectAbi(params);
  const normalizedName = getProjectNormalizedName(params);
  const storageSlots = getProjectStorageSlots(params);
  const inputGlobal = `${debugDir}/*-abi.json`;
  return {
    name: projectName,
    storageSlots,
    normalizedName,
    debugDir,
    tempDir,
    binPath,
    binHexlified,
    abiPath,
    abiName,
    abiContents,
    inputGlobal
  };
};
export {
  getForcProject,
  getProjectAbi,
  getProjectAbiName,
  getProjectAbiPath,
  getProjectBinPath,
  getProjectDebugDir,
  getProjectNormalizedName,
  getProjectStorageSlots,
  getProjectStorageSlotsPath,
  getProjectTempDir
};
//# sourceMappingURL=test-utils.mjs.map