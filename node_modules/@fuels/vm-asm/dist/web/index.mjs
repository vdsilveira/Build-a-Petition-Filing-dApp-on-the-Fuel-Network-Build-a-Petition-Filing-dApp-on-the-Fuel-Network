let wasm$1;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
*Adds two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function add(dst, lhs, rhs) {
    const ret = wasm$1.add(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function and(dst, lhs, rhs) {
    const ret = wasm$1.and(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function div(dst, lhs, rhs) {
    const ret = wasm$1.div(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for equality.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function eq(dst, lhs, rhs) {
    const ret = wasm$1.eq(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of another.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function exp(dst, lhs, rhs) {
    const ret = wasm$1.exp(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for greater-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function gt(dst, lhs, rhs) {
    const ret = wasm$1.gt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for less-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function lt(dst, lhs, rhs) {
    const ret = wasm$1.lt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer logarithm of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mlog(dst, lhs, rhs) {
    const ret = wasm$1.mlog(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer root of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mroo(dst, lhs, rhs) {
    const ret = wasm$1.mroo(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mod_(dst, lhs, rhs) {
    const ret = wasm$1.mod_(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Copy from one register to another.
* @param {number} dst
* @param {number} src
* @returns {Instruction}
*/
function move_(dst, src) {
    const ret = wasm$1.move_(dst, src);
    return Instruction.__wrap(ret);
}

/**
*Multiplies two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mul(dst, lhs, rhs) {
    const ret = wasm$1.mul(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise NOT a register.
* @param {number} dst
* @param {number} arg
* @returns {Instruction}
*/
function not(dst, arg) {
    const ret = wasm$1.not(dst, arg);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function or(dst, lhs, rhs) {
    const ret = wasm$1.or(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sll(dst, lhs, rhs) {
    const ret = wasm$1.sll(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srl(dst, lhs, rhs) {
    const ret = wasm$1.srl(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sub(dst, lhs, rhs) {
    const ret = wasm$1.sub(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xor(dst, lhs, rhs) {
    const ret = wasm$1.xor(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide with arbitrary precision intermediate step.
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function mldv(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Return from context.
* @param {number} value
* @returns {Instruction}
*/
function ret(value) {
    const ret = wasm$1.ret(value);
    return Instruction.__wrap(ret);
}

/**
*Return from context with data.
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function retd(addr, len) {
    const ret = wasm$1.retd(addr, len);
    return Instruction.__wrap(ret);
}

/**
*Allocate a number of bytes from the heap.
* @param {number} bytes
* @returns {Instruction}
*/
function aloc(bytes) {
    const ret = wasm$1.aloc(bytes);
    return Instruction.__wrap(ret);
}

/**
*Clear a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} len
* @returns {Instruction}
*/
function mcl(dst_addr, len) {
    const ret = wasm$1.mcl(dst_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Copy a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcp(dst_addr, src_addr, len) {
    const ret = wasm$1.mcp(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Compare bytes in memory.
* @param {number} result
* @param {number} lhs_addr
* @param {number} rhs_addr
* @param {number} len
* @returns {Instruction}
*/
function meq(result, lhs_addr, rhs_addr, len) {
    const ret = wasm$1.meq(result, lhs_addr, rhs_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get block header hash for height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function bhsh(dst, heigth) {
    const ret = wasm$1.bhsh(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Get current block height.
* @param {number} dst
* @returns {Instruction}
*/
function bhei(dst) {
    const ret = wasm$1.bhei(dst);
    return Instruction.__wrap(ret);
}

/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function burn(amount, sub_id_addr) {
    const ret = wasm$1.burn(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Call a contract.
* @param {number} target_struct
* @param {number} fwd_coins
* @param {number} asset_id_addr
* @param {number} fwd_gas
* @returns {Instruction}
*/
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
    const ret = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
    return Instruction.__wrap(ret);
}

/**
*Copy contract code for a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ccp(dst_addr, contract_id_addr, offset, len) {
    const ret = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Get code root of a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function croo(dst_addr, contract_id_addr) {
    const ret = wasm$1.croo(dst_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get code size of a contract.
* @param {number} dst
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function csiz(dst, contract_id_addr) {
    const ret = wasm$1.csiz(dst, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get current block proposer's address.
* @param {number} dst
* @returns {Instruction}
*/
function cb(dst) {
    const ret = wasm$1.cb(dst);
    return Instruction.__wrap(ret);
}

/**
*Load a contract's code as executable.
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ldc(contract_id_addr, offset, len) {
    const ret = wasm$1.ldc(contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Log an event.
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function log(a, b, c, d) {
    const ret = wasm$1.log(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
*Log data.
* @param {number} a
* @param {number} b
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function logd(a, b, addr, len) {
    const ret = wasm$1.logd(a, b, addr, len);
    return Instruction.__wrap(ret);
}

/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function mint(amount, sub_id_addr) {
    const ret = wasm$1.mint(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Halt execution, reverting state changes and returning a value.
* @param {number} value
* @returns {Instruction}
*/
function rvrt(value) {
    const ret = wasm$1.rvrt(value);
    return Instruction.__wrap(ret);
}

/**
*Clear a series of slots from contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} lenq
* @returns {Instruction}
*/
function scwq(key_addr, status, lenq) {
    const ret = wasm$1.scwq(key_addr, status, lenq);
    return Instruction.__wrap(ret);
}

/**
*Load a word from contract storage.
* @param {number} dst
* @param {number} status
* @param {number} key_addr
* @returns {Instruction}
*/
function srw(dst, status, key_addr) {
    const ret = wasm$1.srw(dst, status, key_addr);
    return Instruction.__wrap(ret);
}

/**
*Load a series of 32 byte slots from contract storage.
* @param {number} dst_addr
* @param {number} status
* @param {number} key_addr
* @param {number} lenq
* @returns {Instruction}
*/
function srwq(dst_addr, status, key_addr, lenq) {
    const ret = wasm$1.srwq(dst_addr, status, key_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Store a word in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} value
* @returns {Instruction}
*/
function sww(key_addr, status, value) {
    const ret = wasm$1.sww(key_addr, status, value);
    return Instruction.__wrap(ret);
}

/**
*Store a series of 32 byte slots in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} src_addr
* @param {number} lenq
* @returns {Instruction}
*/
function swwq(key_addr, status, src_addr, lenq) {
    const ret = wasm$1.swwq(key_addr, status, src_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a contract unconditionally.
* @param {number} contract_id_addr
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tr(contract_id_addr, amount, asset_id_addr) {
    const ret = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a variable output.
* @param {number} contract_id_addr
* @param {number} output_index
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tro(contract_id_addr, output_index, amount, asset_id_addr) {
    const ret = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function eck1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ecr1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*Verify ED25519 public key and signature match a 32-byte message.
* @param {number} pub_key_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ed19(pub_key_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ed19(pub_key_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The keccak-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function k256(dst_addr, src_addr, len) {
    const ret = wasm$1.k256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*The SHA-2-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function s256(dst_addr, src_addr, len) {
    const ret = wasm$1.s256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get timestamp of block at given height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function time(dst, heigth) {
    const ret = wasm$1.time(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Performs no operation.
* @returns {Instruction}
*/
function noop() {
    const ret = wasm$1.noop();
    return Instruction.__wrap(ret);
}

/**
*Set flag register to a register.
* @param {number} value
* @returns {Instruction}
*/
function flag(value) {
    const ret = wasm$1.flag(value);
    return Instruction.__wrap(ret);
}

/**
*Get the balance of contract of an asset ID.
* @param {number} dst
* @param {number} asset_id_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function bal(dst, asset_id_addr, contract_id_addr) {
    const ret = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Dynamic jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function jmp(abs_target) {
    const ret = wasm$1.jmp(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Conditional dynamic jump.
* @param {number} abs_target
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function jne(abs_target, lhs, rhs) {
    const ret = wasm$1.jne(abs_target, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Send a message to recipient address with call abi, coins, and output.
* @param {number} recipient_addr
* @param {number} data_addr
* @param {number} data_len
* @param {number} coins
* @returns {Instruction}
*/
function smo(recipient_addr, data_addr, data_len, coins) {
    const ret = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
    return Instruction.__wrap(ret);
}

/**
*Adds a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function addi(dst, lhs, rhs) {
    const ret = wasm$1.addi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function andi(dst, lhs, rhs) {
    const ret = wasm$1.andi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function divi(dst, lhs, rhs) {
    const ret = wasm$1.divi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function expi(dst, lhs, rhs) {
    const ret = wasm$1.expi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function modi(dst, lhs, rhs) {
    const ret = wasm$1.modi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Multiplies a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function muli(dst, lhs, rhs) {
    const ret = wasm$1.muli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function ori(dst, lhs, rhs) {
    const ret = wasm$1.ori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function slli(dst, lhs, rhs) {
    const ret = wasm$1.slli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srli(dst, lhs, rhs) {
    const ret = wasm$1.srli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function subi(dst, lhs, rhs) {
    const ret = wasm$1.subi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xori(dst, lhs, rhs) {
    const ret = wasm$1.xori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} abs_target
* @returns {Instruction}
*/
function jnei(cond_lhs, cond_rhs, abs_target) {
    const ret = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
    return Instruction.__wrap(ret);
}

/**
*A byte is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lb(dst, addr, offset) {
    const ret = wasm$1.lb(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*A word is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lw(dst, addr, offset) {
    const ret = wasm$1.lw(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*Write the least significant byte of a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sb(addr, value, offset) {
    const ret = wasm$1.sb(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Write a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sw(addr, value, offset) {
    const ret = wasm$1.sw(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Copy an immediate number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcpi(dst_addr, src_addr, len) {
    const ret = wasm$1.mcpi(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get transaction fields.
* @param {number} dst
* @param {number} arg
* @param {number} selector
* @returns {Instruction}
*/
function gtf(dst, arg, selector) {
    const ret = wasm$1.gtf(dst, arg, selector);
    return Instruction.__wrap(ret);
}

/**
*Clear an immediate number of bytes in memory.
* @param {number} addr
* @param {number} count
* @returns {Instruction}
*/
function mcli(addr, count) {
    const ret = wasm$1.mcli(addr, count);
    return Instruction.__wrap(ret);
}

/**
*Get metadata from memory.
* @param {number} dst
* @param {number} selector
* @returns {Instruction}
*/
function gm(dst, selector) {
    const ret = wasm$1.gm(dst, selector);
    return Instruction.__wrap(ret);
}

/**
*Copy immediate value into a register
* @param {number} dst
* @param {number} val
* @returns {Instruction}
*/
function movi(dst, val) {
    const ret = wasm$1.movi(dst, val);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump against zero.
* @param {number} cond_nz
* @param {number} abs_target
* @returns {Instruction}
*/
function jnzi(cond_nz, abs_target) {
    const ret = wasm$1.jnzi(cond_nz, abs_target);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump forwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpf(dynamic, fixed) {
    const ret = wasm$1.jmpf(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump backwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpb(dynamic, fixed) {
    const ret = wasm$1.jmpb(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzf(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzf(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzb(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzb(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function ji(abs_target) {
    const ret = wasm$1.ji(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfei(amount) {
    const ret = wasm$1.cfei(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfsi(amount) {
    const ret = wasm$1.cfsi(amount);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfe(amount) {
    const ret = wasm$1.cfe(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfs(amount) {
    const ret = wasm$1.cfs(amount);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshl(bitmask) {
    const ret = wasm$1.pshl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshh(bitmask) {
    const ret = wasm$1.pshh(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function popl(bitmask) {
    const ret = wasm$1.popl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function poph(bitmask) {
    const ret = wasm$1.poph(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Compare 128bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Compare 256bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 128bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 256bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wddv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wddv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqdv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqdv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wdmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wqmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*AddMod 128bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*AddMod 256bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {number} args
* @returns {Instruction}
*/
function gm_args(ra, args) {
    const ret = wasm$1.gm_args(ra, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} args
* @returns {Instruction}
*/
function gtf_args(ra, rb, args) {
    const ret = wasm$1.gtf_args(ra, rb, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wdcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wqcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wdop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wqop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wdml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wqml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wddv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wddv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wqdv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqdv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
    }
    return cachedInt32Memory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
*r" Argument list for GM (get metadata) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GMArgs = Object.freeze({
/**
*r" Get if caller is external.
*/
IsCallerExternal:1,"1":"IsCallerExternal",
/**
*r" Get caller's contract ID.
*/
GetCaller:2,"2":"GetCaller",
/**
*r" Get index of current predicate.
*/
GetVerifyingPredicate:3,"3":"GetVerifyingPredicate",
/**
*r" Get the Chain ID this VM is operating within
*/
GetChainId:4,"4":"GetChainId", });
/**
*r" Argument list for GTF (get tx fields) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GTFArgs = Object.freeze({
/**
*r" Set `$rA` to `tx.type`
*/
Type:1,"1":"Type",
/**
*r" Set `$rA` to `tx.gasPrice`
*/
ScriptGasPrice:2,"2":"ScriptGasPrice",
/**
*r" Set `$rA` to `tx.gasLimit`
*/
ScriptGasLimit:3,"3":"ScriptGasLimit",
/**
*r" Set `$rA` to `tx.maturity`
*/
ScriptMaturity:4,"4":"ScriptMaturity",
/**
*r" Set `$rA` to `tx.scriptLength`
*/
ScriptLength:5,"5":"ScriptLength",
/**
*r" Set `$rA` to `tx.scriptDataLength`
*/
ScriptDataLength:6,"6":"ScriptDataLength",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
ScriptInputsCount:7,"7":"ScriptInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
ScriptOutputsCount:8,"8":"ScriptOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
ScriptWitnessesCound:9,"9":"ScriptWitnessesCound",
/**
*r" Set `$rA` to `Memory address of tx.receiptsRoot`
*/
ScriptReceiptsRoot:10,"10":"ScriptReceiptsRoot",
/**
*r" Set `$rA` to `Memory address of tx.script`
*/
Script:11,"11":"Script",
/**
*r" Set `$rA` to `Memory address of tx.scriptData`
*/
ScriptData:12,"12":"ScriptData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
ScriptInputAtIndex:13,"13":"ScriptInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
ScriptOutputAtIndex:14,"14":"ScriptOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
ScriptWitnessAtIndex:15,"15":"ScriptWitnessAtIndex",
/**
*r" Set `$rA` to `tx.gasPrice`
*/
CreateGasPrice:16,"16":"CreateGasPrice",
/**
*r" Set `$rA` to `tx.gasLimit`
*/
CreateGasLimit:17,"17":"CreateGasLimit",
/**
*r" Set `$rA` to `tx.maturity`
*/
CreateMaturity:18,"18":"CreateMaturity",
/**
*r" Set `$rA` to `tx.bytecodeLength`
*/
CreateBytecodeLength:19,"19":"CreateBytecodeLength",
/**
*r" Set `$rA` to `tx.bytecodeWitnessIndex`
*/
CreateBytecodeWitnessIndex:20,"20":"CreateBytecodeWitnessIndex",
/**
*r" Set `$rA` to `tx.storageSlotsCount`
*/
CreateStorageSlotsCount:21,"21":"CreateStorageSlotsCount",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
CreateInputsCount:22,"22":"CreateInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
CreateOutputsCount:23,"23":"CreateOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
CreateWitnessesCount:24,"24":"CreateWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.salt`
*/
CreateSalt:25,"25":"CreateSalt",
/**
*r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
*/
CreateStorageSlotAtIndex:26,"26":"CreateStorageSlotAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
CreateInputAtIndex:27,"27":"CreateInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
CreateOutputAtIndex:28,"28":"CreateOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
CreateWitnessAtIndex:29,"29":"CreateWitnessAtIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].type`
*/
InputType:257,"257":"InputType",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputCoinTxId:258,"258":"InputCoinTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputCoinOutputIndex:259,"259":"InputCoinOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
*/
InputCoinOwner:260,"260":"InputCoinOwner",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputCoinAmount:261,"261":"InputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
*/
InputCoinAssetId:262,"262":"InputCoinAssetId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
InputCoinTxPointer:263,"263":"InputCoinTxPointer",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputCoinWitnessIndex:264,"264":"InputCoinWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].maturity`
*/
InputCoinMaturity:265,"265":"InputCoinMaturity",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputCoinPredicateLength:266,"266":"InputCoinPredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputCoinPredicateDataLength:267,"267":"InputCoinPredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputCoinPredicate:268,"268":"InputCoinPredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputCoinPredicateData:269,"269":"InputCoinPredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputCoinPredicateGasUsed:270,"270":"InputCoinPredicateGasUsed",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputContractTxId:271,"271":"InputContractTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputContractOutputIndex:272,"272":"InputContractOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].balanceRoot`
*/
InputContractBalanceRoot:273,"273":"InputContractBalanceRoot",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].stateRoot`
*/
InputContractStateRoot:274,"274":"InputContractStateRoot",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
InputContractTxPointer:275,"275":"InputContractTxPointer",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
*/
InputContractId:276,"276":"InputContractId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
*/
InputMessageSender:277,"277":"InputMessageSender",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
*/
InputMessageRecipient:278,"278":"InputMessageRecipient",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputMessageAmount:279,"279":"InputMessageAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
*/
InputMessageNonce:280,"280":"InputMessageNonce",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputMessageWitnessIndex:281,"281":"InputMessageWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].dataLength`
*/
InputMessageDataLength:282,"282":"InputMessageDataLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputMessagePredicateLength:283,"283":"InputMessagePredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputMessagePredicateDataLength:284,"284":"InputMessagePredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
*/
InputMessageData:285,"285":"InputMessageData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputMessagePredicate:286,"286":"InputMessagePredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputMessagePredicateData:287,"287":"InputMessagePredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputMessagePredicateGasUsed:288,"288":"InputMessagePredicateGasUsed",
/**
*r" Set `$rA` to `tx.outputs[$rB].type`
*/
OutputType:513,"513":"OutputType",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
*/
OutputCoinTo:514,"514":"OutputCoinTo",
/**
*r" Set `$rA` to `tx.outputs[$rB].amount`
*/
OutputCoinAmount:515,"515":"OutputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
*/
OutputCoinAssetId:516,"516":"OutputCoinAssetId",
/**
*r" Set `$rA` to `tx.outputs[$rB].inputIndex`
*/
OutputContractInputIndex:517,"517":"OutputContractInputIndex",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].balanceRoot`
*/
OutputContractBalanceRoot:518,"518":"OutputContractBalanceRoot",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
OutputContractStateRoot:519,"519":"OutputContractStateRoot",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
*/
OutputContractCreatedContractId:520,"520":"OutputContractCreatedContractId",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
OutputContractCreatedStateRoot:521,"521":"OutputContractCreatedStateRoot",
/**
*r" Set `$rA` to `tx.witnesses[$rB].dataLength`
*/
WitnessDataLength:769,"769":"WitnessDataLength",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
*/
WitnessData:770,"770":"WitnessData", });
/**
*r" Panic reason representation for the interpreter.
*/
const PanicReason = Object.freeze({
/**
*r" The byte can't be mapped to any known `PanicReason`.
*/
UnknownPanicReason:0,"0":"UnknownPanicReason",
/**
*r" Found `RVRT` instruction.
*/
Revert:1,"1":"Revert",
/**
*r" Execution ran out of gas.
*/
OutOfGas:2,"2":"OutOfGas",
/**
*r" The transaction validity is violated.
*/
TransactionValidity:3,"3":"TransactionValidity",
/**
*r" Attempt to write outside interpreter memory boundaries.
*/
MemoryOverflow:4,"4":"MemoryOverflow",
/**
*r" Overflow while executing arithmetic operation.
*r" These errors are ignored using the WRAPPING flag.
*/
ArithmeticOverflow:5,"5":"ArithmeticOverflow",
/**
*r" Designed contract was not found in the storage.
*/
ContractNotFound:6,"6":"ContractNotFound",
/**
*r" Memory ownership rules are violated.
*/
MemoryOwnership:7,"7":"MemoryOwnership",
/**
*r" The asset ID balance isn't enough for the instruction.
*/
NotEnoughBalance:8,"8":"NotEnoughBalance",
/**
*r" The interpreter is expected to be in internal context.
*/
ExpectedInternalContext:9,"9":"ExpectedInternalContext",
/**
*r" The queried asset ID was not found in the state.
*/
AssetIdNotFound:10,"10":"AssetIdNotFound",
/**
*r" The provided input is not found in the transaction.
*/
InputNotFound:11,"11":"InputNotFound",
/**
*r" The provided output is not found in the transaction.
*/
OutputNotFound:12,"12":"OutputNotFound",
/**
*r" The provided witness is not found in the transaction.
*/
WitnessNotFound:13,"13":"WitnessNotFound",
/**
*r" The transaction maturity is not valid for this request.
*/
TransactionMaturity:14,"14":"TransactionMaturity",
/**
*r" The metadata identifier is invalid.
*/
InvalidMetadataIdentifier:15,"15":"InvalidMetadataIdentifier",
/**
*r" The call structure is not valid.
*/
MalformedCallStructure:16,"16":"MalformedCallStructure",
/**
*r" The provided register does not allow write operations.
*/
ReservedRegisterNotWritable:17,"17":"ReservedRegisterNotWritable",
/**
*r" The execution resulted in an erroneous state of the interpreter.
*/
ErrorFlag:18,"18":"ErrorFlag",
/**
*r" The provided immediate value is not valid for this instruction.
*/
InvalidImmediateValue:19,"19":"InvalidImmediateValue",
/**
*r" The provided transaction input is not of type `Coin`.
*/
ExpectedCoinInput:20,"20":"ExpectedCoinInput",
/**
*r" This entry is no longer used, and can be repurposed.
*/
Unused0x15:21,"21":"Unused0x15",
/**
*r" Two segments of the interpreter memory should not intersect for write operations.
*/
MemoryWriteOverlap:22,"22":"MemoryWriteOverlap",
/**
*r" The requested contract is not listed in the transaction inputs.
*/
ContractNotInInputs:23,"23":"ContractNotInInputs",
/**
*r" The internal asset ID balance overflowed with the provided instruction.
*/
InternalBalanceOverflow:24,"24":"InternalBalanceOverflow",
/**
*r" The maximum allowed contract size is violated.
*/
ContractMaxSize:25,"25":"ContractMaxSize",
/**
*r" This instruction expects the stack area to be unallocated for this call.
*/
ExpectedUnallocatedStack:26,"26":"ExpectedUnallocatedStack",
/**
*r" The maximum allowed number of static contracts was reached for this transaction.
*/
MaxStaticContractsReached:27,"27":"MaxStaticContractsReached",
/**
*r" The requested transfer amount cannot be zero.
*/
TransferAmountCannotBeZero:28,"28":"TransferAmountCannotBeZero",
/**
*r" The provided transaction output should be of type `Variable`.
*/
ExpectedOutputVariable:29,"29":"ExpectedOutputVariable",
/**
*r" The expected context of the stack parent is internal.
*/
ExpectedParentInternalContext:30,"30":"ExpectedParentInternalContext",
/**
*r" The jump instruction cannot move backwards in predicate verification.
*/
IllegalJump:31,"31":"IllegalJump",
/**
*r" The contract ID is already deployed and can't be overwritten.
*/
ContractIdAlreadyDeployed:32,"32":"ContractIdAlreadyDeployed",
/**
*r" The loaded contract mismatch expectations.
*/
ContractMismatch:33,"33":"ContractMismatch",
/**
*r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
*/
MessageDataTooLong:34,"34":"MessageDataTooLong",
/**
*r" Mathimatically invalid arguments where given to an arithmetic instruction.
*r" For instance, division by zero produces this.
*r" These errors are ignored using the UNSAFEMATH flag.
*/
ArithmeticError:35,"35":"ArithmeticError",
/**
*r" The contract instruction is not allowed in predicates.
*/
ContractInstructionNotAllowed:36,"36":"ContractInstructionNotAllowed",
/**
*r" Transfer of zero coins is not allowed.
*/
TransferZeroCoins:37,"37":"TransferZeroCoins", });
/**
* Comparison mode used by WDCM and WQCM instructions.
*/
const CompareMode = Object.freeze({
/**
* Equality (`==`)
*/
EQ:0,"0":"EQ",
/**
* Inequality (`!=`)
*/
NE:1,"1":"NE",
/**
* Less than (`<`)
*/
LT:2,"2":"LT",
/**
* Greater than (`>`)
*/
GT:3,"3":"GT",
/**
* Less than or equals (`>=`)
*/
LTE:4,"4":"LTE",
/**
* Greater than or equals (`>=`)
*/
GTE:5,"5":"GTE",
/**
* Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
*/
LZC:6,"6":"LZC", });
/**
* The operation performed by WDOP and WQOP instructions, determined as
*/
const MathOp = Object.freeze({
/**
* Add
*/
ADD:0,"0":"ADD",
/**
* Subtract
*/
SUB:1,"1":"SUB",
/**
* Invert bits (discards rhs)
*/
NOT:2,"2":"NOT",
/**
* Bitwise or
*/
OR:3,"3":"OR",
/**
* Bitwise exclusive or
*/
XOR:4,"4":"XOR",
/**
* Bitwise and
*/
AND:5,"5":"AND",
/**
* Shift left
*/
SHL:6,"6":"SHL",
/**
* Shift right
*/
SHR:7,"7":"SHR", });
/**
*Adds two registers.
*/
class ADD {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ADD.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_add_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return ADD.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Adds a register and an immediate value.
*/
class ADDI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ADDI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_addi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return ADDI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Allocate a number of bytes from the heap.
*/
class ALOC {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ALOC.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_aloc_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} bytes
    */
    constructor(bytes) {
        _assertClass(bytes, RegId);
        var ptr0 = bytes.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return ALOC.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ANDs two registers.
*/
class AND {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AND.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_and_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return AND.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ANDs a register and an immediate value.
*/
class ANDI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ANDI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_andi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return ANDI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Get the balance of contract of an asset ID.
*/
class BAL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BAL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bal_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} asset_id_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst, asset_id_addr, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr1 = asset_id_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr2 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return BAL.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get current block height.
*/
class BHEI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BHEI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return BHEI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get block header hash for height.
*/
class BHSH {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BHSH.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhsh_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return BHSH.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class BURN {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BURN.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_burn_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return BURN.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Call a contract.
*/
class CALL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CALL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_call_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} target_struct
    * @param {RegId} fwd_coins
    * @param {RegId} asset_id_addr
    * @param {RegId} fwd_gas
    */
    constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        _assertClass(target_struct, RegId);
        var ptr0 = target_struct.__destroy_into_raw();
        _assertClass(fwd_coins, RegId);
        var ptr1 = fwd_coins.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        _assertClass(fwd_gas, RegId);
        var ptr3 = fwd_gas.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return CALL.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get current block proposer's address.
*/
class CB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return CB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Copy contract code for a contract.
*/
class CCP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CCP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ccp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(dst_addr, contract_id_addr, offset, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return CCP.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Extend the current call frame's stack
*/
class CFE {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CFE.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfe_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return CFE.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Extend the current call frame's stack by an immediate value.
*/
class CFEI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CFEI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return CFEI.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Shrink the current call frame's stack
*/
class CFS {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CFS.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfs_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return CFS.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Shrink the current call frame's stack by an immediate value.
*/
class CFSI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CFSI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfsi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return CFSI.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Get code root of a contract.
*/
class CROO {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CROO.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_croo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst_addr, contract_id_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return CROO.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get code size of a contract.
*/
class CSIZ {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CSIZ.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_csiz_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} contract_id_addr
    */
    constructor(dst, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return CSIZ.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
* Arguments for WDCM and WQCM instructions.
*/
class CompareArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompareArgs.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compareargs_free(ptr);
    }
    /**
    * Comparison mode
    * @returns {number}
    */
    get mode() {
        const ret = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
    * Comparison mode
    * @param {number} arg0
    */
    set mode(arg0) {
        wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Convert to immediate value.
    * @returns {Imm06}
    */
    to_imm() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.compareargs_to_imm(ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
    * @param {Imm06} bits
    * @returns {CompareArgs | undefined}
    */
    static from_imm(bits) {
        _assertClass(bits, Imm06);
        var ptr0 = bits.__destroy_into_raw();
        const ret = wasm$1.compareargs_from_imm(ptr0);
        return ret === 0 ? undefined : CompareArgs.__wrap(ret);
    }
}
/**
*Divides two registers.
*/
class DIV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DIV.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_div_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return DIV.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Divides a register and an immediate value.
*/
class DIVI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DIVI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return DIVI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
* Additional arguments for WMDV and WDDV instructions.
*/
class DivArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divargs_free(ptr);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}
/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
class ECK1 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ECK1.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eck1_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return ECK1.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
class ECR1 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ECR1.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecr1_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return ECR1.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Verify ED25519 public key and signature match a 32-byte message.
*/
class ED19 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ED19.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ed19_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} pub_key_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(pub_key_addr, sig_addr, msg_hash_addr) {
        _assertClass(pub_key_addr, RegId);
        var ptr0 = pub_key_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return ED19.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compares two registers for equality.
*/
class EQ {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EQ.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return EQ.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Raises one register to the power of another.
*/
class EXP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EXP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_exp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return EXP.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Raises one register to the power of an immediate value.
*/
class EXPI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EXPI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_expi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return EXPI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Set flag register to a register.
*/
class FLAG {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FLAG.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_flag_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return FLAG.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get metadata from memory.
*/
class GM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} selector
    */
    constructor(dst, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(selector, Imm18);
        var ptr1 = selector.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        return GM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
    /**
    * Construct a `GM` instruction from its arguments.
    * @param {RegId} ra
    * @param {number} args
    * @returns {GM}
    */
    static from_args(ra, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        const ret = wasm$1.gm_from_args(ptr0, args);
        return GM.__wrap(ret);
    }
}
/**
*Compares two registers for greater-than.
*/
class GT {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GT.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return GT.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get transaction fields.
*/
class GTF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GTF.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gtf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    * @param {Imm12} selector
    */
    constructor(dst, arg, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(selector, Imm12);
        var ptr2 = selector.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return GTF.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
    /**
    * Construct a `GTF` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {number} args
    * @returns {GTF}
    */
    static from_args(ra, rb, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        const ret = wasm$1.gtf_from_args(ptr0, ptr1, args);
        return GTF.__wrap(ret);
    }
}
/**
* Represents a 6-bit immediate value, guaranteed to be masked by construction.
*/
class Imm06 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm06.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm06_free(ptr);
    }
}
/**
* Represents a 12-bit immediate value, guaranteed to be masked by construction.
*/
class Imm12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm12.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm12_free(ptr);
    }
}
/**
* Represents a 18-bit immediate value, guaranteed to be masked by construction.
*/
class Imm18 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm18.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm18_free(ptr);
    }
}
/**
* Represents a 24-bit immediate value, guaranteed to be masked by construction.
*/
class Imm24 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm24.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm24_free(ptr);
    }
}
/**
* Representation of a single instruction for the interpreter.
*
* The opcode is represented in the tag (variant), or may be retrieved in the
* form of an `Opcode` byte using the `opcode` method.
*
* The register and immediate data associated with the instruction is represented
* within an inner unit type wrapper around the 3 remaining bytes.
*/
class Instruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Instruction.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_instruction_free(ptr);
    }
    /**
    * Convenience method for converting to bytes
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_free(r0, r1 * 1);
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Size of an instruction in bytes
    * @returns {number}
    */
    static size() {
        const ret = wasm$1.instruction_size();
        return ret >>> 0;
    }
}
/**
*Jump.
*/
class JI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ji_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, Imm24);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return JI.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Dynamic jump.
*/
class JMP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JMP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return JMP.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Unconditional dynamic relative jump backwards, with a constant offset.
*/
class JMPB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JMPB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        return JMPB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*Unconditional dynamic relative jump forwards, with a constant offset.
*/
class JMPF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JMPF.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        return JMPF.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*Conditional dynamic jump.
*/
class JNE {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNE.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jne_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(abs_target, lhs, rhs) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return JNE.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
*/
class JNEB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNEB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jneb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return JNEB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}
/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
*/
class JNEF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNEF.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnef_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return JNEF.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}
/**
*Conditional jump.
*/
class JNEI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNEI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {Imm12} abs_target
    */
    constructor(cond_lhs, cond_rhs, abs_target) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(abs_target, Imm12);
        var ptr2 = abs_target.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return JNEI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
*/
class JNZB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNZB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return JNZB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
*/
class JNZF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNZF.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return JNZF.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Conditional jump against zero.
*/
class JNZI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(JNZI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {Imm18} abs_target
    */
    constructor(cond_nz, abs_target) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(abs_target, Imm18);
        var ptr1 = abs_target.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        return JNZI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*The keccak-256 hash of a slice.
*/
class K256 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(K256.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_k256_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return K256.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*A byte is loaded from the specified address offset by an immediate value.
*/
class LB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return LB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Load a contract's code as executable.
*/
class LDC {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LDC.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ldc_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(contract_id_addr, offset, len) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr1 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return LDC.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Log an event.
*/
class LOG {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LOG.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_log_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return LOG.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Log data.
*/
class LOGD {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LOGD.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_logd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(a, b, addr, len) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr2 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return LOGD.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compares two registers for less-than.
*/
class LT {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LT.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return LT.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*A word is loaded from the specified address offset by an immediate value.
*/
class LW {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LW.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return LW.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Clear a variable number of bytes in memory.
*/
class MCL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MCL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} len
    */
    constructor(dst_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return MCL.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Clear an immediate number of bytes in memory.
*/
class MCLI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MCLI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {Imm18} count
    */
    constructor(addr, count) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(count, Imm18);
        var ptr1 = count.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        return MCLI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*Copy a variable number of bytes in memory.
*/
class MCP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MCP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return MCP.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Copy an immediate number of bytes in memory.
*/
class MCPI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MCPI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcpi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {Imm12} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, Imm12);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return MCPI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Compare bytes in memory.
*/
class MEQ {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MEQ.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_meq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} result
    * @param {RegId} lhs_addr
    * @param {RegId} rhs_addr
    * @param {RegId} len
    */
    constructor(result, lhs_addr, rhs_addr, len) {
        _assertClass(result, RegId);
        var ptr0 = result.__destroy_into_raw();
        _assertClass(lhs_addr, RegId);
        var ptr1 = lhs_addr.__destroy_into_raw();
        _assertClass(rhs_addr, RegId);
        var ptr2 = rhs_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return MEQ.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class MINT {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MINT.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mint_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return MINT.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Fused multiply-divide with arbitrary precision intermediate step.
*/
class MLDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MLDV.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mldv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return MLDV.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*The integer logarithm of a register.
*/
class MLOG {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MLOG.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mlog_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return MLOG.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Modulo remainder of two registers.
*/
class MOD {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MOD.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mod_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return MOD.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Modulo remainder of a register and an immediate value.
*/
class MODI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MODI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_modi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return MODI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Copy from one register to another.
*/
class MOVE {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MOVE.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_move_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} src
    */
    constructor(dst, src) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(src, RegId);
        var ptr1 = src.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return MOVE.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Copy immediate value into a register
*/
class MOVI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MOVI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_movi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} val
    */
    constructor(dst, val) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(val, Imm18);
        var ptr1 = val.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        return MOVI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*The integer root of a register.
*/
class MROO {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MROO.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mroo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return MROO.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiplies two registers.
*/
class MUL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MUL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mul_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return MUL.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiplies a register and an immediate value.
*/
class MULI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MULI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_muli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return MULI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
* Additional arguments for WDOP and WQOP instructions.
*/
class MathArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mathargs_free(ptr);
    }
    /**
    * The operation to perform
    * @returns {number}
    */
    get op() {
        const ret = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
    * The operation to perform
    * @param {number} arg0
    */
    set op(arg0) {
        wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}
/**
* Additional arguments for WDML and WQML instructions.
*/
class MulArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mulargs_free(ptr);
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_lhs() {
        const ret = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_lhs(arg0) {
        wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}
/**
*Performs no operation.
*/
class NOOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NOOP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_noop_free(ptr);
    }
    /**
    * Construct the instruction.
    */
    constructor() {
        const ret = wasm$1.noop_new_typescript();
        return NOOP.__wrap(ret);
    }
}
/**
*Bitwise NOT a register.
*/
class NOT {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NOT.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_not_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    */
    constructor(dst, arg) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return NOT.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ORs two registers.
*/
class OR {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(OR.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_or_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return OR.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ORs a register and an immediate value.
*/
class ORI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ORI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ori_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return ORI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
*/
class POPH {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(POPH.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_poph_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return POPH.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
*/
class POPL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(POPL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_popl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return POPL.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
*/
class PSHH {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PSHH.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshh_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return PSHH.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
*/
class PSHL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PSHL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        return PSHL.__wrap(ret);
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
* Describe a panic reason with the instruction that generated it
*/
class PanicInstruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PanicInstruction.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_panicinstruction_free(ptr);
    }
    /**
    * Represents an error described by a reason and an instruction.
    * @param {number} reason
    * @param {number} instruction
    */
    constructor(reason, instruction) {
        const ret = wasm$1.panicinstruction_error_typescript(reason, instruction);
        return PanicInstruction.__wrap(ret);
    }
    /**
    * Underlying panic reason
    * @returns {number}
    */
    reason() {
        const ret = wasm$1.panicinstruction_reason(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
    * Underlying instruction
    * @returns {number}
    */
    instruction() {
        const ret = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
        return ret >>> 0;
    }
}
/**
*Return from context.
*/
class RET {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RET.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ret_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return RET.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Return from context with data.
*/
class RETD {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RETD.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_retd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(addr, len) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return RETD.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Halt execution, reverting state changes and returning a value.
*/
class RVRT {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RVRT.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_rvrt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        return RVRT.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
* Represents a 6-bit register ID, guaranteed to be masked by construction.
*/
class RegId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegId.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_regid_free(ptr);
    }
    /**
    * Construct a register ID from the given value.
    *
    * Returns `None` if the value is outside the 6-bit value range.
    * @param {number} u
    * @returns {RegId | undefined}
    */
    static new_checked(u) {
        const ret = wasm$1.regid_new_checked(u);
        return ret === 0 ? undefined : RegId.__wrap(ret);
    }
    /**
    * Received balance for this context.
    * @returns {RegId}
    */
    static bal() {
        const ret = wasm$1.regid_bal();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas in the context.
    * @returns {RegId}
    */
    static cgas() {
        const ret = wasm$1.regid_cgas();
        return RegId.__wrap(ret);
    }
    /**
    * Error codes for particular operations.
    * @returns {RegId}
    */
    static err() {
        const ret = wasm$1.regid_err();
        return RegId.__wrap(ret);
    }
    /**
    * Flags register.
    * @returns {RegId}
    */
    static flag() {
        const ret = wasm$1.regid_flag();
        return RegId.__wrap(ret);
    }
    /**
    * Frame pointer. Memory address of beginning of current call frame.
    * @returns {RegId}
    */
    static fp() {
        const ret = wasm$1.regid_fp();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas globally.
    * @returns {RegId}
    */
    static ggas() {
        const ret = wasm$1.regid_ggas();
        return RegId.__wrap(ret);
    }
    /**
    * Heap pointer. Memory address below the current bottom of the heap (points to free
    * memory).
    * @returns {RegId}
    */
    static hp() {
        const ret = wasm$1.regid_hp();
        return RegId.__wrap(ret);
    }
    /**
    * Instructions start. Pointer to the start of the currently-executing code.
    * @returns {RegId}
    */
    static is() {
        const ret = wasm$1.regid_is();
        return RegId.__wrap(ret);
    }
    /**
    * Contains overflow/underflow of addition, subtraction, and multiplication.
    * @returns {RegId}
    */
    static of() {
        const ret = wasm$1.regid_of();
        return RegId.__wrap(ret);
    }
    /**
    * Contains one (1), for convenience.
    * @returns {RegId}
    */
    static one() {
        const ret = wasm$1.regid_one();
        return RegId.__wrap(ret);
    }
    /**
    * The program counter. Memory address of the current instruction.
    * @returns {RegId}
    */
    static pc() {
        const ret = wasm$1.regid_pc();
        return RegId.__wrap(ret);
    }
    /**
    * Return value or pointer.
    * @returns {RegId}
    */
    static ret() {
        const ret = wasm$1.regid_ret();
        return RegId.__wrap(ret);
    }
    /**
    * Return value length in bytes.
    * @returns {RegId}
    */
    static retl() {
        const ret = wasm$1.regid_retl();
        return RegId.__wrap(ret);
    }
    /**
    * Stack pointer. Memory address on top of current writable stack area (points to
    * free memory).
    * @returns {RegId}
    */
    static sp() {
        const ret = wasm$1.regid_sp();
        return RegId.__wrap(ret);
    }
    /**
    * Stack start pointer. Memory address of bottom of current writable stack area.
    * @returns {RegId}
    */
    static spp() {
        const ret = wasm$1.regid_spp();
        return RegId.__wrap(ret);
    }
    /**
    * Smallest writable register.
    * @returns {RegId}
    */
    static writable() {
        const ret = wasm$1.regid_writable();
        return RegId.__wrap(ret);
    }
    /**
    * Contains zero (0), for convenience.
    * @returns {RegId}
    */
    static zero() {
        const ret = wasm$1.regid_zero();
        return RegId.__wrap(ret);
    }
    /**
    * Construct a register ID from the given value.
    *
    * The given value will be masked to 6 bits.
    * @param {number} u
    */
    constructor(u) {
        const ret = wasm$1.regid_new_typescript(u);
        return RegId.__wrap(ret);
    }
    /**
    * A const alternative to the `Into<u8>` implementation.
    * @returns {number}
    */
    to_u8() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.regid_to_u8(ptr);
        return ret;
    }
}
/**
*The SHA-2-256 hash of a slice.
*/
class S256 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(S256.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_s256_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return S256.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Write the least significant byte of a register to memory.
*/
class SB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return SB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Clear a series of slots from contract storage.
*/
class SCWQ {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SCWQ.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_scwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} lenq
    */
    constructor(key_addr, status, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr2 = lenq.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return SCWQ.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Left shifts a register by a register.
*/
class SLL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SLL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sll_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return SLL.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Left shifts a register by an immediate value.
*/
class SLLI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SLLI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_slli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return SLLI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Send a message to recipient address with call abi, coins, and output.
*/
class SMO {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SMO.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_smo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} recipient_addr
    * @param {RegId} data_addr
    * @param {RegId} data_len
    * @param {RegId} coins
    */
    constructor(recipient_addr, data_addr, data_len, coins) {
        _assertClass(recipient_addr, RegId);
        var ptr0 = recipient_addr.__destroy_into_raw();
        _assertClass(data_addr, RegId);
        var ptr1 = data_addr.__destroy_into_raw();
        _assertClass(data_len, RegId);
        var ptr2 = data_len.__destroy_into_raw();
        _assertClass(coins, RegId);
        var ptr3 = coins.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return SMO.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Right shifts a register by a register.
*/
class SRL {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SRL.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return SRL.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Right shifts a register by an immediate value.
*/
class SRLI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SRLI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return SRLI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Load a word from contract storage.
*/
class SRW {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SRW.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} status
    * @param {RegId} key_addr
    */
    constructor(dst, status, key_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return SRW.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Load a series of 32 byte slots from contract storage.
*/
class SRWQ {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SRWQ.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} status
    * @param {RegId} key_addr
    * @param {RegId} lenq
    */
    constructor(dst_addr, status, key_addr, lenq) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return SRWQ.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Subtracts two registers.
*/
class SUB {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SUB.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sub_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return SUB.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Subtracts a register and an immediate value.
*/
class SUBI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SUBI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_subi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return SUBI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Write a register to memory.
*/
class SW {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SW.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return SW.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Store a word in contract storage.
*/
class SWW {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SWW.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sww_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} value
    */
    constructor(key_addr, status, value) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr2 = value.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return SWW.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Store a series of 32 byte slots in contract storage.
*/
class SWWQ {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SWWQ.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_swwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} src_addr
    * @param {RegId} lenq
    */
    constructor(key_addr, status, src_addr, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr2 = src_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return SWWQ.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get timestamp of block at given height.
*/
class TIME {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TIME.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_time_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        return TIME.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Transfer coins to a contract unconditionally.
*/
class TR {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TR.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tr_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr1 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return TR.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Transfer coins to a variable output.
*/
class TRO {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TRO.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tro_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} output_index
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, output_index, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(output_index, RegId);
        var ptr1 = output_index.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr2 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr3 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return TRO.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*AddMod 128bit
*/
class WDAM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDAM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdam_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDAM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compare 128bit integers
*/
class WDCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDCM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdcm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WDCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
}
/**
*Divide 128bit
*/
class WDDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDDV.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wddv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WDDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
}
/**
*Fused multiply-divide 128bit
*/
class WDMD {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDMD.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDMD.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiply 128bit
*/
class WDML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDML.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdml_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WDML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
}
/**
*MulMod 128bit
*/
class WDMM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDMM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDMM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Simple 128bit operations
*/
class WDOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDOP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdop_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WDOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
}
/**
*AddMod 256bit
*/
class WQAM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQAM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqam_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQAM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compare 256bit integers
*/
class WQCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQCM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqcm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WQCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
}
/**
*Divide 256bit
*/
class WQDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQDV.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqdv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WQDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
}
/**
*Fused multiply-divide 256bit
*/
class WQMD {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQMD.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQMD.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiply 256bit
*/
class WQML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQML.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqml_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WQML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
}
/**
*MulMod 256bit
*/
class WQMM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQMM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQMM.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Simple 256bit operations
*/
class WQOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQOP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqop_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WQOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
}
/**
*Bitwise XORs two registers.
*/
class XOR {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(XOR.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xor_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        return XOR.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise XORs a register and an immediate value.
*/
class XORI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(XORI.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xori_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        return XORI.__wrap(ret);
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm$1 = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedInt32Memory0 = null;
    cachedUint8Memory0 = null;


    return wasm$1;
}

function initSync(module) {
    if (wasm$1 !== undefined) return wasm$1;

    const imports = __wbg_get_imports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(input) {
    if (wasm$1 !== undefined) return wasm$1;
    const imports = __wbg_get_imports();

    const { instance, module } = await __wbg_load(await input, imports);

    return __wbg_finalize_init(instance, module);
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function wasm(imports){return _loadWasmModule(1, null, 'AGFzbQEAAAABVA5gA39/fwF/YAF/AX9gAn9/AX9gBH9/f38Bf2ACf38AYAABf2ABfwBgBX9/f39/AX9gA39/fwBgAABgAX8BfmACfn8Bf2AFf39/f38AYAR/f39/AAIYAQN3YmcQX193YmluZGdlbl90aHJvdwAEA4AC/gEBBgIEAQIDAwMDAwMDAwMDAgsAAAAAAAAAAAAAAAAAAAAAAAAAAAYEAwMDAwMDBQMDAgICAgICAwMDAwMDAwMDAwMDAwMDAwMDBAMDAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAwAAg0CAgQCAgICAgICAgICAQIBAQEBAQEEBAEBAQEBAQEBAQEBAQIBBgUAAgkBBAQEAwQGBAEEAQEBBAYFBQUFBQUFBQUFBQUFBQUFBQEBBggFBAYBAQQCCAECBAECAQEEAQICAgIJAQQJCQEBAQEEAAICAQEFCgoKBgIIAgMDAgcABwABAgcHBwQFAXABFhYFAwEAEQYJAX8BQYCAwAALB5JNugUGbWVtb3J5AgAOX193YmdfYWRkX2ZyZWUAsQESYWRkX25ld190eXBlc2NyaXB0AHEGYWRkX3JhAJEBBmFkZF9yYgCLAQZhZGRfcmMAjAEDYWRkAHADYW5kAFQDZGl2AFUCZXEAVgNleHAAVwJndABYAmx0AFkEbWxvZwBaBG1yb28AWwRtb2RfAFwFbW92ZV8AfANtdWwAXQNub3QAfQJvcgBeA3NsbABfA3NybABgA3N1YgBhA3hvcgBiBG1sZHYAOgNyZXQAkgEEcmV0ZAB+E2Fsb2NfbmV3X3R5cGVzY3JpcHQAnQEEYWxvYwCTAQNtY2wAfwNtY3AAYwNtZXEAOxNiaHNoX25ld190eXBlc2NyaXB0AIcBBGJoc2gAgAEEYmhlaQCUAQRidXJuAIEBE2NhbGxfbmV3X3R5cGVzY3JpcHQATAdjYWxsX3JkAJUBBGNhbGwAPANjY3AAPQRjcm9vAIIBBGNzaXoAgwECY2IAlgEDbGRjAGQDbG9nAD4EbG9nZAA/BG1pbnQAhAEEcnZydACXAQRzY3dxAGUDc3J3AGYEc3J3cQBAA3N3dwBnBHN3d3EAQQJ0cgBoA3RybwBCBGVjazEAaQRlY3IxAGoEZWQxOQBrBGsyNTYAbARzMjU2AG0EdGltZQCFARNub29wX25ld190eXBlc2NyaXB0AMcBBG5vb3AAnwEEZmxhZwCYAQNiYWwAbgNqbXAAmQEDam5lAG8Dc21vAEMTYWRkaV9uZXdfdHlwZXNjcmlwdABzCmFkZGlfaW1tMTIAjQEEYWRkaQATBGFuZGkAFARkaXZpABUEZXhwaQAWBG1vZGkAFwRtdWxpABgDb3JpABkEc2xsaQAaBHNybGkAGwRzdWJpABwEeG9yaQAdBGpuZWkAHgJsYgAfAmx3ACACc2IAIQJzdwAiBG1jcGkAIwNndGYAJARtY2xpADIRZ21fbmV3X3R5cGVzY3JpcHQAeQhnbV9pbW0xOACJAQJnbQAzBG1vdmkANARqbnppADUEam1wZgA2BGptcGIANwRqbnpmACUEam56YgAmBGpuZWYABwRqbmViAAgCamkATRNjZmVpX25ld190eXBlc2NyaXB0AIgBCmNmZWlfaW1tMjQAigEEY2ZlaQBOBGNmc2kATwNjZmUAmgEDY2ZzAJsBBHBzaGwAUARwc2hoAFEEcG9wbABSBHBvcGgAUwR3ZGNtAAkEd3FjbQAKBHdkb3AACwR3cW9wAAwEd2RtbAANBHdxbWwADgR3ZGR2AA8Ed3FkdgAQBHdkbWQARAR3cW1kAEUEd2RhbQBGBHdxYW0ARwR3ZG1tAEgEd3FtbQBJCm1jbGlfaW1tMTgAiQEKbW92aV9pbW0xOACJAQpqbnppX2ltbTE4AIkBCmptcGZfaW1tMTgAiQEKam1wYl9pbW0xOACJAQhqaV9pbW0yNACKAQpjZnNpX2ltbTI0AIoBCnBzaGxfaW1tMjQAigEKcHNoaF9pbW0yNACKAQpwb3BsX2ltbTI0AIoBCnBvcGhfaW1tMjQAigETbWNsaV9uZXdfdHlwZXNjcmlwdAB5E21vdmlfbmV3X3R5cGVzY3JpcHQAeRNqbnppX25ld190eXBlc2NyaXB0AHkTam1wZl9uZXdfdHlwZXNjcmlwdAB5E2ptcGJfbmV3X3R5cGVzY3JpcHQAeRJub3RfbmV3X3R5cGVzY3JpcHQAhwETcmV0ZF9uZXdfdHlwZXNjcmlwdACHARNtb3ZlX25ld190eXBlc2NyaXB0AIcBEm1jbF9uZXdfdHlwZXNjcmlwdACHARNidXJuX25ld190eXBlc2NyaXB0AIcBE2Nyb29fbmV3X3R5cGVzY3JpcHQAhwETY3Npel9uZXdfdHlwZXNjcmlwdACHARNtaW50X25ld190eXBlc2NyaXB0AIcBE3RpbWVfbmV3X3R5cGVzY3JpcHQAhwERamlfbmV3X3R5cGVzY3JpcHQAiAETY2ZzaV9uZXdfdHlwZXNjcmlwdACIARNwc2hsX25ld190eXBlc2NyaXB0AIgBE3BzaGhfbmV3X3R5cGVzY3JpcHQAiAETcG9wbF9uZXdfdHlwZXNjcmlwdACIARNwb3BoX25ld190eXBlc2NyaXB0AIgBE2FuZGlfbmV3X3R5cGVzY3JpcHQAcxNkaXZpX25ld190eXBlc2NyaXB0AHMTZXhwaV9uZXdfdHlwZXNjcmlwdABzE21vZGlfbmV3X3R5cGVzY3JpcHQAcxNtdWxpX25ld190eXBlc2NyaXB0AHMSb3JpX25ld190eXBlc2NyaXB0AHMTc2xsaV9uZXdfdHlwZXNjcmlwdABzE3NybGlfbmV3X3R5cGVzY3JpcHQAcxNzdWJpX25ld190eXBlc2NyaXB0AHMTeG9yaV9uZXdfdHlwZXNjcmlwdABzE2puZWlfbmV3X3R5cGVzY3JpcHQAcxFsYl9uZXdfdHlwZXNjcmlwdABzEWx3X25ld190eXBlc2NyaXB0AHMRc2JfbmV3X3R5cGVzY3JpcHQAcxFzd19uZXdfdHlwZXNjcmlwdABzE21jcGlfbmV3X3R5cGVzY3JpcHQAcxJndGZfbmV3X3R5cGVzY3JpcHQAcxNqbnpmX25ld190eXBlc2NyaXB0AHMTam56Yl9uZXdfdHlwZXNjcmlwdABzCmFuZGlfaW1tMTIAjQEKZGl2aV9pbW0xMgCNAQpleHBpX2ltbTEyAI0BCm1vZGlfaW1tMTIAjQEKbXVsaV9pbW0xMgCNAQlvcmlfaW1tMTIAjQEKc2xsaV9pbW0xMgCNAQpzcmxpX2ltbTEyAI0BCnN1YmlfaW1tMTIAjQEKeG9yaV9pbW0xMgCNAQpqbmVpX2ltbTEyAI0BCGxiX2ltbTEyAI0BCGx3X2ltbTEyAI0BCHNiX2ltbTEyAI0BCHN3X2ltbTEyAI0BCm1jcGlfaW1tMTIAjQEJZ3RmX2ltbTEyAI0BCmpuemZfaW1tMTIAjQEKam56Yl9pbW0xMgCNARJhbmRfbmV3X3R5cGVzY3JpcHQAcRJkaXZfbmV3X3R5cGVzY3JpcHQAcRFlcV9uZXdfdHlwZXNjcmlwdABxEmV4cF9uZXdfdHlwZXNjcmlwdABxEWd0X25ld190eXBlc2NyaXB0AHERbHRfbmV3X3R5cGVzY3JpcHQAcRNtbG9nX25ld190eXBlc2NyaXB0AHETbXJvb19uZXdfdHlwZXNjcmlwdABxEm1vZF9uZXdfdHlwZXNjcmlwdABxEm11bF9uZXdfdHlwZXNjcmlwdABxEW9yX25ld190eXBlc2NyaXB0AHESc2xsX25ld190eXBlc2NyaXB0AHESc3JsX25ld190eXBlc2NyaXB0AHESc3ViX25ld190eXBlc2NyaXB0AHESeG9yX25ld190eXBlc2NyaXB0AHESbWNwX25ld190eXBlc2NyaXB0AHESbGRjX25ld190eXBlc2NyaXB0AHETc2N3cV9uZXdfdHlwZXNjcmlwdABxEnNyd19uZXdfdHlwZXNjcmlwdABxEnN3d19uZXdfdHlwZXNjcmlwdABxEXRyX25ld190eXBlc2NyaXB0AHETZWNrMV9uZXdfdHlwZXNjcmlwdABxE2VjcjFfbmV3X3R5cGVzY3JpcHQAcRNlZDE5X25ld190eXBlc2NyaXB0AHETazI1Nl9uZXdfdHlwZXNjcmlwdABxE3MyNTZfbmV3X3R5cGVzY3JpcHQAcRJiYWxfbmV3X3R5cGVzY3JpcHQAcRJqbmVfbmV3X3R5cGVzY3JpcHQAcRJyZXRfbmV3X3R5cGVzY3JpcHQAnQETYmhlaV9uZXdfdHlwZXNjcmlwdACdARFjYl9uZXdfdHlwZXNjcmlwdACdARNydnJ0X25ld190eXBlc2NyaXB0AJ0BE2ZsYWdfbmV3X3R5cGVzY3JpcHQAnQESam1wX25ld190eXBlc2NyaXB0AJ0BEmNmZV9uZXdfdHlwZXNjcmlwdACdARJjZnNfbmV3X3R5cGVzY3JpcHQAnQEGYW5kX3JiAIsBBmRpdl9yYgCLAQVlcV9yYgCLAQZleHBfcmIAiwEFZ3RfcmIAiwEFbHRfcmIAiwEHbWxvZ19yYgCLAQdtcm9vX3JiAIsBBm1vZF9yYgCLAQdtb3ZlX3JiAIsBBm11bF9yYgCLAQZub3RfcmIAiwEFb3JfcmIAiwEGc2xsX3JiAIsBBnNybF9yYgCLAQZzdWJfcmIAiwEGeG9yX3JiAIsBB21sZHZfcmIAiwEHcmV0ZF9yYgCLAQZtY2xfcmIAiwEGbWNwX3JiAIsBBm1lcV9yYgCLAQdiaHNoX3JiAIsBB2J1cm5fcmIAiwEHY2FsbF9yYgCLAQZjY3BfcmIAiwEHY3Jvb19yYgCLAQdjc2l6X3JiAIsBBmxkY19yYgCLAQZsb2dfcmIAiwEHbG9nZF9yYgCLAQdtaW50X3JiAIsBB3Njd3FfcmIAiwEGc3J3X3JiAIsBB3Nyd3FfcmIAiwEGc3d3X3JiAIsBB3N3d3FfcmIAiwEFdHJfcmIAiwEGdHJvX3JiAIsBB2VjazFfcmIAiwEHZWNyMV9yYgCLAQdlZDE5X3JiAIsBB2syNTZfcmIAiwEHczI1Nl9yYgCLAQd0aW1lX3JiAIsBBmJhbF9yYgCLAQZqbmVfcmIAiwEGc21vX3JiAIsBB2FkZGlfcmIAiwEHYW5kaV9yYgCLAQdkaXZpX3JiAIsBB2V4cGlfcmIAiwEHbW9kaV9yYgCLAQdtdWxpX3JiAIsBBm9yaV9yYgCLAQdzbGxpX3JiAIsBB3NybGlfcmIAiwEHc3ViaV9yYgCLAQd4b3JpX3JiAIsBB2puZWlfcmIAiwEFbGJfcmIAiwEFbHdfcmIAiwEFc2JfcmIAiwEFc3dfcmIAiwEHbWNwaV9yYgCLAQZndGZfcmIAiwEHam56Zl9yYgCLAQdqbnpiX3JiAIsBB2puZWZfcmIAiwEHam5lYl9yYgCLAQd3ZGNtX3JiAIsBB3dxY21fcmIAiwEHd2RvcF9yYgCLAQd3cW9wX3JiAIsBB3dkbWxfcmIAiwEHd3FtbF9yYgCLAQd3ZGR2X3JiAIsBB3dxZHZfcmIAiwEHd2RtZF9yYgCLAQd3cW1kX3JiAIsBB3dkYW1fcmIAiwEHd3FhbV9yYgCLAQd3ZG1tX3JiAIsBB3dxbW1fcmIAiwEGYW5kX3JhAJEBBmRpdl9yYQCRAQVlcV9yYQCRAQZleHBfcmEAkQEFZ3RfcmEAkQEFbHRfcmEAkQEHbWxvZ19yYQCRAQdtcm9vX3JhAJEBBm1vZF9yYQCRAQdtb3ZlX3JhAJEBBm11bF9yYQCRAQZub3RfcmEAkQEFb3JfcmEAkQEGc2xsX3JhAJEBBnNybF9yYQCRAQZzdWJfcmEAkQEGeG9yX3JhAJEBB21sZHZfcmEAkQEGcmV0X3JhAJEBB3JldGRfcmEAkQEHYWxvY19yYQCRAQZtY2xfcmEAkQEGbWNwX3JhAJEBBm1lcV9yYQCRAQdiaHNoX3JhAJEBB2JoZWlfcmEAkQEHYnVybl9yYQCRAQdjYWxsX3JhAJEBBmNjcF9yYQCRAQdjcm9vX3JhAJEBB2NzaXpfcmEAkQEFY2JfcmEAkQEGbGRjX3JhAJEBBmxvZ19yYQCRAQdsb2dkX3JhAJEBB21pbnRfcmEAkQEHcnZydF9yYQCRAQdzY3dxX3JhAJEBBnNyd19yYQCRAQdzcndxX3JhAJEBBnN3d19yYQCRAQdzd3dxX3JhAJEBBXRyX3JhAJEBBnRyb19yYQCRAQdlY2sxX3JhAJEBB2VjcjFfcmEAkQEHZWQxOV9yYQCRAQdrMjU2X3JhAJEBB3MyNTZfcmEAkQEHdGltZV9yYQCRAQdmbGFnX3JhAJEBBmJhbF9yYQCRAQZqbXBfcmEAkQEGam5lX3JhAJEBBnNtb19yYQCRAQdhZGRpX3JhAJEBB2FuZGlfcmEAkQEHZGl2aV9yYQCRAQdleHBpX3JhAJEBB21vZGlfcmEAkQEHbXVsaV9yYQCRAQZvcmlfcmEAkQEHc2xsaV9yYQCRAQdzcmxpX3JhAJEBB3N1YmlfcmEAkQEHeG9yaV9yYQCRAQdqbmVpX3JhAJEBBWxiX3JhAJEBBWx3X3JhAJEBBXNiX3JhAJEBBXN3X3JhAJEBB21jcGlfcmEAkQEGZ3RmX3JhAJEBB21jbGlfcmEAkQEFZ21fcmEAkQEHbW92aV9yYQCRAQdqbnppX3JhAJEBB2ptcGZfcmEAkQEHam1wYl9yYQCRAQdqbnpmX3JhAJEBB2puemJfcmEAkQEHam5lZl9yYQCRAQdqbmViX3JhAJEBBmNmZV9yYQCRAQZjZnNfcmEAkQEHd2RjbV9yYQCRAQd3cWNtX3JhAJEBB3dkb3BfcmEAkQEHd3FvcF9yYQCRAQd3ZG1sX3JhAJEBB3dxbWxfcmEAkQEHd2Rkdl9yYQCRAQd3cWR2X3JhAJEBB3dkbWRfcmEAkQEHd3FtZF9yYQCRAQd3ZGFtX3JhAJEBB3dxYW1fcmEAkQEHd2RtbV9yYQCRAQd3cW1tX3JhAJEBE21sZHZfbmV3X3R5cGVzY3JpcHQATBJtZXFfbmV3X3R5cGVzY3JpcHQATBJjY3BfbmV3X3R5cGVzY3JpcHQATBJsb2dfbmV3X3R5cGVzY3JpcHQATBNsb2dkX25ld190eXBlc2NyaXB0AEwTc3J3cV9uZXdfdHlwZXNjcmlwdABME3N3d3FfbmV3X3R5cGVzY3JpcHQATBJ0cm9fbmV3X3R5cGVzY3JpcHQATBJzbW9fbmV3X3R5cGVzY3JpcHQATBNqbmVmX25ld190eXBlc2NyaXB0AEwTam5lYl9uZXdfdHlwZXNjcmlwdABME3dkY21fbmV3X3R5cGVzY3JpcHQATBN3cWNtX25ld190eXBlc2NyaXB0AEwTd2RvcF9uZXdfdHlwZXNjcmlwdABME3dxb3BfbmV3X3R5cGVzY3JpcHQATBN3ZG1sX25ld190eXBlc2NyaXB0AEwTd3FtbF9uZXdfdHlwZXNjcmlwdABME3dkZHZfbmV3X3R5cGVzY3JpcHQATBN3cWR2X25ld190eXBlc2NyaXB0AEwTd2RtZF9uZXdfdHlwZXNjcmlwdABME3dxbWRfbmV3X3R5cGVzY3JpcHQATBN3ZGFtX25ld190eXBlc2NyaXB0AEwTd3FhbV9uZXdfdHlwZXNjcmlwdABME3dkbW1fbmV3X3R5cGVzY3JpcHQATBN3cW1tX25ld190eXBlc2NyaXB0AEwHbWxkdl9yZACVAQZtZXFfcmQAlQEGY2NwX3JkAJUBBmxvZ19yZACVAQdsb2dkX3JkAJUBB3Nyd3FfcmQAlQEHc3d3cV9yZACVAQZ0cm9fcmQAlQEGc21vX3JkAJUBCmpuZWZfaW1tMDYAlQEKam5lYl9pbW0wNgCVAQp3ZGNtX2ltbTA2AJUBCndxY21faW1tMDYAlQEKd2RvcF9pbW0wNgCVAQp3cW9wX2ltbTA2AJUBCndkbWxfaW1tMDYAlQEKd3FtbF9pbW0wNgCVAQp3ZGR2X2ltbTA2AJUBCndxZHZfaW1tMDYAlQEHd2RtZF9yZACVAQd3cW1kX3JkAJUBB3dkYW1fcmQAlQEHd3FhbV9yZACVAQd3ZG1tX3JkAJUBB3dxbW1fcmQAlQEOX193YmdfYW5kX2ZyZWUAsQEOX193YmdfZGl2X2ZyZWUAsQENX193YmdfZXFfZnJlZQCxAQ5fX3diZ19leHBfZnJlZQCxAQ1fX3diZ19ndF9mcmVlALEBDV9fd2JnX2x0X2ZyZWUAsQEPX193YmdfbWxvZ19mcmVlALEBD19fd2JnX21yb29fZnJlZQCxAQ5fX3diZ19tb2RfZnJlZQCxAQ9fX3diZ19tb3ZlX2ZyZWUAsQEOX193YmdfbXVsX2ZyZWUAsQEOX193Ymdfbm90X2ZyZWUAsQENX193Ymdfb3JfZnJlZQCxAQ5fX3diZ19zbGxfZnJlZQCxAQ5fX3diZ19zcmxfZnJlZQCxAQ5fX3diZ19zdWJfZnJlZQCxAQ5fX3diZ194b3JfZnJlZQCxAQ9fX3diZ19tbGR2X2ZyZWUAsQEOX193YmdfcmV0X2ZyZWUAsQEPX193YmdfcmV0ZF9mcmVlALEBD19fd2JnX2Fsb2NfZnJlZQCxAQ5fX3diZ19tY2xfZnJlZQCxAQ5fX3diZ19tY3BfZnJlZQCxAQ5fX3diZ19tZXFfZnJlZQCxAQ9fX3diZ19iaHNoX2ZyZWUAsQEPX193YmdfYmhlaV9mcmVlALEBD19fd2JnX2J1cm5fZnJlZQCxAQ9fX3diZ19jYWxsX2ZyZWUAsQEOX193YmdfY2NwX2ZyZWUAsQEPX193YmdfY3Jvb19mcmVlALEBD19fd2JnX2NzaXpfZnJlZQCxAQ1fX3diZ19jYl9mcmVlALEBDl9fd2JnX2xkY19mcmVlALEBDl9fd2JnX2xvZ19mcmVlALEBD19fd2JnX2xvZ2RfZnJlZQCxAQ9fX3diZ19taW50X2ZyZWUAsQEPX193YmdfcnZydF9mcmVlALEBD19fd2JnX3Njd3FfZnJlZQCxAQ5fX3diZ19zcndfZnJlZQCxAQ9fX3diZ19zcndxX2ZyZWUAsQEOX193Ymdfc3d3X2ZyZWUAsQEPX193Ymdfc3d3cV9mcmVlALEBDV9fd2JnX3RyX2ZyZWUAsQEOX193YmdfdHJvX2ZyZWUAsQEPX193YmdfZWNrMV9mcmVlALEBD19fd2JnX2VjcjFfZnJlZQCxAQ9fX3diZ19lZDE5X2ZyZWUAsQEPX193YmdfazI1Nl9mcmVlALEBD19fd2JnX3MyNTZfZnJlZQCxAQ9fX3diZ190aW1lX2ZyZWUAsQEPX193Ymdfbm9vcF9mcmVlALEBD19fd2JnX2ZsYWdfZnJlZQCxAQ5fX3diZ19iYWxfZnJlZQCxAQ5fX3diZ19qbXBfZnJlZQCxAQ5fX3diZ19qbmVfZnJlZQCxAQ5fX3diZ19zbW9fZnJlZQCxAQ9fX3diZ19hZGRpX2ZyZWUAsQEPX193YmdfYW5kaV9mcmVlALEBD19fd2JnX2RpdmlfZnJlZQCxAQ9fX3diZ19leHBpX2ZyZWUAsQEPX193YmdfbW9kaV9mcmVlALEBD19fd2JnX211bGlfZnJlZQCxAQ5fX3diZ19vcmlfZnJlZQCxAQ9fX3diZ19zbGxpX2ZyZWUAsQEPX193Ymdfc3JsaV9mcmVlALEBD19fd2JnX3N1YmlfZnJlZQCxAQ9fX3diZ194b3JpX2ZyZWUAsQEPX193Ymdfam5laV9mcmVlALEBDV9fd2JnX2xiX2ZyZWUAsQENX193YmdfbHdfZnJlZQCxAQ1fX3diZ19zYl9mcmVlALEBDV9fd2JnX3N3X2ZyZWUAsQEPX193YmdfbWNwaV9mcmVlALEBDl9fd2JnX2d0Zl9mcmVlALEBD19fd2JnX21jbGlfZnJlZQCxAQ1fX3diZ19nbV9mcmVlALEBD19fd2JnX21vdmlfZnJlZQCxAQ9fX3diZ19qbnppX2ZyZWUAsQEPX193Ymdfam1wZl9mcmVlALEBD19fd2JnX2ptcGJfZnJlZQCxAQ9fX3diZ19qbnpmX2ZyZWUAsQEPX193Ymdfam56Yl9mcmVlALEBD19fd2JnX2puZWZfZnJlZQCxAQ9fX3diZ19qbmViX2ZyZWUAsQENX193YmdfamlfZnJlZQCxAQ9fX3diZ19jZmVpX2ZyZWUAsQEPX193YmdfY2ZzaV9mcmVlALEBDl9fd2JnX2NmZV9mcmVlALEBDl9fd2JnX2Nmc19mcmVlALEBD19fd2JnX3BzaGxfZnJlZQCxAQ9fX3diZ19wc2hoX2ZyZWUAsQEPX193YmdfcG9wbF9mcmVlALEBD19fd2JnX3BvcGhfZnJlZQCxAQ9fX3diZ193ZGNtX2ZyZWUAsQEPX193Ymdfd3FjbV9mcmVlALEBD19fd2JnX3dkb3BfZnJlZQCxAQ9fX3diZ193cW9wX2ZyZWUAsQEPX193Ymdfd2RtbF9mcmVlALEBD19fd2JnX3dxbWxfZnJlZQCxAQ9fX3diZ193ZGR2X2ZyZWUAsQEPX193Ymdfd3Fkdl9mcmVlALEBD19fd2JnX3dkbWRfZnJlZQCxAQ9fX3diZ193cW1kX2ZyZWUAsQEPX193Ymdfd2RhbV9mcmVlALEBD19fd2JnX3dxYW1fZnJlZQCxAQ9fX3diZ193ZG1tX2ZyZWUAsQEPX193Ymdfd3FtbV9mcmVlALEBBmFuZF9yYwCMAQZkaXZfcmMAjAEFZXFfcmMAjAEGZXhwX3JjAIwBBWd0X3JjAIwBBWx0X3JjAIwBB21sb2dfcmMAjAEHbXJvb19yYwCMAQZtb2RfcmMAjAEGbXVsX3JjAIwBBW9yX3JjAIwBBnNsbF9yYwCMAQZzcmxfcmMAjAEGc3ViX3JjAIwBBnhvcl9yYwCMAQdtbGR2X3JjAIwBBm1jcF9yYwCMAQZtZXFfcmMAjAEHY2FsbF9yYwCMAQZjY3BfcmMAjAEGbGRjX3JjAIwBBmxvZ19yYwCMAQdsb2dkX3JjAIwBB3Njd3FfcmMAjAEGc3J3X3JjAIwBB3Nyd3FfcmMAjAEGc3d3X3JjAIwBB3N3d3FfcmMAjAEFdHJfcmMAjAEGdHJvX3JjAIwBB2VjazFfcmMAjAEHZWNyMV9yYwCMAQdlZDE5X3JjAIwBB2syNTZfcmMAjAEHczI1Nl9yYwCMAQZiYWxfcmMAjAEGam5lX3JjAIwBBnNtb19yYwCMAQdqbmVmX3JjAIwBB2puZWJfcmMAjAEHd2RjbV9yYwCMAQd3cWNtX3JjAIwBB3dkb3BfcmMAjAEHd3FvcF9yYwCMAQd3ZG1sX3JjAIwBB3dxbWxfcmMAjAEHd2Rkdl9yYwCMAQd3cWR2X3JjAIwBB3dkbWRfcmMAjAEHd3FtZF9yYwCMAQd3ZGFtX3JjAIwBB3dxYW1fcmMAjAEHd2RtbV9yYwCMAQd3cW1tX3JjAIwBEF9fd2JnX2ltbTA2X2ZyZWUAsQERcmVnaWRfbmV3X2NoZWNrZWQAowEJcmVnaWRfYmFsALIBCnJlZ2lkX2NnYXMAswEJcmVnaWRfZXJyALQBCnJlZ2lkX2ZsYWcAtQEIcmVnaWRfZnAAtgEKcmVnaWRfZ2dhcwC3AQhyZWdpZF9ocAC4AQhyZWdpZF9pcwC5AQhyZWdpZF9vZgC6AQlyZWdpZF9vbmUAuwEIcmVnaWRfcGMAvAEJcmVnaWRfcmV0AL0BCnJlZ2lkX3JldGwAvgEIcmVnaWRfc3AAvwEJcmVnaWRfc3BwAMABDnJlZ2lkX3dyaXRhYmxlAMEBCnJlZ2lkX3plcm8AwgEUcmVnaWRfbmV3X3R5cGVzY3JpcHQArQELcmVnaWRfdG9fdTgAqwEQX193YmdfcmVnaWRfZnJlZQCxARBfX3diZ19pbW0xMl9mcmVlALEBEF9fd2JnX2ltbTE4X2ZyZWUAsQEQX193YmdfaW1tMjRfZnJlZQCxARZfX3diZ19jb21wYXJlYXJnc19mcmVlALEBGl9fd2JnX2dldF9jb21wYXJlYXJnc19tb2RlAMMBGl9fd2JnX3NldF9jb21wYXJlYXJnc19tb2RlAKQBIl9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMArgEiX193Ymdfc2V0X2NvbXBhcmVhcmdzX2luZGlyZWN0X3JocwCqARJjb21wYXJlYXJnc190b19pbW0AkAEUY29tcGFyZWFyZ3NfZnJvbV9pbW0AhgEVX193YmdfZ2V0X21hdGhhcmdzX29wAMMBFV9fd2JnX3NldF9tYXRoYXJnc19vcAClAR5fX3diZ19nZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAwwEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAKwBH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMArgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAK4BHl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X2xocwDDAR9fX3diZ19zZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzAKoBHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwCqAR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9saHMArAETX193YmdfbWF0aGFyZ3NfZnJlZQCxARJfX3diZ19tdWxhcmdzX2ZyZWUAsQESX193YmdfZGl2YXJnc19mcmVlALEBDGdtX2Zyb21fYXJncwB6DWd0Zl9mcm9tX2FyZ3MAdgdnbV9hcmdzAHcIZ3RmX2FyZ3MAcg53ZGNtX2Zyb21fYXJncwA4Dndkb3BfZnJvbV9hcmdzADgOd2RtbF9mcm9tX2FyZ3MAOQ53ZGR2X2Zyb21fYXJncwBLCXdkY21fYXJncwApCXdxY21fYXJncwAqCXdkb3BfYXJncwAr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QRBBCBDNAUEFayAASxtBCBDNASIDakEQQQgQzQFqQQRrEAEiAkUNACACEOoBIQACQCABQQFrIgQgAnFFBEAgACEBDAELIAIgBGpBACABa3EQ6gEhAkEQQQgQzQEhBCAAEOEBIAIgAUEAIAIgAGsgBE0baiIBIABrIgJrIQQgABDVAUUEQCABIAQQsAEgACACELABIAAgAhAEDAELIAAoAgAhACABIAQ2AgQgASAAIAJqNgIACyABENUBDQEgARDhASICQRBBCBDNASADak0NASABIAMQ5wEhACABIAMQsAEgACACIANrIgMQsAEgACADEAQMAQsgBA8LIAEQ6QEgARDVARoLEAAgACABIAIgA0HTABD2AQsQACAAIAEgAiADQdQAEPYBCxAAIAAgASACIANB3gAQ9gELEAAgACABIAIgA0HfABD2AQsQACAAIAEgAiADQeAAEPYBCxAAIAAgASACIANB4QAQ9gELEAAgACABIAIgA0HiABD2AQsQACAAIAEgAiADQeMAEPYBCxAAIAAgASACIANB5AAQ9gELEAAgACABIAIgA0HlABD2AQuQBAEFfyMAQRBrIgMkACAAKAIAIQACQCABQf8ATQRAIAAoAggiAiAAKAIARgRAIwBBIGsiBCQAAkACQCACQQFqIgJFDQBBCCAAKAIAIgVBAXQiBiACIAIgBkkbIgIgAkEITRsiAkF/c0EfdiEGAkAgBQRAIARBATYCGCAEIAU2AhQgBCAAQQRqKAIANgIQDAELIARBADYCGAsgBCACIAYgBEEQahB4IAQoAgQhBSAEKAIARQRAIAAgAjYCACAAIAU2AgQMAgsgBEEIaigCACICQYGAgIB4Rg0BIAJFDQAgBSACEOUBAAsQogEACyAEQSBqJAAgACgCCCECCyAAIAJBAWo2AgggACgCBCACaiABOgAADAELIANBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAyABQT9xQYABcjoADyADIAFBBnZBP3FBgAFyOgAOIAMgAUEMdkE/cUGAAXI6AA0gAyABQRJ2QQdxQfABcjoADEEEDAILIAMgAUE/cUGAAXI6AA4gAyABQQx2QeABcjoADCADIAFBBnZBP3FBgAFyOgANQQMMAQsgAyABQT9xQYABcjoADSADIAFBBnZBwAFyOgAMQQILIQEgASAAKAIAIAAoAggiAmtLBEAgACACIAEQdCAAKAIIIQILIAAoAgQgAmogA0EMaiABEOYBGiAAIAEgAmo2AggLIANBEGokAEEAC9oGAgx/AX4jAEEwayIFJABBJyEDAkAgAEKQzgBUBEAgACEODAELA0AgBUEJaiADaiICQQRrIAAgAEKQzgCAIg5CkM4Afn2nIgRB//8DcUHkAG4iBkEBdEGgi8AAai8AADsAACACQQJrIAQgBkHkAGxrQf//A3FBAXRBoIvAAGovAAA7AAAgA0EEayEDIABC/8HXL1YgDiEADQALCyAOpyICQeMASwRAIANBAmsiAyAFQQlqaiAOpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRBoIvAAGovAAA7AAALAkAgAkEKTwRAIANBAmsiAyAFQQlqaiACQQF0QaCLwABqLwAAOwAADAELIANBAWsiAyAFQQlqaiACQTBqOgAACwJ/IAVBCWogA2ohCUErQYCAxAAgASICKAIYIgFBAXEiBBshBiAEQScgA2siCmohA0GIi8AAQQAgAUEEcRshCAJAAkAgAigCCEUEQEEBIQEgAigCACIEIAJBBGooAgAiAiAGIAgQpwENAQwCCwJAAkACQAJAIAMgAkEMaigCACIESQRAIAFBCHENBCAEIANrIgMhBEEBIAItACAiASABQQNGG0EDcSIBQQFrDgIBAgMLQQEhASACKAIAIgQgAkEEaigCACICIAYgCBCnAQ0EDAULQQAhBCADIQEMAQsgA0EBdiEBIANBAWpBAXYhBAsgAUEBaiEBIAJBBGooAgAhAyACKAIcIQcgAigCACECAkADQCABQQFrIgFFDQEgAiAHIAMoAhARAgBFDQALQQEMBAtBASEBIAdBgIDEAEYNASACIAMgBiAIEKcBDQEgAiAJIAogAygCDBEAAA0BQQAhAQJ/A0AgBCABIARGDQEaIAFBAWohASACIAcgAygCEBECAEUNAAsgAUEBawsgBEkhAQwBCyACKAIcIQwgAkEwNgIcIAItACAhDUEBIQEgAkEBOgAgIAIoAgAiByACQQRqKAIAIgsgBiAIEKcBDQAgBCADa0EBaiEBAkADQCABQQFrIgFFDQEgB0EwIAsoAhARAgBFDQALQQEMAwtBASEBIAcgCSAKIAsoAgwRAAANACACIA06ACAgAiAMNgIcQQAMAgsgAQwBCyAEIAkgCiACKAIMEQAACyAFQTBqJAALDQAgACABIAJBORDzAQsNACAAIAEgAkE6EPMBCw0AIAAgASACQTsQ8wELDQAgACABIAJBPBDzAQsNACAAIAEgAkE9EPMBCw0AIAAgASACQT4Q8wELDQAgACABIAJBPxDzAQsOACAAIAEgAkHAABDzAQsOACAAIAEgAkHBABDzAQsOACAAIAEgAkHCABDzAQsOACAAIAEgAkHDABDzAQsOACAAIAEgAkHEABDzAQsOACAAIAEgAkHFABDzAQsOACAAIAEgAkHGABDzAQsOACAAIAEgAkHHABDzAQsOACAAIAEgAkHIABDzAQsOACAAIAEgAkHJABDzAQsOACAAIAEgAkHKABDzAQsOACAAIAEgAkHRABDzAQsOACAAIAEgAkHSABDzAQu8AgEFfyAAKAIYIQMCQAJAIAAgACgCDEYEQCAAQRRBECAAQRRqIgEoAgAiBBtqKAIAIgINAUEAIQEMAgsgACgCCCICIAAoAgwiATYCDCABIAI2AggMAQsgASAAQRBqIAQbIQQDQCAEIQUgAiIBQRRqIgIgAUEQaiACKAIAIgIbIQQgAUEUQRAgAhtqKAIAIgINAAsgBUEANgIACwJAIANFDQACQCAAIAAoAhxBAnRBpI3AAGoiAigCAEcEQCADQRBBFCADKAIQIABGG2ogATYCACABRQ0CDAELIAIgATYCACABDQBBwJDAAEHAkMAAKAIAQX4gACgCHHdxNgIADwsgASADNgIYIAAoAhAiAgRAIAEgAjYCECACIAE2AhgLIABBFGooAgAiAEUNACABQRRqIAA2AgAgACABNgIYCwuuAgEEfyAAQgA3AhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQh2ZyICa3ZBAXEgAkEBdGtBPmoLIgI2AhwgAkECdEGkjcAAaiEEIAAhAwJAAkACQAJAQcCQwAAoAgAiAEEBIAJ0IgVxBEAgBCgCACEAIAIQywEhAiAAEOEBIAFHDQEgACECDAILQcCQwAAgACAFcjYCACAEIAM2AgAgAyAENgIYDAMLIAEgAnQhBANAIAAgBEEddkEEcWpBEGoiBSgCACICRQ0CIARBAXQhBCACIgAQ4QEgAUcNAAsLIAIoAggiACADNgIMIAIgAzYCCCADIAI2AgwgAyAANgIIIANBADYCGA8LIAUgAzYCACADIAA2AhgLIAMgAzYCCCADIAM2AgwLEAAgACABIAIgA0HeABD8AQsQACAAIAEgAiADQd8AEPwBCxAAIAAgASACIANB4AAQ/AELEAAgACABIAIgA0HhABD8AQsQACAAIAEgAiADQeIAEP4BCxAAIAAgASACIANB4wAQ/gELYAEMf0GsjsAAKAIAIgIEQEGkjsAAIQYDQCACIgEoAgghAiABKAIEIQMgASgCACEEIAFBDGooAgAaIAEhBiAFQQFqIQUgAg0ACwtB5JDAAEH/HyAFIAVB/x9NGzYCAEEACxAAIAAgASACIANB5AAQ/QELEAAgACABIAIgA0HlABD9AQsMACAAIAFBywAQ9wELDAAgACABQcwAEPcBCwwAIAAgAUHNABD3AQsMACAAIAFBzgAQ9wELDAAgACABQc8AEPcBCwwAIAAgAUHQABD3AQv7AQIBfgJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBSAAEAIgAUUNACABKAIADQEgAS0ABCEGIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIANBADYCACADKQIAIQQgAxACQQhBBBDQASIARQ0CIAAgBkEMdCAFQRJ0ciABQQZ0ciICIARCIIinIARCI4inQSBxckH/AXFyIgFBGHQgAkEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQAL+gECAX4CfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQUgABACIAFFDQAgASgCAA0BIAEtAAQhBiABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADQQA2AgAgAykCACEEIAMQAkEIQQQQ0AEiAEUNAiAAIARCI4inQSBxIAZBDHQgBUESdHIgAUEGdHIiAiAEQhyIp0EQcXJyIgFBGHQgAkEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQALDwAgACABIAIgA0ESEPgBCw8AIAAgASACIANBGBD4AQsPACAAIAEgAiADQRwQ+AELDwAgACABIAIgA0EdEPgBCw8AIAAgASACIANBIhD4AQsPACAAIAEgAiADQSMQ+AELDwAgACABIAIgA0EoEPgBCw8AIAAgASACIANBKhD4AQsPACAAIAEgAiADQSwQ+AELDwAgACABIAIgA0E4EPgBCxAAIAAgASACIANB5gAQ+AELEAAgACABIAIgA0HnABD4AQsQACAAIAEgAiADQegAEPgBCxAAIAAgASACIANB6QAQ+AELEAAgACABIAIgA0HqABD4AQsQACAAIAEgAiADQesAEPgBC4YCAgN/AX4jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEAMaIAFBCGogBCgCADYCACABIAIpAwg3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBIGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDGEEMQQQQ0AEiAUUEQEEMQQQQ5QEACyABIAIpAxg3AgAgAUEIaiADKAIANgIAIABB6InAADYCBCAAIAE2AgAgAkEwaiQAC+YBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBCAAEAIgAUUNACABKAIADQEgAS0ABCEFIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIAMtAAQhAiADEAJBCEEEENABIgBFDQIgACAFQQx0IARBEnRyIAFBBnRyIgMgAkEFdEEgcXIiAUEYdCADQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIgFBCHZBgICAB3EgAUGA/v8HcUEIdnKtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAvgAQECfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQQgABACIAFFDQAgASgCAA0BIAEtAAQhBSABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADLQAEIQIgAxACQQhBBBDQASIARQ0CIAAgAiAFQQx0IARBEnRyIAFBBnRyIgNyIgFBGHQgA0EIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQALCgAgAEHVABD1AQsKACAAQdYAEPUBCwoAIABB1wAQ9QELCgAgAEHaABD1AQsKACAAQdsAEPUBCwoAIABB3AAQ9QELCgAgAEHdABD1AQsNACAAIAEgAkEBEPQBCw0AIAAgASACQQIQ9AELDQAgACABIAJBAxD0AQsNACAAIAEgAkEEEPQBCw0AIAAgASACQQUQ9AELDQAgACABIAJBBhD0AQsNACAAIAEgAkEHEPQBCw0AIAAgASACQQgQ9AELDQAgACABIAJBCRD0AQsNACAAIAEgAkELEPQBCw0AIAAgASACQQ0Q9AELDQAgACABIAJBDhD0AQsNACAAIAEgAkEPEPQBCw0AIAAgASACQRAQ9AELDQAgACABIAJBERD0AQsNACAAIAEgAkEXEPQBCw0AIAAgASACQSEQ9AELDQAgACABIAJBJhD0AQsNACAAIAEgAkEnEPQBCw0AIAAgASACQSkQ9AELDQAgACABIAJBKxD0AQsNACAAIAEgAkEtEPQBCw0AIAAgASACQS4Q9AELDQAgACABIAJBLxD0AQsNACAAIAEgAkEwEPQBCw0AIAAgASACQTEQ9AELDQAgACABIAJBNRD0AQsNACAAIAEgAkE3EPQBC8cBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DQQRBARDQASIDRQ0BIAMgAkEGdEHA/wBxIAFBDHRBgOA/cSAAQRJ0QYCA8B9xcnIiAEEIdEGAgPwHcSACQR50ciAAQQh2QYD+A3EgAEEYdnJyIgBBCHZBgICABnEgAEGA/v8HcUEIdnJBCHQ2AABBCEEEENABIgBFDQIgACADNgIEIABBADYCACAADwsMAgtBBEEBEOUBAAtBCEEEEOUBAAsQ3AEAC8QBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAyAAEAIgAUUNACABKAIADQEgAS0ABCEEIAEQAiACRQ0AIAIoAgANASACLQAEIQAgAhACQQhBBBDQASIBRQ0CIAEgBEEMdCADQRJ0ciAAQQZ0ciICQQh0QYCA/AdxIABBHnRyIAJBCHZBgP4DcSACQRh2cnIiAEEIdkGAgIAGcSAAQYD+/wdxQQh2cq1CIIY3AgAgAQ8LEN8BAAsQ4AEAC0EIQQQQ5QEAC8kBAQF/IAIQBSECAkACQAJAIABBwAFxRQRAIAFBwAFxDQFBBEEBENABIgNFDQIgAyACQf//A3EgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIAQQh0QYCA/AdxIAJBGHRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdEHKAHI2AABBCEEEENABIgBFDQMgACADNgIEIABBADYCACAADwsQ3AEACxDcAQALQQRBARDlAQALQQhBBBDlAQALwQEBAn8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQQgARACIAJFDQAgAigCAA0BIAIvAQQhACACEAJBCEEEENABIgFFDQIgASAEQQx0IANBEnRyIAByIgJBCHRBgID8B3EgAEEYdHIgAkEIdkGA/gNxIAJBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyrUIghjcCACABDwsQ3wEACxDgAQALQQhBBBDlAQALywEBAn8jAEEgayIDJAACQAJAIAEgASACaiIBSw0AQQggACgCACICQQF0IgQgASABIARJGyIBIAFBCE0bIgFBf3NBH3YhBAJAIAIEQCADQQE2AhggAyACNgIUIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgASAEIANBEGoQeCADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgABDlAQALEKIBAAsgA0EgaiQAC4gCAQJ/IwBBIGsiBSQAQaCNwABBoI3AACgCACIGQQFqNgIAAkACQCAGQQBIDQBB6JDAAEHokMAAKAIAQQFqIgY2AgAgBkECSw0AIAUgBDoAGCAFIAM2AhQgBSACNgIQIAVBsIrAADYCDCAFQaSIwAA2AghBkI3AACgCACICQQBIDQBBkI3AACACQQFqIgI2AgBBkI3AAEGYjcAAKAIABH8gBSAAIAEoAhARBAAgBSAFKQMANwMIQZiNwAAoAgAgBUEIakGcjcAAKAIAKAIUEQQAQZCNwAAoAgAFIAILQQFrNgIAIAZBAUsNACAEDQELAAsjAEEQayICJAAgAiABNgIMIAIgADYCCAALtQEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQAgARACIAIQBSECQQhBBBDQASIBRQ0CIAEgAkH//wNxIABBDHQgA0ESdHJyIgBBCHRBgID8B3EgAkEYdHIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyrUIghjcCACABDwsQ3wEACxDgAQALQQhBBBDlAQALuwEBAX8CQAJAAkAgAUEBa0EESQRAIABBwAFxDQFBBEEBENABIgJFDQIgAiABQQh0QYCA/AdxIAFBGHRyIABBEnRBgIDwH3EgAXIiAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0QcwAcjYAAEEIQQQQ0AEiAEUNAyAAIAI2AgQgAEEANgIAIAAPC0HwhsAAQRkQ3gEACxDcAQALQQRBARDlAQALQQhBBBDlAQALowcBCX8CQCACBEACfwJAAkACQCABQQBOBEAgAygCCEUNAiADKAIEIgYNASABDQMgAgwECyAAQQhqQQA2AgAMBQsCfyADKAIAIQkCQAJAAkAgAkEJTwRAIAEgAhAGIgsNAUEADAQLQQhBCBDNASEKQRRBCBDNASEHQRBBCBDNASEDQQBBEEEIEM0BQQJ0ayIGQYCAfCADIAcgCmpqa0F3cUEDayIDIAMgBksbIAFNDQFBECABQQRqQRBBCBDNAUEFayABSxtBCBDNASEEIAkQ6gEiBSAFEOEBIgMQ5wEhCAJAAkACQAJAAkACQAJAIAUQ1QFFBEAgAyAETw0BIAhB0JDAACgCAEYNAiAIQcyQwAAoAgBGDQMgCBDSAQ0HIAgQ4QEiCiADaiIHIARJDQcgByAEayEMIApBgAJJDQQgCBAnDAULIAUQ4QEhAyAEQYACSQ0GIAMgBGtBgYAISSAEQQRqIANNcQ0FIAUoAgAaIARBH2pBgIAEEM0BGgwGC0EQQQgQzQEgAyAEayIGSw0EIAUgBBDnASEDIAUgBBCwASADIAYQsAEgAyAGEAQMBAtByJDAACgCACADaiIDIARNDQQgBSAEEOcBIQYgBSAEELABIAYgAyAEayIDQQFyNgIEQciQwAAgAzYCAEHQkMAAIAY2AgAMAwtBxJDAACgCACADaiIDIARJDQMCQEEQQQgQzQEgAyAEayIHSwRAIAUgAxCwAUEAIQdBACEGDAELIAUgBBDnASIGIAcQ5wEhAyAFIAQQsAEgBiAHEMwBIAMgAygCBEF+cTYCBAtBzJDAACAGNgIAQcSQwAAgBzYCAAwCCyAIQQxqKAIAIgYgCEEIaigCACIDRwRAIAMgBjYCDCAGIAM2AggMAQtBvJDAAEG8kMAAKAIAQX4gCkEDdndxNgIAC0EQQQgQzQEgDE0EQCAFIAQQ5wEhAyAFIAQQsAEgAyAMELABIAMgDBAEDAELIAUgBxCwAQsgBQ0DCyABEAEiA0UNASADIAkgBRDhAUF4QXwgBRDVARtqIgMgASABIANLGxDmASAJEAIMAwsgCyAJIAYgASABIAZLGxDmARogCRACCyALDAELIAUQ1QEaIAUQ6QELDAILIAENACACDAELIAEgAhDQAQsiAwRAIAAgAzYCBCAAQQhqIAE2AgAgAEEANgIADwsgACABNgIEIABBCGogAjYCAAwBCyAAIAE2AgQgAEEIakEANgIACyAAQQE2AgALpAEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCECIAAQAiABRQ0AIAEoAgANASABKAIEIQAgARACQQhBBBDQASIBRQ0CIAEgAEEIdEGAgPwHcSAAQRh0ciAAIAJBEnRyIgBBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2cq1CIIY3AgAgAQ8LEN8BAAsQ4AEAC0EIQQQQ5QEAC6IBAQF/AkACQAJAIAAEQCAAKAIADQEgAC0ABCECIAAQAiABQQFrQQRPDQJBCEEEENABIgBFDQMgACABQQh0QYCA/AdxIAFBGHRyIAJBEnQgAXIiAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQfCGwABBGRDeAQALQQhBBBDlAQALpAEBA38jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEAMaIAFBCGogBCgCADYCACABIAIpAwg3AgALIABB6InAADYCBCAAIAE2AgAgAkEwaiQACwsAIAAgAUEKEPkBCwsAIAAgAUEMEPkBCwsAIAAgAUEUEPkBCwsAIAAgAUEWEPkBCwsAIAAgAUEZEPkBCwsAIAAgAUEbEPkBCwsAIAAgAUEeEPkBCwsAIAAgAUEfEPkBCwsAIAAgAUEkEPkBCwsAIAAgAUEyEPkBC4IBAQJ/AkACQCAABEAgACgCAA0BIAAtAAQhASAAEAJBACEAAkAgAUEYcQ0AQfcBIAFBBHNBB3EiAnZBAXFFDQBBCEEEENABIgBFDQMgACACQQN0QbCGwABqKQMAIAFBBXZBAXGtQiiGhDcCAAsgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC4ABAQF/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAiAAEAIgAUUNACABKAIADQEgAS0ABCEAIAEQAkEIQQQQ0AEiAUUNAiABIABBFHQgAEEMdCACQRJ0ckEIdnJBgP7DB3FBCHatQiCGNwIAIAEPCxDfAQALEOABAAtBCEEEEOUBAAuCAQEBfwJAAkAgAARAIAAoAgANASAAKAIEIQEgABACQQhBBBDQASIARQ0CIAAgAUEIdEGAgPwHcSABQRh0ciABQQh2QYD+A3EgAUEYdnJyIgFBCHZBgID8B3EgAUGA/v8HcUEIdnKtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAuCAQECfwJAAkAgAARAIAAoAgBBf0YNASAAQQZqLQAAIQEgAC8ABCECQQhBBBDQASIARQ0CIABBADYCACAAIAIgAUEQdHIiAUEQdEGAgAxxIAFBCHRBgIZ8cSIBQQh2QYD+A3EgAUEYdnJyNgIEIAAPCxDfAQALEOABAAtBCEEEEOUBAAt8AQJ/AkACQCAABEAgACgCAEF/Rg0BIABBBmotAAAhASAALwAEIQJBCEEEENABIgBFDQIgAEEANgIAIAAgAiABQRB0ciIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcXJBCHY2AgQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3QBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyIgFBGHQgAUEIdEGAgMAHcXJBFHZBP3E6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3QBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyQQh0QYCAvHhxIgFBCHYgAUEYdnJBBnY6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3EBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyQQh0QYCAvHhxIgFBCHYgAUEYdnI7AQQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC4YBAQJ/AkACQCABBEAgASgCACICQX9GDQEgASACQQFqNgIAIAEoAgQoAAAiAkEYdEEWdUHggsAAaigCACACQYB+cXIhA0EEQQEQ0AEiAkUNAiACIAM2AAAgASABKAIAQQFrNgIAIABBBDYCBCAAIAI2AgAPCxDfAQALEOABAAtBBEEBEOUBAAtyACMAQTBrIgEkAEHojMAALQAABEAgAUEUakECNgIAIAFBHGpBATYCACABQfSIwAA2AhAgAUEANgIIIAFBAjYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQZyJwAAQqAEACyABQTBqJAALYwEBfgJAAkAgAARAIAAoAgANASAAQQA2AgAgACkCACEBIAAQAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACABQiCIpyABQiOIp0EgcXI6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEACwkAIABBAhDyAQsJACAAQRMQ+wELCQAgAEEVEPsBCwkAIABBGhD7AQsJACAAQRAQ8gELCQAgAEEgEPsBCwkAIABBJRD7AQsJACAAQTQQ+wELCQAgAEE2EPsBCwoAIABB2AAQ+wELCgAgAEHZABD7AQtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQAyACQSBqJAALUgEBfwJAAkAgAARAIAAoAgANASAALQAEIQEgABACQQhBBBDQASIARQ0CIAAgAUECdEH8AXGtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAtVAQF/IwBBIGsiASQAIAFBDGpBATYCACABQRRqQQA2AgAgAUGIi8AANgIQIAFBADYCACABQSs2AhwgAUGkiMAANgIYIAEgAUEYajYCCCABIAAQqAEAC0cBAn8CQEEEQQEQ0AEiAQRAIAFBMzYAAEEIQQQQ0AEiAEUNASAAIAE2AgQgAEEANgIAIAAPC0EEQQEQ5QEAC0EIQQQQ5QEAC0cBAX8gAiAAKAIAIgAoAgAgACgCCCIDa0sEQCAAIAMgAhB0IAAoAgghAwsgACgCBCADaiABIAIQ5gEaIAAgAiADajYCCEEAC0YBAX8CQCAAQSZJBEBBDEEEENABIgJFDQEgAiAAOgAIIAIgATYCBCACQQA2AgAgAg8LQYmHwABBGRDeAQALQQxBBBDlAQALSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABB8IrAADYCECAAQcCKwAA2AhggAEEANgIIIABBCGpB+IrAABCoAQALOAEBfwJAIABB/wFxQT9NBEBBCEEEENABIgFFDQEgASAAOgAEIAFBADYCAAsgAQ8LQQhBBBDlAQALCwAgACABQQcQ8QELCwAgACABQQgQ8QELRgECfyABKAIEIQIgASgCACEDQQhBBBDQASIBRQRAQQhBBBDlAQALIAEgAjYCBCABIAM2AgAgAEH4icAANgIEIAAgATYCAAs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAgANARoLIAMNAUEACw8LIAAgA0EAIAEoAgwRAAALsQIBAn8jAEEgayICJAAgAkEBOgAYIAIgATYCFCACIAA2AhAgAkGQi8AANgIMIAJBiIvAADYCCCMAQRBrIgAkAAJAIAJBCGoiASgCDCICBEAgASgCCCIDRQ0BIAAgAjYCCCAAIAE2AgQgACADNgIAIwBBEGsiASQAIAAoAgAiAkEUaigCACEDAkACfwJAAkAgAkEMaigCAA4CAAEDCyADDQJBACECQaSIwAAMAQsgAw0BIAIoAggiAygCBCECIAMoAgALIQMgASACNgIEIAEgAzYCACABQZyKwAAgACgCBCIBKAIIIAAoAgggAS0AEBB1AAsgAUEANgIEIAEgAjYCDCABQYiKwAAgACgCBCIBKAIIIAAoAgggAS0AEBB1AAtB2InAABCeAQALQciJwAAQngEACycBAX8CQCAABEAgACgCAA0BIAAoAgQgABACEAIPCxDfAQALEOABAAsuAAJAIAAEQCAAKAIADQEgAEEANgIAIABBBWogAUEARzoAAA8LEN8BAAsQ4AEACyUBAX8CQCAABEAgACgCAA0BIAAtAAQgABACDwsQ3wEACxDgAQALKwACQCAABEAgACgCAA0BIABBADYCACAAIAFBAEc6AAQPCxDfAQALEOABAAssAQF/QQhBBBDQASIBRQRAQQhBBBDlAQALIAFBADYCACABIABBP3E6AAQgAQsJACAAQQUQ8AELCQAgAEEIEPABCycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAseAAJAIAAEQCAAKAIADQEgABACDwsQ3wEACxDgAQALBwBBCxD6AQsHAEEKEPoBCwcAQQgQ+gELBwBBDxD6AQsHAEEGEPoBCwcAQQkQ+gELBwBBBxD6AQsHAEEMEPoBCwcAQQIQ+gELBwBBARD6AQsHAEEDEPoBCwcAQQ0Q+gELBwBBDhD6AQsHAEEFEPoBCwcAQQQQ+gELBwBBEBD6AQsHAEEAEPoBCyIAAkAgAARAIAAoAgBBf0YNASAALQAEDwsQ3wEACxDgAQALIgACQCAABEAgACgCAEF/Rg0BIAAoAgQPCxDfAQALEOABAAsgAQF/AkAgAEEEaigCACIBRQ0AIAAoAgBFDQAgARACCwsjACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsiAQF/QQhBBBDQASIARQRAQQhBBBDlAQALIABCADcCACAACx4AIAAgAUEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsUACAAKAIABEAgAEEEaigCABACCwsZAQF/IAAoAhAiAQR/IAEFIABBFGooAgALCxIAQRkgAEEBdmtBACAAQR9HGwsWACAAIAFBAXI2AgQgACABaiABNgIACxAAIAAgAWpBAWtBACABa3ELCwAgAQRAIAAQAgsLDwAgAEEBdCIAQQAgAGtyCwgAIAAgARAGCxMAIABB+InAADYCBCAAIAE2AgALDQAgAC0ABEECcUEBdguHDwENfwJ/IAAoAgAhCSAAKAIEIQUCQAJAIAEiBigCCCIKQQFHIAEoAhAiAEEBR3FFBEACQCAAQQFHDQAgBSAJaiEHIAZBFGooAgBBAWohAyAJIQEDQAJAIAEhACADQQFrIgNFDQAgACAHRg0CAn8gACwAACIBQQBOBEAgAUH/AXEhAiAAQQFqDAELIAAtAAFBP3EhCCABQR9xIQIgAUFfTQRAIAJBBnQgCHIhAiAAQQJqDAELIAAtAAJBP3EgCEEGdHIhCCABQXBJBEAgCCACQQx0ciECIABBA2oMAQsgAkESdEGAgPAAcSAALQADQT9xIAhBBnRyciICQYCAxABGDQMgAEEEagsiASAEIABraiEEIAJBgIDEAEcNAQwCCwsgACAHRg0AIAAsAAAiAUEATiABQWBJciABQXBJckUEQCABQf8BcUESdEGAgPAAcSAALQADQT9xIAAtAAJBP3FBBnQgAC0AAUE/cUEMdHJyckGAgMQARg0BCwJAAkAgBEUNACAEIAVPBEBBACEAIAQgBUYNAQwCC0EAIQAgBCAJaiwAAEFASA0BCyAJIQALIAQgBSAAGyEFIAAgCSAAGyEJCyAKRQ0CIAZBDGooAgAhDAJAIAVBEE8EQAJ/QQAhAkEAIQQCQAJAIAkiAEEDakF8cSIBIABrIgcgBUsgB0EES3INACAFIAdrIgpBBEkNACAKQQNxIQtBACEDAkAgACABRg0AIAdBA3EhAgJAIAEgAEF/c2pBA0kEQCAAIQEMAQsgB0F8cSEIIAAhAQNAIAMgASwAAEG/f0pqIAEsAAFBv39KaiABLAACQb9/SmogASwAA0G/f0pqIQMgAUEEaiEBIAhBBGsiCA0ACwsgAkUNAANAIAMgASwAAEG/f0pqIQMgAUEBaiEBIAJBAWsiAg0ACwsgACAHaiEAAkAgC0UNACAAIApBfHFqIgEsAABBv39KIQQgC0EBRg0AIAQgASwAAUG/f0pqIQQgC0ECRg0AIAQgASwAAkG/f0pqIQQLIApBAnYhByADIARqIQIDQCAAIQMgB0UNAkHAASAHIAdBwAFPGyIEQQNxIQggBEECdCELAkAgBEH8AXEiCkUEQEEAIQEMAQsgAyAKQQJ0aiENQQAhAQNAIABFDQEgASAAKAIAIg5Bf3NBB3YgDkEGdnJBgYKECHFqIABBBGooAgAiAUF/c0EHdiABQQZ2ckGBgoQIcWogAEEIaigCACIBQX9zQQd2IAFBBnZyQYGChAhxaiAAQQxqKAIAIgFBf3NBB3YgAUEGdnJBgYKECHFqIQEgAEEQaiIAIA1HDQALCyAHIARrIQcgAyALaiEAIAFBCHZB/4H8B3EgAUH/gfwHcWpBgYAEbEEQdiACaiECIAhFDQALAkAgA0UEQEEAIQEMAQsgAyAKQQJ0aiEAIAhBAWtB/////wNxIgFBAWoiBEEDcSEDAkAgAUEDSQRAQQAhAQwBCyAEQfz///8HcSEIQQAhAQNAIAEgACgCACIEQX9zQQd2IARBBnZyQYGChAhxaiAAQQRqKAIAIgFBf3NBB3YgAUEGdnJBgYKECHFqIABBCGooAgAiAUF/c0EHdiABQQZ2ckGBgoQIcWogAEEMaigCACIBQX9zQQd2IAFBBnZyQYGChAhxaiEBIABBEGohACAIQQRrIggNAAsLIANFDQADQCABIAAoAgAiBEF/c0EHdiAEQQZ2ckGBgoQIcWohASAAQQRqIQAgA0EBayIDDQALCyABQQh2Qf+B/AdxIAFB/4H8B3FqQYGABGxBEHYgAmoMAgtBACAFRQ0BGiAFQQNxIQEgBUEBa0EDTwRAIAVBfHEhAwNAIAIgACwAAEG/f0pqIAAsAAFBv39KaiAALAACQb9/SmogACwAA0G/f0pqIQIgAEEEaiEAIANBBGsiAw0ACwsgAUUNAANAIAIgACwAAEG/f0pqIQIgAEEBaiEAIAFBAWsiAQ0ACwsgAgshAQwBCyAFRQRAQQAhAQwBCyAFQQNxIQICQCAFQQFrQQNJBEBBACEBIAkhAAwBCyAFQXxxIQNBACEBIAkhAANAIAEgACwAAEG/f0pqIAAsAAFBv39KaiAALAACQb9/SmogACwAA0G/f0pqIQEgAEEEaiEAIANBBGsiAw0ACwsgAkUNAANAIAEgACwAAEG/f0pqIQEgAEEBaiEAIAJBAWsiAg0ACwsgASAMSQRAIAwgAWsiASEDAkACQAJAIAYtACAiAEEAIABBA0cbQQNxIgBBAWsOAgABAgtBACEDIAEhAAwBCyABQQF2IQAgAUEBakEBdiEDCyAAQQFqIQAgBkEEaigCACEBIAYoAhwhAiAGKAIAIQYCQANAIABBAWsiAEUNASAGIAIgASgCEBECAEUNAAtBAQwFC0EBIQAgAkGAgMQARg0CIAYgCSAFIAEoAgwRAAANAkEAIQADQEEAIAAgA0YNBRogAEEBaiEAIAYgAiABKAIQEQIARQ0ACyAAQQFrIANJDAQLDAILIAYoAgAgCSAFIAYoAgQoAgwRAAAhAAsgAAwBCyAGKAIAIAkgBSAGKAIEKAIMEQAACwsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAaA0AMAAsACwsAIAA1AgAgARASCwsAIAAxAAAgARASCwsAIAAzAQAgARASC3IBAn8jAEEQayIBJAAgAUEiNgIMIAFBgIDAADYCCCMAQSBrIgAkACAAQQxqQQE2AgAgAEEUakEBNgIAIABBiIvAADYCCCAAQQA2AgAgAEETNgIcIAAgAUEIajYCGCAAIABBGGo2AhAgAEG4gMAAEKgBAAsLACAAIwBqJAAjAAsJACAAIAEQAAALDQBBoofAAEEbEN4BAAsOAEG9h8AAQc8AEN4BAAsKACAAKAIEQXhxCwoAIAAoAgRBAXELCgAgACgCDEEBcQsKACAAKAIMQQF2CxkAIAAgAUGMjcAAKAIAIgBBBCAAGxEEAAALswIBB38CQCACIgRBD00EQCAAIQIMAQsgAEEAIABrQQNxIgNqIQUgAwRAIAAhAiABIQYDQCACIAYtAAA6AAAgBkEBaiEGIAJBAWoiAiAFSQ0ACwsgBSAEIANrIghBfHEiB2ohAgJAIAEgA2oiA0EDcSIEBEAgB0EATA0BIANBfHEiBkEEaiEBQQAgBEEDdCIJa0EYcSEEIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgBHRyNgIAIAFBBGohASAFQQRqIgUgAkkNAAsMAQsgB0EATA0AIAMhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIAJJDQALCyAIQQNxIQQgAyAHaiEBCyAEBEAgAiAEaiEDA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0kNAAsLIAALBwAgACABagsHACAAIAFrCwcAIABBCGoLBwAgAEEIawsEAEEECwwAQtbkq/72/7CeagsNAELKvdvazqCx5od/Cw0AQsi14M/KhtvTiX8LAgALJQACQCAABEAgACgCAEF/Rg0BIAAgAWotAAAPCxDfAQALEOABAAs9AAJAAkAgAARAIAEgAk8NASAAKAIADQIgAEEANgIAIAAgAToABA8LEN8BAAtBkIbAAEEZEN4BAAsQ4AEAC2MBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACECIAAvAAQhA0EIQQQQ0AEiAEUNAiAAQQA2AgAgACADIAJBEHRyIAF2QT9xOgAEIAAPCxDfAQALEOABAAtBCEEEEOUBAAu3AgECfyMAQTBrIgQkAAJAAkACQAJAIABBwAFxRQRAIAFBwAFxDQEgBCACOwEOIAJB//8DcUGAIE8NAkEEQQEQ0AEiBUUNAyAFIAJB//8DcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgBBCHRBgID8B3EgAkEYdHIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0IANyNgAAQQhBBBDQASIARQ0EIAAgBTYCBCAAQQA2AgAgBEEwaiQAIAAPCxDcAQALENwBAAsgBEEcakECNgIAIARBJGpBATYCACAEQbiBwAA2AhggBEEANgIQIARBATYCLCAEIARBKGo2AiAgBCAEQQ5qNgIoIARBEGpByIHAABCoAQALQQRBARDlAQALQQhBBBDlAQALygEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXEgAkHAAXFyDQNBBEEBENABIgRFDQEgBCACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIAQQh0QYCA/AdxIAJBHnRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgIAGcSAAQYD+/wdxQQh2ckEIdCADcjYAAEEIQQQQ0AEiAEUNAiAAIAQ2AgQgAEEANgIAIAAPCwwCC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQAL9wEBAn8jAEEwayICJAAgAiAANgIMAkACQCAAQYCAgAhJBEBBBEEBENABIgNFDQEgAyAAQQh0QYCA/AdxIABBGHRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCABcjYAAEEIQQQQ0AEiAEUNAiAAIAM2AgQgAEEANgIAIAJBMGokACAADwsgAkEcakECNgIAIAJBJGpBATYCACACQcCCwAA2AhggAkEANgIQIAJBAjYCLCACIAJBKGo2AiAgAiACQQxqNgIoIAJBEGpB0ILAABCoAQALQQRBARDlAQALQQhBBBDlAQALxwIBAn8jAEEwayIFJAACQAJAAkACQCAAQcABcUUEQCABQcABcSACQcABcXINBCAFIAM6AA8gA0H/AXFBwABPDQFBBEEBENABIgZFDQIgBiACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIANB/wFxciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAyAAIAY2AgQgAEEANgIAIAVBMGokACAADwsMAwsgBUEcakECNgIAIAVBJGpBATYCACAFQfSAwAA2AhggBUEANgIQIAVBAzYCLCAFIAVBKGo2AiAgBSAFQQ9qNgIoIAVBEGpBhIHAABCoAQALQQRBARDlAQALQQhBBBDlAQALENwBAAuUAgECfyMAQTBrIgMkAAJAAkACQCAAQcABcUUEQCADIAE2AgwgAUGAgBBPDQFBBEEBENABIgRFDQIgBCABQQh0QYCA/AdxIAFBGHRyIABBEnRBgIDwH3EgAXIiAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0IAJyNgAAQQhBBBDQASIARQ0DIAAgBDYCBCAAQQA2AgAgA0EwaiQAIAAPCxDcAQALIANBHGpBAjYCACADQSRqQQE2AgAgA0H8gcAANgIYIANBADYCECADQQI2AiwgAyADQShqNgIgIAMgA0EMajYCKCADQRBqQYyCwAAQqAEAC0EEQQEQ5QEAC0EIQQQQ5QEAC9sBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DIANBwAFxDQNBBEEBENABIgVFDQEgBSACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIANB/wFxciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAiAAIAU2AgQgAEEANgIAIAAPCwwCC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQALjQEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXENAUEEQQEQ0AEiA0UNAiADIAFBFHRBgIDAB3EgAEESdEGAgPAHcSABQQx0QYCAPHFyQQh2ciACcjYAAEEIQQQQ0AEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxDcAQALENwBAAtBBEEBEOUBAAtBCEEEEOUBAAspAQF/QQhBBBDQASIBRQRAQQhBBBDlAQALIAEgADoABCABQQA2AgAgAQtjAQF/AkACQCAAQcABcUUEQEEEQQEQ0AEiAkUNASACIABBCnRBgPgDcSABcjYAAEEIQQQQ0AEiAEUNAiAAIAI2AgQgAEEANgIAIAAPCxDcAQALQQRBARDlAQALQQhBBBDlAQALhQIBAX4CQAJAAkACQCADBEAgAygCAA0BIANBADYCACADKQIAIQUgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEEEQQEQ0AEiA0UNAiADIAJBBnRBwP8AcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgEgBUIgiKcgBUIjiKdBIHFyQf8BcXIiAEEYdCABQQh0QYCA/AdxciAAQQh2QYD+A3EgAEEYdnJyIgBBCHZBgID8B3EgAEGA/v8HcUEIdnJBCHQgBHI2AABBCEEEENABIgBFDQMgACADNgIEIABBADYCACAADwsQ3wEACxDgAQALQQRBARDlAQALQQhBBBDlAQALENwBAAvyAQEBfwJAAkACQAJAIAMEQCADKAIADQEgAy0ABCEFIAMQAiACQcABcSAAQcABcSABQcABcXJyDQRBBEEBENABIgNFDQIgAyACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIAVBBXRBIHFyIgBBGHQgAUEIdEGAgPwHcXIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCAgAdxIABBgP7/B3FBCHZyQQh0IARyNgAAQQhBBBDQASIARQ0DIAAgAzYCBCAAQQA2AgAgAA8LEN8BAAsQ4AEAC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQALhAIBAX4CQAJAAkACQCADBEAgAygCAA0BIANBADYCACADKQIAIQUgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEEEQQEQ0AEiA0UNAiADIAVCI4inQSBxIAJBBnRBwP8AcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgEgBUIciKdBEHFyciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxDfAQALEOABAAtBBEEBEOUBAAtBCEEEEOUBAAsQ3AEACwvhDAMAQYCAwAALqQZDaGVja1JlZ0lkIHdhcyBnaXZlbiBpbnZhbGlkIFJlZ0lkZnVlbC1hc20vc3JjL2xpYi5ycwAAACIAEAATAAAAbAAAACIAAABWYWx1ZSBgYCBvdXQgb2YgcmFuZ2UgZm9yIDYtYml0IGltbWVkaWF0ZQAAAEgAEAAHAAAATwAQACIAAAAiABAAEwAAAKQDAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDEyLWJpdCBpbW1lZGlhdGUASAAQAAcAAACUABAAIwAAACIAEAATAAAAqQMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMTgtYml0IGltbWVkaWF0ZQBIABAABwAAANgAEAAjAAAAIgAQABMAAACuAwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAyNC1iaXQgaW1tZWRpYXRlAEgAEAAHAAAAHAEQACMAAAAiABAAEwAAALMDAAAcAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAJYAAACXAAAAmAAAAKAAAAChAAAAogAAAKMAAACkAAAApQAAAKYAAACnAAAAqAAAAKkAAACqAAAAqwAAAKwAAACtAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZABBtIbAAAsRBAAAAAAAAAAFAAAAAAAAAAYAQdyGwAALjAYBAAAAAAAAAAIAAAAAAAAAAwAAAGludmFsaWQgZW51bSB2YWx1ZSBwYXNzZWRpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAUAAAAEAAAABAAAAAYAAAAHAAAACAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAAAATwQQABUAAABkBBAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc4QEEAAYAAAAVQEAAAkAAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzrAQQABwAAABCAgAAHgAAAKwEEAAcAAAAQQIAAB8AAAAJAAAADAAAAAQAAAAKAAAABQAAAAgAAAAEAAAACwAAAAwAAAAQAAAABAAAAA0AAAAOAAAABQAAAAgAAAAEAAAADwAAABAAAAAFAAAAAAAAAAEAAAARAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAAXAUQABEAAABABRAAHAAAAA0CAAAFAAAAiAUQAAAAAAAUAAAAAAAAAAEAAAAVAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAbwlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNjkuMCAoODRjODk4ZDY1IDIwMjMtMDQtMTYpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuBjAuMi44Nw==', imports)}

async function initWasm () {
  return await __wbg_init(wasm());
}

/**
 * calling it right away for pre-caching
 * the wasm async initialization at startup
 */
initWasm();

export { ADD, ADDI, ALOC, AND, ANDI, BAL, BHEI, BHSH, BURN, CALL, CB, CCP, CFE, CFEI, CFS, CFSI, CROO, CSIZ, CompareArgs, CompareMode, DIV, DIVI, DivArgs, ECK1, ECR1, ED19, EQ, EXP, EXPI, FLAG, GM, GMArgs, GT, GTF, GTFArgs, Imm06, Imm12, Imm18, Imm24, Instruction, JI, JMP, JMPB, JMPF, JNE, JNEB, JNEF, JNEI, JNZB, JNZF, JNZI, K256, LB, LDC, LOG, LOGD, LT, LW, MCL, MCLI, MCP, MCPI, MEQ, MINT, MLDV, MLOG, MOD, MODI, MOVE, MOVI, MROO, MUL, MULI, MathArgs, MathOp, MulArgs, NOOP, NOT, OR, ORI, POPH, POPL, PSHH, PSHL, PanicInstruction, PanicReason, RET, RETD, RVRT, RegId, S256, SB, SCWQ, SLL, SLLI, SMO, SRL, SRLI, SRW, SRWQ, SUB, SUBI, SW, SWW, SWWQ, TIME, TR, TRO, WDAM, WDCM, WDDV, WDMD, WDML, WDMM, WDOP, WQAM, WQCM, WQDV, WQMD, WQML, WQMM, WQOP, XOR, XORI, add, addi, aloc, and, andi, bal, bhei, bhsh, burn, call, cb, ccp, cfe, cfei, cfs, cfsi, croo, csiz, div, divi, eck1, ecr1, ed19, eq, exp, expi, flag, gm, gm_args, gt, gtf, gtf_args, initSync, initWasm, ji, jmp, jmpb, jmpf, jne, jneb, jnef, jnei, jnzb, jnzf, jnzi, k256, lb, ldc, log, logd, lt, lw, mcl, mcli, mcp, mcpi, meq, mint, mldv, mlog, mod_, modi, move_, movi, mroo, mul, muli, noop, not, or, ori, poph, popl, pshh, pshl, ret, retd, rvrt, s256, sb, scwq, sll, slli, smo, srl, srli, srw, srwq, sub, subi, sw, sww, swwq, time, tr, tro, wdam, wdcm, wdcm_args, wddv, wddv_args, wdmd, wdml, wdml_args, wdmm, wdop, wdop_args, wqam, wqcm, wqcm_args, wqdv, wqdv_args, wqmd, wqml, wqml_args, wqmm, wqop, wqop_args, xor, xori };
