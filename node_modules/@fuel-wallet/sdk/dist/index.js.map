{"version":3,"sources":["../../types/src/accounts.ts","../../types/src/fuel.ts","../../types/src/constants.ts","../src/Fuel.ts","../src/FuelWalletConnection.ts","../src/utils/hasWindow.ts","../src/utils/promise.ts","../src/connections/BaseConnection.ts","../src/config.ts","../src/utils/createUUID.ts","../src/connections/WindowConnection.ts","../src/utils/getTransactionSigner.ts","../src/FuelWalletLocked.ts","../src/FuelWalletProvider.ts","../src/utils/blockExplorer.ts","../src/utils/createReadOnly.ts","../src/utils/createConnector.ts","../src/utils/provider.ts","../src/connections/ContentProxyConnection.ts","../src/connections/ExtensionPageConnection.ts"],"names":["AddressType","MessageTypes","Address","connectorName"],"mappings":"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","sourcesContent":["import type { BigNumberish, BN } from 'fuels';\n\nimport type { Coin } from './coin';\n\nexport type Vault = {\n  key: string;\n  data: string;\n};\n\nexport type Account = {\n  name: string;\n  address: string;\n  vaultId?: number;\n  publicKey: string;\n  isHidden?: boolean;\n  balance?: BigNumberish | BN;\n  balanceSymbol?: string;\n  balances?: Coin[];\n  isCurrent?: boolean;\n};\n\nexport enum AddressType {\n  contract,\n  account,\n}\n","import type {\n  ICreateChange,\n  IUpdateChange,\n  IDeleteChange,\n} from 'dexie-observable/api';\nimport type { JSONRPCRequest, JSONRPCResponse } from 'json-rpc-2.0';\n\nimport type { Asset } from './asset';\nimport type { Network } from './network';\n\nexport const FuelWalletEvents = {\n  accounts: 'accounts',\n  currentAccount: 'currentAccount',\n  connection: 'connection',\n  network: 'network',\n  assets: 'assets',\n  connectors: 'connectors',\n  currentConnector: 'currentConnector',\n  load: 'load',\n} as const;\n\nexport type FuelEvents =\n  | {\n      type: typeof FuelWalletEvents.accounts;\n      data: Array<string>;\n    }\n  | {\n      type: typeof FuelWalletEvents.currentAccount;\n      data: string | null;\n    }\n  | {\n      type: typeof FuelWalletEvents.connection;\n      data: boolean;\n    }\n  | {\n      type: typeof FuelWalletEvents.network;\n      data: Network;\n    }\n  | {\n      type: typeof FuelWalletEvents.assets;\n      data: Array<Asset>;\n    }\n  | {\n      type: typeof FuelWalletEvents.connectors;\n      data: Array<FuelWalletConnector>;\n    }\n  | {\n      type: typeof FuelWalletEvents.currentConnector;\n      data: FuelWalletConnector;\n    }\n  | {\n      type: typeof FuelWalletEvents.load;\n      data: boolean;\n    };\n\nexport type FuelEventArg<T extends FuelEvents['type']> = Extract<\n  FuelEvents,\n  { type: T }\n>['data'];\n\nexport enum MessageTypes {\n  ping = 'ping',\n  uiEvent = 'uiEvent',\n  event = 'event',\n  request = 'request',\n  response = 'response',\n  removeConnection = 'removeConnection',\n}\n\nexport type BaseEvent<T> = {\n  readonly target: string;\n  readonly connectorName?: string;\n  readonly id?: string;\n  readonly sender?: chrome.runtime.Port['sender'];\n} & T;\n\nexport type UIEventMessage = BaseEvent<{\n  readonly type: MessageTypes.uiEvent;\n  readonly ready: boolean;\n  readonly session: string;\n}>;\n\nexport type RequestMessage = BaseEvent<{\n  readonly type: MessageTypes.request;\n  readonly request: JSONRPCRequest;\n}>;\n\nexport type ResponseMessage = BaseEvent<{\n  readonly type: MessageTypes.response;\n  readonly response: JSONRPCResponse;\n}>;\n\nexport type EventMessageEvents = Array<{\n  event: string;\n  params: Array<unknown>;\n}>;\n\nexport type EventMessage<T = EventMessageEvents> = BaseEvent<{\n  readonly type: MessageTypes.event;\n  readonly events: T;\n}>;\n\nexport type CommunicationEventArg<T> = T extends MessageTypes.request\n  ? RequestMessage\n  : T extends MessageTypes.response\n  ? ResponseMessage\n  : T extends MessageTypes.uiEvent\n  ? UIEventMessage\n  : T extends MessageTypes.event\n  ? EventMessage\n  : T extends MessageTypes.removeConnection\n  ? string\n  : unknown;\n\nexport type CommunicationMessage =\n  | UIEventMessage\n  | RequestMessage\n  | ResponseMessage\n  | EventMessage;\n\nexport type DatabaseEvents = ['delete', 'create', 'update'];\nexport type DatabaseObservableEvent<T extends Array<string>> =\n  `${T[number]}:${DatabaseEvents[number]}`;\n\nexport type DatabaseEventArg<T extends string> = T extends `${string}:create`\n  ? ICreateChange\n  : T extends `${string}:update`\n  ? IUpdateChange\n  : T extends `${string}:delete`\n  ? IDeleteChange\n  : unknown;\n\nexport type FuelProviderConfig = {\n  id?: string;\n  url: string;\n};\n\nexport type FuelWalletConnector = {\n  name: string;\n  imageUrl?: string;\n};\n","export const CONTENT_SCRIPT_NAME = 'FuelContentScript';\nexport const BACKGROUND_SCRIPT_NAME = 'FuelBackgroundScript';\nexport const POPUP_SCRIPT_NAME = 'FuelPopUpScript';\nexport const VAULT_SCRIPT_NAME = 'FuelVaultScript';\nexport const EVENT_MESSAGE = 'message';\n","import { FuelWalletEvents } from '@fuel-wallet/types';\nimport { Address } from 'fuels';\nimport type { AbstractAddress } from 'fuels';\n\nimport { FuelWalletConnection } from './FuelWalletConnection';\nimport { FuelWalletLocked } from './FuelWalletLocked';\nimport { FuelWalletProvider } from './FuelWalletProvider';\n\n// Isolate the provider instance to prevent\n// developers from replacing the provider\n// instance with a new one\nconst FuelWeb3Privates: {\n  provider?: FuelWalletProvider;\n} = {};\n\nexport class Fuel extends FuelWalletConnection {\n  readonly utils = {\n    // TODO: remove createAddress once fuels-ts replace input\n    // class address with string. The warn message is to avoid\n    // developers to use this method.\n    createAddress: (address: string) => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Do not use this method! It will be removed in the next release.'\n      );\n      return Address.fromString(address);\n    },\n  };\n\n  // Externalize events names\n  readonly events = FuelWalletEvents;\n\n  async getProvider(): Promise<FuelWalletProvider> {\n    // TODO: This solution should be improved by issue #506\n    // by moving all connection throw events\n    const providerConfig = await this.network();\n    // Return the current provider instance if it exists\n    if (FuelWeb3Privates.provider) {\n      return FuelWeb3Privates.provider;\n    }\n    // Otherwise, create a new provider instance\n    // fetch the current network and connect the provider\n    const provider = await FuelWalletProvider.create(providerConfig.url, {\n      walletConnection: this,\n    });\n    FuelWeb3Privates.provider = provider;\n\n    // Listen for network changes and connect the provider\n    // selected network from the user\n    this.on(FuelWalletEvents.network, async (network) => {\n      FuelWeb3Privates.provider?.switchUrl(network.url);\n    });\n\n    return FuelWeb3Privates.provider;\n  }\n\n  async getWallet(\n    address: string | AbstractAddress\n  ): Promise<FuelWalletLocked> {\n    const provider = await this.getProvider();\n    return new FuelWalletLocked(address, provider);\n  }\n}\n\ninterface FuelDocumentEvents {\n  FuelLoaded: CustomEvent<Fuel>;\n}\ndeclare global {\n  interface Document {\n    addEventListener<K extends keyof FuelDocumentEvents>(\n      type: K,\n      listener: (this: Document, ev: FuelDocumentEvents[K]) => void\n    ): void;\n    dispatchEvent<K extends keyof FuelDocumentEvents>(\n      ev: FuelDocumentEvents[K]\n    ): void;\n  }\n  interface Window {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    fuel: Fuel | undefined;\n  }\n}\n","import type {\n  AbiMap,\n  Asset,\n  FuelEventArg,\n  FuelProviderConfig,\n  FuelEvents,\n  Network,\n} from '@fuel-wallet/types';\nimport type { JsonAbi, TransactionRequestLike } from 'fuels';\nimport { transactionRequestify } from 'fuels';\n\nimport { WindowConnection } from './connections/WindowConnection';\nimport { getTransactionSigner } from './utils/getTransactionSigner';\n\nexport class FuelWalletConnection extends WindowConnection {\n  async ping(): Promise<boolean> {\n    return this.client.timeout(1000).request('ping', {});\n  }\n\n  async isConnected(): Promise<boolean> {\n    // If the wallet not exists or not connected, return false\n    try {\n      return await this.client.request('isConnected', {});\n    } catch {\n      return false;\n    }\n  }\n\n  async connect(): Promise<boolean> {\n    return this.client.request('connect', {});\n  }\n\n  async disconnect(): Promise<boolean> {\n    return this.client.request('disconnect', {});\n  }\n\n  async accounts(): Promise<Array<string>> {\n    return this.client.request('accounts', {});\n  }\n\n  async currentAccount(): Promise<string> {\n    return this.client.request('currentAccount', {});\n  }\n\n  async signMessage(address: string, message: string): Promise<string> {\n    if (!message.trim()) {\n      throw new Error('Message is required');\n    }\n    return this.client.request('signMessage', {\n      address,\n      message,\n    });\n  }\n\n  async sendTransaction(\n    transaction: TransactionRequestLike & { signer?: string },\n    providerConfig: FuelProviderConfig,\n    signer?: string\n  ): Promise<string> {\n    if (!transaction) {\n      throw new Error('Transaction is required');\n    }\n    // Transform transaction object to a transaction request\n    const txRequest = transactionRequestify(transaction);\n\n    const address =\n      signer || transaction.signer || getTransactionSigner(txRequest);\n\n    return this.client.request('sendTransaction', {\n      address,\n      provider: providerConfig,\n      transaction: JSON.stringify(txRequest),\n    });\n  }\n\n  async assets(): Promise<Array<Asset>> {\n    return this.client.request('assets', {});\n  }\n\n  async addAsset(asset: Asset): Promise<boolean> {\n    return this.addAssets([asset]);\n  }\n\n  async addAssets(assets: Asset[]): Promise<boolean> {\n    return this.client.request('addAssets', {\n      assets,\n    });\n  }\n\n  async addAbi(abiMap: AbiMap): Promise<boolean> {\n    return this.client.request('addAbi', {\n      abiMap,\n    });\n  }\n\n  async getAbi(contractId: string): Promise<JsonAbi> {\n    return this.client.request('getAbi', {\n      contractId,\n    });\n  }\n\n  async hasAbi(contractId: string): Promise<boolean> {\n    const abi = await this.getAbi(contractId);\n    return !!abi;\n  }\n\n  async network(): Promise<FuelProviderConfig> {\n    return this.client.request('network', {});\n  }\n\n  async networks(): Promise<FuelProviderConfig[]> {\n    return this.client.request('networks', {});\n  }\n\n  async addNetwork(network: Network): Promise<boolean> {\n    return this.client.request('addNetwork', { network });\n  }\n\n  async version(): Promise<string> {\n    return this.client.request('version', {});\n  }\n\n  on<E extends FuelEvents['type'], D extends FuelEventArg<E>>(\n    eventName: E,\n    listener: (data: D) => void\n  ): this {\n    return super.on(eventName, listener);\n  }\n}\n","export const hasWindow = typeof window !== 'undefined';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type DeferPromise<R = unknown> = {\n  promise: Promise<R>;\n  resolve: (value: R) => void;\n  reject: (error: unknown) => void;\n};\n\nexport function deferPromise<R = unknown>() {\n  const defer: DeferPromise<R> = {} as any;\n\n  defer.promise = new Promise((resolve, reject) => {\n    defer.reject = reject;\n    defer.resolve = resolve;\n  });\n\n  return defer;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type {\n  CommunicationMessage,\n  EventMessage,\n  RequestMessage,\n  ResponseMessage,\n  UIEventMessage,\n} from '@fuel-wallet/types';\nimport { MessageTypes } from '@fuel-wallet/types';\nimport EventEmitter from 'events';\nimport type { JSONRPCRequest, JSONRPCResponse } from 'json-rpc-2.0';\nimport { JSONRPCServer, JSONRPCClient } from 'json-rpc-2.0';\n\nimport { MAX_EVENT_LISTENERS } from '../config';\nimport { createUUID } from '../utils/createUUID';\n\nexport class BaseConnection extends EventEmitter {\n  readonly client: JSONRPCClient;\n  readonly server: JSONRPCServer;\n\n  constructor() {\n    super();\n    this.setMaxListeners(MAX_EVENT_LISTENERS);\n    this.client = new JSONRPCClient(\n      this.sendRequest.bind(this),\n      this.createRequestId\n    );\n    this.server = new JSONRPCServer();\n  }\n\n  createRequestId(): string {\n    return createUUID();\n  }\n\n  externalMethods(methods: Array<string | any>) {\n    methods.forEach((method) => {\n      let methodName = method;\n      if (method.name) {\n        methodName = method.name;\n      }\n      this.server.addMethod(methodName, this[methodName].bind(this) as any);\n    });\n  }\n\n  async sendRequest(request: JSONRPCRequest | null): Promise<void> {\n    throw new Error('Send request not implemented');\n  }\n\n  sendResponse(\n    response: JSONRPCResponse | null,\n    message: RequestMessage\n  ): void {\n    throw new Error('Send response not implemented');\n  }\n\n  onCommunicationMessage = (message: CommunicationMessage) => {\n    switch (message.type) {\n      case MessageTypes.response:\n        this.onResponse(message);\n        break;\n      case MessageTypes.request:\n        this.onRequest(message);\n        break;\n      case MessageTypes.event:\n        this.onEvent(message);\n        break;\n      case MessageTypes.uiEvent:\n        this.onUIEvent(message);\n        break;\n      default:\n    }\n  };\n\n  onEvent(message: EventMessage): void {\n    message.events.forEach((eventData) => {\n      this.emit(eventData.event, ...eventData.params);\n    });\n  }\n\n  onResponse(message: ResponseMessage): void {\n    this.client.receive(message.response);\n  }\n\n  onRequest(message: RequestMessage): void {\n    this.server.receive(message.request).then((response) => {\n      this.sendResponse(response, message);\n    });\n  }\n\n  onUIEvent(message: UIEventMessage): void {}\n}\n","export const MAX_EVENT_LISTENERS = 30;\nexport const PING_TIMEOUT = 1000;\nexport const RECONNECT_TIMEOUT = 300;\n","import { v4 } from 'uuid';\n\nexport function createUUID() {\n  return v4();\n}\n","import {\n  CONTENT_SCRIPT_NAME,\n  EVENT_MESSAGE,\n  FuelWalletEvents,\n  MessageTypes,\n} from '@fuel-wallet/types';\nimport type {\n  CommunicationMessage,\n  FuelWalletConnector,\n} from '@fuel-wallet/types';\nimport type { JSONRPCRequest } from 'json-rpc-2.0';\n\nimport { hasWindow } from '../utils/hasWindow';\nimport { deferPromise } from '../utils/promise';\n\nimport { BaseConnection } from './BaseConnection';\n\nexport class WindowConnection extends BaseConnection {\n  isListenerAdded = false;\n  queue: JSONRPCRequest[] = [];\n  _retry = 0;\n  _injectionTimeout: NodeJS.Timeout;\n  _hasWallet = deferPromise<boolean>();\n  connectorName: string;\n  private connectors: Array<FuelWalletConnector>;\n\n  constructor(connector?: FuelWalletConnector) {\n    super();\n    this.connectorName = connector ? connector.name : '';\n    this.connectors = connector ? [connector] : [];\n    this.handleFuelInjected();\n    this._injectionTimeout = setInterval(\n      this.handleFuelInjected.bind(this),\n      100\n    );\n    this.handleIsReady();\n  }\n\n  executeQueuedRequests() {\n    // Execute pending requests in the queue\n    let request = this.queue.shift();\n    while (request) {\n      this.sendRequest(request);\n      request = this.queue.shift();\n    }\n  }\n\n  handleIsReady() {\n    if (typeof document === 'undefined') return;\n    document.addEventListener('FuelLoaded', () => {\n      this._retry = 0;\n      this._hasWallet.resolve(true);\n      this._hasWallet = deferPromise<boolean>();\n      this.handleFuelInjected();\n      this.emit(FuelWalletEvents.load, true);\n    });\n  }\n\n  hasConnector(connectorName: string): boolean {\n    return !!this.connectors.find((c) => c.name === connectorName);\n  }\n\n  addConnector(connector: FuelWalletConnector): void {\n    // Ensure Fuel Wallet is the default connector\n    if (connector.name === 'Fuel Wallet') {\n      this.connectorName = connector.name;\n    }\n    if (this.hasConnector(connector.name)) {\n      throw new Error(`\"${connector.name}\" connector already exists!`);\n    }\n    this.connectors.push(connector);\n    this.emit(FuelWalletEvents.connectors, this.listConnectors());\n  }\n\n  removeConnector(connectorName: string): void {\n    const connectorIndex = this.connectors.findIndex(\n      (c) => c.name === connectorName\n    );\n    if (connectorIndex > -1) {\n      this.connectors.splice(connectorIndex, 1);\n    }\n  }\n\n  listConnectors(): Array<FuelWalletConnector> {\n    return this.connectors;\n  }\n\n  async selectConnector(connectorName: string): Promise<boolean> {\n    const previousConnector = this.connectorName;\n    this.connectorName = connectorName;\n    try {\n      const connectorName = await this.client\n        .timeout(1000)\n        .request('connectorName', {});\n      // Check if the current connector is in the list of connectors\n      let connector = this.connectors.find((c) => c.name === connectorName);\n      // If not, add it to the list of connectors\n      if (!connector) {\n        connector = { name: connectorName };\n        this.addConnector({ name: connectorName });\n      }\n      // Emit the current connector\n      this.emit(FuelWalletEvents.currentConnector, connector);\n    } catch {\n      // If the connector is not found, revert the change and throw an error\n      this.connectorName = previousConnector;\n      throw new Error(`\"${connectorName}\" connector not found!`);\n    }\n    return true;\n  }\n\n  acceptMessage(message: MessageEvent<CommunicationMessage>): boolean {\n    const { data: event } = message;\n    return (\n      message.origin === window.origin &&\n      event.target === this.connectorName &&\n      event.type !== MessageTypes.request\n    );\n  }\n\n  async hasWallet(): Promise<boolean> {\n    return this._hasWallet.promise;\n  }\n\n  async sendRequest(request: JSONRPCRequest | null) {\n    if (!request) return;\n\n    if (!window.fuel) {\n      this.queue.push(request);\n    } else {\n      this.postMessage({\n        type: MessageTypes.request,\n        target: CONTENT_SCRIPT_NAME,\n        connectorName: this.connectorName,\n        request,\n      });\n    }\n  }\n\n  onMessage = (message: MessageEvent<CommunicationMessage>) => {\n    const messageFroze = Object.freeze(message);\n    if (!this.acceptMessage(messageFroze)) return;\n    const { data: event } = messageFroze;\n    this.onCommunicationMessage(event);\n  };\n\n  postMessage(message: CommunicationMessage, origin?: string) {\n    if (!this.hasConnector(this.connectorName)) {\n      throw new Error(`Wallet Connector ${this.connectorName} not found!`);\n    }\n    window.postMessage(message, origin || window.origin);\n  }\n\n  bindFuelConnectors(fuel: Window['fuel']) {\n    // Prevent binding to self if this happen the\n    // object would enter on a infinite loop\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isSelf = (fuel as any) === this;\n    if (!fuel || isSelf) return;\n    // Bind to fuel events to\n    // sync with current instace\n    fuel.on(FuelWalletEvents.connectors, (connectors) => {\n      this.connectors = connectors;\n      this.emit(FuelWalletEvents.connectors, connectors);\n    });\n    fuel.on(FuelWalletEvents.currentConnector, (connector) => {\n      this.selectConnector(connector.name);\n    });\n    // Update the current connectors list\n    this.connectors = fuel.listConnectors();\n    // Trigger connectros list changed event\n    this.emit(FuelWalletEvents.connectors, this.listConnectors());\n    // Sync the current connector\n    this.selectConnector(fuel.connectorName);\n  }\n\n  handleFuelInjected() {\n    // Timeout after 10 retries i.e., 1 second\n    if (this._retry === 9) {\n      clearInterval(this._injectionTimeout);\n      this._hasWallet.resolve(false);\n      this.client.rejectAllPendingRequests(\n        'Timeout fuel not detected on the window!'\n      );\n      return;\n    }\n\n    this._retry++;\n\n    if (hasWindow) {\n      if (!this.isListenerAdded) {\n        window.addEventListener(EVENT_MESSAGE, this.onMessage.bind(this));\n        this.isListenerAdded = true;\n      }\n      if (window.fuel) {\n        clearInterval(this._injectionTimeout);\n        this._hasWallet.resolve(true);\n        this.bindFuelConnectors(window.fuel);\n        this.executeQueuedRequests();\n      }\n    }\n  }\n}\n","import type { TransactionRequestLike } from 'fuels';\nimport { hexlify, Address, InputType } from 'fuels';\n\nexport function getTransactionSigner(transaction: TransactionRequestLike) {\n  const address = transaction.inputs?.map((i) => {\n    switch (i.type) {\n      case InputType.Message:\n        return i.recipient;\n      case InputType.Coin:\n        return i.owner;\n      default:\n        return undefined;\n    }\n  })[0];\n\n  if (!address) {\n    throw new Error('No possible signer found!');\n  }\n\n  return Address.fromB256(hexlify(address)).toString();\n}\n","import type {\n  AbstractAddress,\n  TransactionRequestLike,\n  TransactionResponse,\n} from 'fuels';\nimport { WalletLocked } from 'fuels';\n\nimport type { FuelWalletProvider } from './FuelWalletProvider';\n\nexport class FuelWalletLocked extends WalletLocked {\n  provider: FuelWalletProvider;\n\n  constructor(address: string | AbstractAddress, provider: FuelWalletProvider) {\n    super(address, provider);\n    this.provider = provider;\n  }\n\n  async signMessage(message: string): Promise<string> {\n    return this.provider.walletConnection.signMessage(\n      this.address.toString(),\n      message\n    );\n  }\n\n  async sendTransaction(\n    transaction: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    return this.provider.sendTransaction({\n      ...transaction,\n      signer: this.address.toString(),\n    });\n  }\n}\n","import type { ProviderOptions, TransactionRequestLike } from 'fuels';\nimport { TransactionResponse, Provider } from 'fuels';\n\nimport type { FuelWalletConnection } from './FuelWalletConnection';\n\ntype FuelWalletProviderOptions = ProviderOptions & {\n  walletConnection: FuelWalletConnection;\n};\n\nexport class FuelWalletProvider extends Provider {\n  walletConnection: FuelWalletConnection;\n\n  constructor(url: string, options: FuelWalletProviderOptions) {\n    super(url, options);\n    this.walletConnection = options.walletConnection;\n  }\n\n  static async create(\n    url: string,\n    options: FuelWalletProviderOptions\n  ): Promise<FuelWalletProvider> {\n    const provider = new FuelWalletProvider(url, options);\n    await provider.fetchChainAndNodeInfo();\n    return provider;\n  }\n\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike & { signer?: string }\n  ): Promise<TransactionResponse> {\n    const transactionId = await this.walletConnection.sendTransaction(\n      transactionRequestLike,\n      { url: this.url }\n    );\n    const response = new TransactionResponse(transactionId, this);\n    return response;\n  }\n}\n","export const BLOCK_EXPLORER_URL =\n  'https://fuellabs.github.io/block-explorer-v2/';\n\nexport function getBlockExplorerLink({\n  path,\n  providerUrl,\n}: {\n  path: string;\n  providerUrl?: string;\n}) {\n  return `${BLOCK_EXPLORER_URL}${path}${\n    providerUrl ? `?providerUrl=${encodeURIComponent(providerUrl)}` : ''\n  }`;\n}\n","import type { Fuel } from '../Fuel';\n\nexport const createReadOnly = (fuel: Fuel) => {\n  return new Proxy(fuel, {\n    get(target, prop) {\n      return target[prop];\n    },\n    set(target, key, value) {\n      // Avoid change keys of Fuel, except _eventsCount and _events\n      // This keys are constantly updated by the EventEmitter witch Fuel\n      // extends from.\n      if (\n        Object.hasOwn(target, key) &&\n        ['_eventsCount', '_events', 'connectorName'].includes(key as string)\n      ) {\n        target[key] = value;\n        return true;\n      }\n      return false;\n    },\n    defineProperty(target, key) {\n      if (Object.hasOwn(target, key)) return target[key];\n      return false;\n    },\n    deleteProperty() {\n      return false;\n    },\n  });\n};\n","import type { FuelWalletConnector } from '@fuel-wallet/types';\n\nimport { Fuel } from '../Fuel';\n\nimport { createReadOnly } from './createReadOnly';\n\ntype ObjectTarget = object & { fuel?: Fuel };\n\nfunction injectFuel(fuel: Fuel, target: object & { fuel?: Fuel }) {\n  const fuelObj = createReadOnly(fuel);\n  Object.defineProperty(target, 'fuel', {\n    value: fuel,\n    writable: false,\n    enumerable: true,\n    configurable: true,\n  });\n\n  if (typeof document !== 'undefined') {\n    // Dispatch event fuel loaded into the document\n    const fuelLoadedEvent = new CustomEvent('FuelLoaded', {\n      detail: fuelObj,\n    });\n    document.dispatchEvent(fuelLoadedEvent);\n  }\n}\n\nexport function createConnector(\n  connector: FuelWalletConnector,\n  target: ObjectTarget = window as ObjectTarget\n) {\n  if (target?.fuel) {\n    target.fuel.addConnector(connector);\n    return;\n  }\n  injectFuel(new Fuel(connector), target);\n}\n","import type { Provider } from 'fuels';\n\nexport const getGasConfig = async (provider: Provider) => {\n  const chain = await provider.getChain();\n  const nodeInfo = await provider.fetchNode();\n\n  return {\n    gasLimit: chain.consensusParameters.maxGasPerTx,\n    gasPrice: nodeInfo.minGasPrice,\n  };\n};\n","/* eslint-disable no-console */\nimport {\n  BACKGROUND_SCRIPT_NAME,\n  CONTENT_SCRIPT_NAME,\n  EVENT_MESSAGE,\n  MessageTypes,\n} from '@fuel-wallet/types';\nimport type { CommunicationMessage } from '@fuel-wallet/types';\nimport { createJSONRPCSuccessResponse } from 'json-rpc-2.0';\nimport type { JSONRPCID } from 'json-rpc-2.0';\n\nimport { PING_TIMEOUT, RECONNECT_TIMEOUT } from '../config';\n\nexport class ContentProxyConnection {\n  connection: chrome.runtime.Port;\n  _tryReconect?: NodeJS.Timeout;\n  _keepAlive?: NodeJS.Timeout;\n  readonly connectorName: string;\n\n  constructor(connectorName: string) {\n    this.connection = this.connect();\n    this.connectorName = connectorName;\n    window.addEventListener(EVENT_MESSAGE, this.onMessageFromWindow);\n    this.keepAlive();\n  }\n\n  connect() {\n    const connection = chrome.runtime.connect(chrome.runtime.id, {\n      name: BACKGROUND_SCRIPT_NAME,\n    });\n    connection.onMessage.addListener(this.onMessageFromExtension);\n    connection.onDisconnect.addListener(this.onDisconnect);\n    return connection;\n  }\n\n  destroy() {\n    this.connection.disconnect();\n    clearInterval(this._tryReconect);\n    clearTimeout(this._keepAlive);\n  }\n\n  onDisconnect = () => {\n    clearInterval(this._tryReconect);\n    this._tryReconect = setInterval(() => {\n      console.debug('[FUEL WALLET] reconnecting!');\n      try {\n        this.connection = this.connect();\n        console.debug('[FUEL WALLET] reconnected!');\n        clearInterval(this._tryReconect);\n        // If fails it will try to reconnect\n        // It should not throw an error to avoid\n        // uncessary error reporting as it is expected\n        // to fail if background script is not available.\n      } catch (err: unknown) {\n        if ((err as Error).message === 'Extension context invalidated.') {\n          clearInterval(this._tryReconect);\n          console.debug('[FUEL WALLET] context invalidated!');\n        }\n      }\n    }, RECONNECT_TIMEOUT);\n  };\n\n  keepAlive = () => {\n    // Send ping message to background script\n    // If background script is not available,\n    // it will throw an error and we will try to reconnect.\n    try {\n      this.connection.postMessage({\n        target: BACKGROUND_SCRIPT_NAME,\n        type: MessageTypes.ping,\n      });\n      this._keepAlive = setTimeout(this.keepAlive, PING_TIMEOUT);\n    } catch (err) {\n      this.onDisconnect();\n    }\n  };\n\n  static start(providerWallet: string) {\n    return new ContentProxyConnection(providerWallet);\n  }\n\n  onMessageFromExtension = (message: CommunicationMessage) => {\n    const shouldAcceptMessage = message.target === CONTENT_SCRIPT_NAME;\n    if (shouldAcceptMessage) {\n      this.postMessage(message);\n    }\n  };\n\n  shouldAcceptMessage(event: CommunicationMessage, origin: string) {\n    return (\n      origin === window.location.origin &&\n      event.target === CONTENT_SCRIPT_NAME &&\n      event.connectorName === this.connectorName\n    );\n  }\n\n  sendConnectorName(id: JSONRPCID) {\n    this.postMessage({\n      type: MessageTypes.response,\n      response: createJSONRPCSuccessResponse(id, this.connectorName),\n      target: this.connectorName,\n    });\n  }\n\n  onMessageFromWindow = (message: MessageEvent<CommunicationMessage>) => {\n    const { data: event, origin } = Object.freeze(message);\n    if (this.shouldAcceptMessage(event, origin)) {\n      if (\n        event.type === MessageTypes.request &&\n        event.request.method === 'connectorName'\n      ) {\n        // If the message is a request for the connector name\n        // we send it back to the sender without send to the background script.\n        this.sendConnectorName(event.request.id!);\n      } else {\n        // Otherwise we send the message to the background script\n        this.connection.postMessage({\n          ...event,\n          target: BACKGROUND_SCRIPT_NAME,\n        });\n      }\n    }\n  };\n\n  postMessage(message: CommunicationMessage) {\n    const postMessage = {\n      ...message,\n      target: this.connectorName,\n    };\n    window.postMessage(postMessage, window.location.origin);\n  }\n}\n","import type {\n  CommunicationMessage,\n  RequestMessage,\n  ResponseMessage,\n} from '@fuel-wallet/types';\nimport {\n  BACKGROUND_SCRIPT_NAME,\n  POPUP_SCRIPT_NAME,\n  MessageTypes,\n} from '@fuel-wallet/types';\nimport type { JSONRPCResponse } from 'json-rpc-2.0';\n\nimport { BaseConnection } from './BaseConnection';\n\nexport class ExtensionPageConnection extends BaseConnection {\n  readonly connection: chrome.runtime.Port;\n\n  constructor() {\n    super();\n    this.connection = chrome.runtime.connect(chrome.runtime.id, {\n      name: BACKGROUND_SCRIPT_NAME,\n    });\n    this.connection.onMessage.addListener(this.onCommunicationMessage);\n    this.ready();\n  }\n\n  allowMessage(message: CommunicationMessage): boolean {\n    return message.target === POPUP_SCRIPT_NAME;\n  }\n\n  sendResponse(response: JSONRPCResponse | null, message: RequestMessage) {\n    if (!response) return;\n    const responseMessage: ResponseMessage = {\n      id: message.id,\n      target: BACKGROUND_SCRIPT_NAME,\n      type: MessageTypes.response,\n      response,\n    };\n    this.connection.postMessage(responseMessage);\n    this.onResponseSent();\n  }\n\n  onResponseSent() {\n    window.close();\n  }\n\n  ready() {\n    // Get session from query params\n    const session = new URLSearchParams(window.location.search).get('s');\n    this.connection.postMessage({\n      target: BACKGROUND_SCRIPT_NAME,\n      type: MessageTypes.uiEvent,\n      ready: true,\n      session,\n    });\n  }\n\n  destroy() {\n    this.connection.disconnect();\n  }\n}\n"]}