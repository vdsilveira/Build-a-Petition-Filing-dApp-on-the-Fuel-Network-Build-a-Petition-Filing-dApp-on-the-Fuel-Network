import { RequestMessage, CommunicationMessage, EventMessage, ResponseMessage, UIEventMessage, FuelWalletConnector, FuelProviderConfig, Asset, AbiMap, Network, FuelEvents, FuelEventArg } from '@fuel-wallet/types';
export * from '@fuel-wallet/types';
import * as fuels from 'fuels';
import { TransactionRequestLike, JsonAbi, Provider, TransactionResponse, ProviderOptions, WalletLocked, AbstractAddress, Address } from 'fuels';
import { JSONRPCClient, JSONRPCServer, JSONRPCRequest, JSONRPCResponse, JSONRPCID } from 'json-rpc-2.0';
import EventEmitter from 'events';

type DeferPromise<R = unknown> = {
    promise: Promise<R>;
    resolve: (value: R) => void;
    reject: (error: unknown) => void;
};
declare function deferPromise<R = unknown>(): DeferPromise<R>;

declare class BaseConnection extends EventEmitter {
    readonly client: JSONRPCClient;
    readonly server: JSONRPCServer;
    constructor();
    createRequestId(): string;
    externalMethods(methods: Array<string | any>): void;
    sendRequest(request: JSONRPCRequest | null): Promise<void>;
    sendResponse(response: JSONRPCResponse | null, message: RequestMessage): void;
    onCommunicationMessage: (message: CommunicationMessage) => void;
    onEvent(message: EventMessage): void;
    onResponse(message: ResponseMessage): void;
    onRequest(message: RequestMessage): void;
    onUIEvent(message: UIEventMessage): void;
}

declare class WindowConnection extends BaseConnection {
    isListenerAdded: boolean;
    queue: JSONRPCRequest[];
    _retry: number;
    _injectionTimeout: NodeJS.Timeout;
    _hasWallet: DeferPromise<boolean>;
    connectorName: string;
    private connectors;
    constructor(connector?: FuelWalletConnector);
    executeQueuedRequests(): void;
    handleIsReady(): void;
    hasConnector(connectorName: string): boolean;
    addConnector(connector: FuelWalletConnector): void;
    removeConnector(connectorName: string): void;
    listConnectors(): Array<FuelWalletConnector>;
    selectConnector(connectorName: string): Promise<boolean>;
    acceptMessage(message: MessageEvent<CommunicationMessage>): boolean;
    hasWallet(): Promise<boolean>;
    sendRequest(request: JSONRPCRequest | null): Promise<void>;
    onMessage: (message: MessageEvent<CommunicationMessage>) => void;
    postMessage(message: CommunicationMessage, origin?: string): void;
    bindFuelConnectors(fuel: Window['fuel']): void;
    handleFuelInjected(): void;
}

declare class FuelWalletConnection extends WindowConnection {
    ping(): Promise<boolean>;
    isConnected(): Promise<boolean>;
    connect(): Promise<boolean>;
    disconnect(): Promise<boolean>;
    accounts(): Promise<Array<string>>;
    currentAccount(): Promise<string>;
    signMessage(address: string, message: string): Promise<string>;
    sendTransaction(transaction: TransactionRequestLike & {
        signer?: string;
    }, providerConfig: FuelProviderConfig, signer?: string): Promise<string>;
    assets(): Promise<Array<Asset>>;
    addAsset(asset: Asset): Promise<boolean>;
    addAssets(assets: Asset[]): Promise<boolean>;
    addAbi(abiMap: AbiMap): Promise<boolean>;
    getAbi(contractId: string): Promise<JsonAbi>;
    hasAbi(contractId: string): Promise<boolean>;
    network(): Promise<FuelProviderConfig>;
    networks(): Promise<FuelProviderConfig[]>;
    addNetwork(network: Network): Promise<boolean>;
    version(): Promise<string>;
    on<E extends FuelEvents['type'], D extends FuelEventArg<E>>(eventName: E, listener: (data: D) => void): this;
}

type FuelWalletProviderOptions = ProviderOptions & {
    walletConnection: FuelWalletConnection;
};
declare class FuelWalletProvider extends Provider {
    walletConnection: FuelWalletConnection;
    constructor(url: string, options: FuelWalletProviderOptions);
    static create(url: string, options: FuelWalletProviderOptions): Promise<FuelWalletProvider>;
    sendTransaction(transactionRequestLike: TransactionRequestLike & {
        signer?: string;
    }): Promise<TransactionResponse>;
}

declare class FuelWalletLocked extends WalletLocked {
    provider: FuelWalletProvider;
    constructor(address: string | AbstractAddress, provider: FuelWalletProvider);
    signMessage(message: string): Promise<string>;
    sendTransaction(transaction: TransactionRequestLike): Promise<TransactionResponse>;
}

declare class Fuel extends FuelWalletConnection {
    readonly utils: {
        createAddress: (address: string) => Address;
    };
    readonly events: {
        readonly accounts: "accounts";
        readonly currentAccount: "currentAccount";
        readonly connection: "connection";
        readonly network: "network";
        readonly assets: "assets";
        readonly connectors: "connectors";
        readonly currentConnector: "currentConnector";
        readonly load: "load";
    };
    getProvider(): Promise<FuelWalletProvider>;
    getWallet(address: string | AbstractAddress): Promise<FuelWalletLocked>;
}
interface FuelDocumentEvents {
    FuelLoaded: CustomEvent<Fuel>;
}
declare global {
    interface Document {
        addEventListener<K extends keyof FuelDocumentEvents>(type: K, listener: (this: Document, ev: FuelDocumentEvents[K]) => void): void;
        dispatchEvent<K extends keyof FuelDocumentEvents>(ev: FuelDocumentEvents[K]): void;
    }
    interface Window {
        fuel: Fuel | undefined;
    }
}

declare const BLOCK_EXPLORER_URL = "https://fuellabs.github.io/block-explorer-v2/";
declare function getBlockExplorerLink({ path, providerUrl, }: {
    path: string;
    providerUrl?: string;
}): string;

declare const createReadOnly: (fuel: Fuel) => Fuel;

declare function createUUID(): string;

declare function getTransactionSigner(transaction: TransactionRequestLike): string;

type ObjectTarget = object & {
    fuel?: Fuel;
};
declare function createConnector(connector: FuelWalletConnector, target?: ObjectTarget): void;

declare const hasWindow: boolean;

declare const getGasConfig: (provider: Provider) => Promise<{
    gasLimit: fuels.BN;
    gasPrice: fuels.BN;
}>;

declare class ContentProxyConnection {
    connection: chrome.runtime.Port;
    _tryReconect?: NodeJS.Timeout;
    _keepAlive?: NodeJS.Timeout;
    readonly connectorName: string;
    constructor(connectorName: string);
    connect(): chrome.runtime.Port;
    destroy(): void;
    onDisconnect: () => void;
    keepAlive: () => void;
    static start(providerWallet: string): ContentProxyConnection;
    onMessageFromExtension: (message: CommunicationMessage) => void;
    shouldAcceptMessage(event: CommunicationMessage, origin: string): boolean;
    sendConnectorName(id: JSONRPCID): void;
    onMessageFromWindow: (message: MessageEvent<CommunicationMessage>) => void;
    postMessage(message: CommunicationMessage): void;
}

declare class ExtensionPageConnection extends BaseConnection {
    readonly connection: chrome.runtime.Port;
    constructor();
    allowMessage(message: CommunicationMessage): boolean;
    sendResponse(response: JSONRPCResponse | null, message: RequestMessage): void;
    onResponseSent(): void;
    ready(): void;
    destroy(): void;
}

export { BLOCK_EXPLORER_URL, BaseConnection, ContentProxyConnection, DeferPromise, ExtensionPageConnection, Fuel, FuelWalletConnection, FuelWalletLocked, FuelWalletProvider, WindowConnection, createConnector, createReadOnly, createUUID, deferPromise, getBlockExplorerLink, getGasConfig, getTransactionSigner, hasWindow };
