'use strict';

var fuels = require('fuels');
var EventEmitter = require('events');
var jsonRpc2_0 = require('json-rpc-2.0');
var uuid = require('uuid');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var EventEmitter__default = /*#__PURE__*/_interopDefault(EventEmitter);

// ../types/src/accounts.ts
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2[AddressType2["contract"] = 0] = "contract";
  AddressType2[AddressType2["account"] = 1] = "account";
  return AddressType2;
})(AddressType || {});

// ../types/src/fuel.ts
var FuelWalletEvents = {
  accounts: "accounts",
  currentAccount: "currentAccount",
  connection: "connection",
  network: "network",
  assets: "assets",
  connectors: "connectors",
  currentConnector: "currentConnector",
  load: "load"
};
var MessageTypes = /* @__PURE__ */ ((MessageTypes2) => {
  MessageTypes2["ping"] = "ping";
  MessageTypes2["uiEvent"] = "uiEvent";
  MessageTypes2["event"] = "event";
  MessageTypes2["request"] = "request";
  MessageTypes2["response"] = "response";
  MessageTypes2["removeConnection"] = "removeConnection";
  return MessageTypes2;
})(MessageTypes || {});

// ../types/src/constants.ts
var CONTENT_SCRIPT_NAME = "FuelContentScript";
var BACKGROUND_SCRIPT_NAME = "FuelBackgroundScript";
var POPUP_SCRIPT_NAME = "FuelPopUpScript";
var VAULT_SCRIPT_NAME = "FuelVaultScript";
var EVENT_MESSAGE = "message";

// src/utils/hasWindow.ts
var hasWindow = typeof window !== "undefined";

// src/utils/promise.ts
function deferPromise() {
  const defer = {};
  defer.promise = new Promise((resolve, reject) => {
    defer.reject = reject;
    defer.resolve = resolve;
  });
  return defer;
}

// src/config.ts
var MAX_EVENT_LISTENERS = 30;
var PING_TIMEOUT = 1e3;
var RECONNECT_TIMEOUT = 300;
function createUUID() {
  return uuid.v4();
}

// src/connections/BaseConnection.ts
var BaseConnection = class extends EventEmitter__default.default {
  constructor() {
    super();
    this.onCommunicationMessage = (message) => {
      switch (message.type) {
        case "response" /* response */:
          this.onResponse(message);
          break;
        case "request" /* request */:
          this.onRequest(message);
          break;
        case "event" /* event */:
          this.onEvent(message);
          break;
        case "uiEvent" /* uiEvent */:
          this.onUIEvent(message);
          break;
      }
    };
    this.setMaxListeners(MAX_EVENT_LISTENERS);
    this.client = new jsonRpc2_0.JSONRPCClient(
      this.sendRequest.bind(this),
      this.createRequestId
    );
    this.server = new jsonRpc2_0.JSONRPCServer();
  }
  createRequestId() {
    return createUUID();
  }
  externalMethods(methods) {
    methods.forEach((method) => {
      let methodName = method;
      if (method.name) {
        methodName = method.name;
      }
      this.server.addMethod(methodName, this[methodName].bind(this));
    });
  }
  async sendRequest(request) {
    throw new Error("Send request not implemented");
  }
  sendResponse(response, message) {
    throw new Error("Send response not implemented");
  }
  onEvent(message) {
    message.events.forEach((eventData) => {
      this.emit(eventData.event, ...eventData.params);
    });
  }
  onResponse(message) {
    this.client.receive(message.response);
  }
  onRequest(message) {
    this.server.receive(message.request).then((response) => {
      this.sendResponse(response, message);
    });
  }
  onUIEvent(message) {
  }
};

// src/connections/WindowConnection.ts
var WindowConnection = class extends BaseConnection {
  constructor(connector) {
    super();
    this.isListenerAdded = false;
    this.queue = [];
    this._retry = 0;
    this._hasWallet = deferPromise();
    this.onMessage = (message) => {
      const messageFroze = Object.freeze(message);
      if (!this.acceptMessage(messageFroze))
        return;
      const { data: event } = messageFroze;
      this.onCommunicationMessage(event);
    };
    this.connectorName = connector ? connector.name : "";
    this.connectors = connector ? [connector] : [];
    this.handleFuelInjected();
    this._injectionTimeout = setInterval(
      this.handleFuelInjected.bind(this),
      100
    );
    this.handleIsReady();
  }
  executeQueuedRequests() {
    let request = this.queue.shift();
    while (request) {
      this.sendRequest(request);
      request = this.queue.shift();
    }
  }
  handleIsReady() {
    if (typeof document === "undefined")
      return;
    document.addEventListener("FuelLoaded", () => {
      this._retry = 0;
      this._hasWallet.resolve(true);
      this._hasWallet = deferPromise();
      this.handleFuelInjected();
      this.emit(FuelWalletEvents.load, true);
    });
  }
  hasConnector(connectorName) {
    return !!this.connectors.find((c) => c.name === connectorName);
  }
  addConnector(connector) {
    if (connector.name === "Fuel Wallet") {
      this.connectorName = connector.name;
    }
    if (this.hasConnector(connector.name)) {
      throw new Error(`"${connector.name}" connector already exists!`);
    }
    this.connectors.push(connector);
    this.emit(FuelWalletEvents.connectors, this.listConnectors());
  }
  removeConnector(connectorName) {
    const connectorIndex = this.connectors.findIndex(
      (c) => c.name === connectorName
    );
    if (connectorIndex > -1) {
      this.connectors.splice(connectorIndex, 1);
    }
  }
  listConnectors() {
    return this.connectors;
  }
  async selectConnector(connectorName) {
    const previousConnector = this.connectorName;
    this.connectorName = connectorName;
    try {
      const connectorName2 = await this.client.timeout(1e3).request("connectorName", {});
      let connector = this.connectors.find((c) => c.name === connectorName2);
      if (!connector) {
        connector = { name: connectorName2 };
        this.addConnector({ name: connectorName2 });
      }
      this.emit(FuelWalletEvents.currentConnector, connector);
    } catch {
      this.connectorName = previousConnector;
      throw new Error(`"${connectorName}" connector not found!`);
    }
    return true;
  }
  acceptMessage(message) {
    const { data: event } = message;
    return message.origin === window.origin && event.target === this.connectorName && event.type !== "request" /* request */;
  }
  async hasWallet() {
    return this._hasWallet.promise;
  }
  async sendRequest(request) {
    if (!request)
      return;
    if (!window.fuel) {
      this.queue.push(request);
    } else {
      this.postMessage({
        type: "request" /* request */,
        target: CONTENT_SCRIPT_NAME,
        connectorName: this.connectorName,
        request
      });
    }
  }
  postMessage(message, origin) {
    if (!this.hasConnector(this.connectorName)) {
      throw new Error(`Wallet Connector ${this.connectorName} not found!`);
    }
    window.postMessage(message, origin || window.origin);
  }
  bindFuelConnectors(fuel) {
    const isSelf = fuel === this;
    if (!fuel || isSelf)
      return;
    fuel.on(FuelWalletEvents.connectors, (connectors) => {
      this.connectors = connectors;
      this.emit(FuelWalletEvents.connectors, connectors);
    });
    fuel.on(FuelWalletEvents.currentConnector, (connector) => {
      this.selectConnector(connector.name);
    });
    this.connectors = fuel.listConnectors();
    this.emit(FuelWalletEvents.connectors, this.listConnectors());
    this.selectConnector(fuel.connectorName);
  }
  handleFuelInjected() {
    if (this._retry === 9) {
      clearInterval(this._injectionTimeout);
      this._hasWallet.resolve(false);
      this.client.rejectAllPendingRequests(
        "Timeout fuel not detected on the window!"
      );
      return;
    }
    this._retry++;
    if (hasWindow) {
      if (!this.isListenerAdded) {
        window.addEventListener(EVENT_MESSAGE, this.onMessage.bind(this));
        this.isListenerAdded = true;
      }
      if (window.fuel) {
        clearInterval(this._injectionTimeout);
        this._hasWallet.resolve(true);
        this.bindFuelConnectors(window.fuel);
        this.executeQueuedRequests();
      }
    }
  }
};
function getTransactionSigner(transaction) {
  const address = transaction.inputs?.map((i) => {
    switch (i.type) {
      case fuels.InputType.Message:
        return i.recipient;
      case fuels.InputType.Coin:
        return i.owner;
      default:
        return void 0;
    }
  })[0];
  if (!address) {
    throw new Error("No possible signer found!");
  }
  return fuels.Address.fromB256(fuels.hexlify(address)).toString();
}

// src/FuelWalletConnection.ts
var FuelWalletConnection = class extends WindowConnection {
  async ping() {
    return this.client.timeout(1e3).request("ping", {});
  }
  async isConnected() {
    try {
      return await this.client.request("isConnected", {});
    } catch {
      return false;
    }
  }
  async connect() {
    return this.client.request("connect", {});
  }
  async disconnect() {
    return this.client.request("disconnect", {});
  }
  async accounts() {
    return this.client.request("accounts", {});
  }
  async currentAccount() {
    return this.client.request("currentAccount", {});
  }
  async signMessage(address, message) {
    if (!message.trim()) {
      throw new Error("Message is required");
    }
    return this.client.request("signMessage", {
      address,
      message
    });
  }
  async sendTransaction(transaction, providerConfig, signer) {
    if (!transaction) {
      throw new Error("Transaction is required");
    }
    const txRequest = fuels.transactionRequestify(transaction);
    const address = signer || transaction.signer || getTransactionSigner(txRequest);
    return this.client.request("sendTransaction", {
      address,
      provider: providerConfig,
      transaction: JSON.stringify(txRequest)
    });
  }
  async assets() {
    return this.client.request("assets", {});
  }
  async addAsset(asset) {
    return this.addAssets([asset]);
  }
  async addAssets(assets) {
    return this.client.request("addAssets", {
      assets
    });
  }
  async addAbi(abiMap) {
    return this.client.request("addAbi", {
      abiMap
    });
  }
  async getAbi(contractId) {
    return this.client.request("getAbi", {
      contractId
    });
  }
  async hasAbi(contractId) {
    const abi = await this.getAbi(contractId);
    return !!abi;
  }
  async network() {
    return this.client.request("network", {});
  }
  async networks() {
    return this.client.request("networks", {});
  }
  async addNetwork(network) {
    return this.client.request("addNetwork", { network });
  }
  async version() {
    return this.client.request("version", {});
  }
  on(eventName, listener) {
    return super.on(eventName, listener);
  }
};
var FuelWalletLocked = class extends fuels.WalletLocked {
  constructor(address, provider) {
    super(address, provider);
    this.provider = provider;
  }
  async signMessage(message) {
    return this.provider.walletConnection.signMessage(
      this.address.toString(),
      message
    );
  }
  async sendTransaction(transaction) {
    return this.provider.sendTransaction({
      ...transaction,
      signer: this.address.toString()
    });
  }
};
var FuelWalletProvider = class _FuelWalletProvider extends fuels.Provider {
  constructor(url, options) {
    super(url, options);
    this.walletConnection = options.walletConnection;
  }
  static async create(url, options) {
    const provider = new _FuelWalletProvider(url, options);
    await provider.fetchChainAndNodeInfo();
    return provider;
  }
  async sendTransaction(transactionRequestLike) {
    const transactionId = await this.walletConnection.sendTransaction(
      transactionRequestLike,
      { url: this.url }
    );
    const response = new fuels.TransactionResponse(transactionId, this);
    return response;
  }
};

// src/Fuel.ts
var FuelWeb3Privates = {};
var Fuel = class extends FuelWalletConnection {
  constructor() {
    super(...arguments);
    this.utils = {
      // TODO: remove createAddress once fuels-ts replace input
      // class address with string. The warn message is to avoid
      // developers to use this method.
      createAddress: (address) => {
        console.warn(
          "Do not use this method! It will be removed in the next release."
        );
        return fuels.Address.fromString(address);
      }
    };
    // Externalize events names
    this.events = FuelWalletEvents;
  }
  async getProvider() {
    const providerConfig = await this.network();
    if (FuelWeb3Privates.provider) {
      return FuelWeb3Privates.provider;
    }
    const provider = await FuelWalletProvider.create(providerConfig.url, {
      walletConnection: this
    });
    FuelWeb3Privates.provider = provider;
    this.on(FuelWalletEvents.network, async (network) => {
      FuelWeb3Privates.provider?.switchUrl(network.url);
    });
    return FuelWeb3Privates.provider;
  }
  async getWallet(address) {
    const provider = await this.getProvider();
    return new FuelWalletLocked(address, provider);
  }
};

// src/utils/blockExplorer.ts
var BLOCK_EXPLORER_URL = "https://fuellabs.github.io/block-explorer-v2/";
function getBlockExplorerLink({
  path,
  providerUrl
}) {
  return `${BLOCK_EXPLORER_URL}${path}${providerUrl ? `?providerUrl=${encodeURIComponent(providerUrl)}` : ""}`;
}

// src/utils/createReadOnly.ts
var createReadOnly = (fuel) => {
  return new Proxy(fuel, {
    get(target, prop) {
      return target[prop];
    },
    set(target, key, value) {
      if (Object.hasOwn(target, key) && ["_eventsCount", "_events", "connectorName"].includes(key)) {
        target[key] = value;
        return true;
      }
      return false;
    },
    defineProperty(target, key) {
      if (Object.hasOwn(target, key))
        return target[key];
      return false;
    },
    deleteProperty() {
      return false;
    }
  });
};

// src/utils/createConnector.ts
function injectFuel(fuel, target) {
  const fuelObj = createReadOnly(fuel);
  Object.defineProperty(target, "fuel", {
    value: fuel,
    writable: false,
    enumerable: true,
    configurable: true
  });
  if (typeof document !== "undefined") {
    const fuelLoadedEvent = new CustomEvent("FuelLoaded", {
      detail: fuelObj
    });
    document.dispatchEvent(fuelLoadedEvent);
  }
}
function createConnector(connector, target = window) {
  if (target?.fuel) {
    target.fuel.addConnector(connector);
    return;
  }
  injectFuel(new Fuel(connector), target);
}

// src/utils/provider.ts
var getGasConfig = async (provider) => {
  const chain = await provider.getChain();
  const nodeInfo = await provider.fetchNode();
  return {
    gasLimit: chain.consensusParameters.maxGasPerTx,
    gasPrice: nodeInfo.minGasPrice
  };
};
var ContentProxyConnection = class _ContentProxyConnection {
  constructor(connectorName) {
    this.onDisconnect = () => {
      clearInterval(this._tryReconect);
      this._tryReconect = setInterval(() => {
        console.debug("[FUEL WALLET] reconnecting!");
        try {
          this.connection = this.connect();
          console.debug("[FUEL WALLET] reconnected!");
          clearInterval(this._tryReconect);
        } catch (err) {
          if (err.message === "Extension context invalidated.") {
            clearInterval(this._tryReconect);
            console.debug("[FUEL WALLET] context invalidated!");
          }
        }
      }, RECONNECT_TIMEOUT);
    };
    this.keepAlive = () => {
      try {
        this.connection.postMessage({
          target: BACKGROUND_SCRIPT_NAME,
          type: "ping" /* ping */
        });
        this._keepAlive = setTimeout(this.keepAlive, PING_TIMEOUT);
      } catch (err) {
        this.onDisconnect();
      }
    };
    this.onMessageFromExtension = (message) => {
      const shouldAcceptMessage = message.target === CONTENT_SCRIPT_NAME;
      if (shouldAcceptMessage) {
        this.postMessage(message);
      }
    };
    this.onMessageFromWindow = (message) => {
      const { data: event, origin } = Object.freeze(message);
      if (this.shouldAcceptMessage(event, origin)) {
        if (event.type === "request" /* request */ && event.request.method === "connectorName") {
          this.sendConnectorName(event.request.id);
        } else {
          this.connection.postMessage({
            ...event,
            target: BACKGROUND_SCRIPT_NAME
          });
        }
      }
    };
    this.connection = this.connect();
    this.connectorName = connectorName;
    window.addEventListener(EVENT_MESSAGE, this.onMessageFromWindow);
    this.keepAlive();
  }
  connect() {
    const connection = chrome.runtime.connect(chrome.runtime.id, {
      name: BACKGROUND_SCRIPT_NAME
    });
    connection.onMessage.addListener(this.onMessageFromExtension);
    connection.onDisconnect.addListener(this.onDisconnect);
    return connection;
  }
  destroy() {
    this.connection.disconnect();
    clearInterval(this._tryReconect);
    clearTimeout(this._keepAlive);
  }
  static start(providerWallet) {
    return new _ContentProxyConnection(providerWallet);
  }
  shouldAcceptMessage(event, origin) {
    return origin === window.location.origin && event.target === CONTENT_SCRIPT_NAME && event.connectorName === this.connectorName;
  }
  sendConnectorName(id) {
    this.postMessage({
      type: "response" /* response */,
      response: jsonRpc2_0.createJSONRPCSuccessResponse(id, this.connectorName),
      target: this.connectorName
    });
  }
  postMessage(message) {
    const postMessage = {
      ...message,
      target: this.connectorName
    };
    window.postMessage(postMessage, window.location.origin);
  }
};

// src/connections/ExtensionPageConnection.ts
var ExtensionPageConnection = class extends BaseConnection {
  constructor() {
    super();
    this.connection = chrome.runtime.connect(chrome.runtime.id, {
      name: BACKGROUND_SCRIPT_NAME
    });
    this.connection.onMessage.addListener(this.onCommunicationMessage);
    this.ready();
  }
  allowMessage(message) {
    return message.target === POPUP_SCRIPT_NAME;
  }
  sendResponse(response, message) {
    if (!response)
      return;
    const responseMessage = {
      id: message.id,
      target: BACKGROUND_SCRIPT_NAME,
      type: "response" /* response */,
      response
    };
    this.connection.postMessage(responseMessage);
    this.onResponseSent();
  }
  onResponseSent() {
    window.close();
  }
  ready() {
    const session = new URLSearchParams(window.location.search).get("s");
    this.connection.postMessage({
      target: BACKGROUND_SCRIPT_NAME,
      type: "uiEvent" /* uiEvent */,
      ready: true,
      session
    });
  }
  destroy() {
    this.connection.disconnect();
  }
};

exports.AddressType = AddressType;
exports.BACKGROUND_SCRIPT_NAME = BACKGROUND_SCRIPT_NAME;
exports.BLOCK_EXPLORER_URL = BLOCK_EXPLORER_URL;
exports.BaseConnection = BaseConnection;
exports.CONTENT_SCRIPT_NAME = CONTENT_SCRIPT_NAME;
exports.ContentProxyConnection = ContentProxyConnection;
exports.EVENT_MESSAGE = EVENT_MESSAGE;
exports.ExtensionPageConnection = ExtensionPageConnection;
exports.Fuel = Fuel;
exports.FuelWalletConnection = FuelWalletConnection;
exports.FuelWalletEvents = FuelWalletEvents;
exports.FuelWalletLocked = FuelWalletLocked;
exports.FuelWalletProvider = FuelWalletProvider;
exports.MessageTypes = MessageTypes;
exports.POPUP_SCRIPT_NAME = POPUP_SCRIPT_NAME;
exports.VAULT_SCRIPT_NAME = VAULT_SCRIPT_NAME;
exports.WindowConnection = WindowConnection;
exports.createConnector = createConnector;
exports.createReadOnly = createReadOnly;
exports.createUUID = createUUID;
exports.deferPromise = deferPromise;
exports.getBlockExplorerLink = getBlockExplorerLink;
exports.getGasConfig = getGasConfig;
exports.getTransactionSigner = getTransactionSigner;
exports.hasWindow = hasWindow;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map